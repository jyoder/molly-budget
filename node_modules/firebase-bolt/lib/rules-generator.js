"use strict";
exports.__esModule = true;
/*
 * Copyright 2015 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var util = require("./util");
var ast = require("./ast");
var logger_1 = require("./logger");
var parser = require('./rules-parser');
var parse_util_1 = require("./parse-util");
var errors = {
    badIndex: "The index function must return a String or an array of Strings.",
    noPaths: "Must have at least one path expression.",
    nonObject: "Type contains properties and must extend 'Object'.",
    missingSchema: "Missing definition for type.",
    recursive: "Recursive function call.",
    mismatchParams: "Incorrect number of function arguments.",
    generateFailed: "Could not generate JSON: ",
    noSuchType: "No type definition for: ",
    badSchemaMethod: "Unsupported method name in type statement: ",
    badPathMethod: "Unsupported method name in path statement: ",
    badWriteAlias: "Cannot have both a write() method and a write-aliasing method: ",
    coercion: "Cannot convert value: ",
    undefinedFunction: "Undefined function: ",
    application: "Bolt application error: ",
    invalidGeneric: "Invalid generic schema usage: ",
    invalidMapKey: "Map<Key, T> - Key must derive from String type.",
    invalidWildChildren: "Types can have at most one $wild property and cannot mix with other properties.",
    invalidPropertyName: "Property names cannot contain any of: . $ # [ ] / or control characters: "
};
var INVALID_KEY_REGEX = /[\[\].#$\/\u0000-\u001F\u007F]/;
;
var builtinSchemaNames = ['Any', 'Null', 'String', 'Number', 'Boolean', 'Object'];
// Method names allowed in Bolt files.
var valueMethods = ['length', 'includes', 'startsWith', 'beginsWith', 'endsWith',
    'replace', 'toLowerCase', 'toUpperCase', 'test', 'contains',
    'matches'];
// TODO: Make sure users don't call internal methods...make private to impl.
var snapshotMethods = ['parent', 'child', 'hasChildren', 'val', 'isString', 'isNumber',
    'isBoolean'].concat(valueMethods);
var writeAliases = {
    'create': parse_util_1.parseExpression('prior(this) == null'),
    'update': parse_util_1.parseExpression('prior(this) != null && this != null'),
    'delete': parse_util_1.parseExpression('prior(this) != null && this == null')
};
// Usage:
//   json = bolt.generate(bolt-text)
function generate(symbols) {
    if (typeof symbols === 'string') {
        symbols = parser.parse(symbols);
    }
    var gen = new Generator(symbols);
    return gen.generateRules();
}
exports.generate = generate;
// Symbols contains:
//   functions: {}
//   schema: {}
//   paths: {}
var Generator = /** @class */ (function () {
    function Generator(symbols) {
        this.symbols = symbols;
        this.validators = {};
        this.rules = {};
        this.errorCount = 0;
        this.runSilently = false;
        this.allowUndefinedFunctions = false;
        this.keyIndex = 0;
        // TODO: globals should be part of this.symbols (nested scopes)
        this.globals = {
            "root": ast.call(ast.variable('@root'))
        };
        this.registerBuiltinSchema();
    }
    // Return Firebase compatible Rules JSON for a the given symbols definitions.
    Generator.prototype.generateRules = function () {
        var _this = this;
        this.errorCount = 0;
        var paths = this.symbols.paths;
        var schema = this.symbols.schema;
        var name;
        paths.forEach(function (path) {
            _this.validateMethods(errors.badPathMethod, path.methods, ['validate', 'read', 'write', 'index']);
        });
        for (name in schema) {
            if (!util.arrayIncludes(builtinSchemaNames, name)) {
                this.validateMethods(errors.badSchemaMethod, schema[name].methods, ['validate', 'read', 'write']);
            }
        }
        if (paths.length === 0) {
            this.fatal(errors.noPaths);
        }
        paths.forEach(function (path) { return _this.updateRules(path); });
        this.convertExpressions(this.rules);
        if (this.errorCount !== 0) {
            throw new Error(errors.generateFailed + this.errorCount + " errors.");
        }
        util.deletePropName(this.rules, '.scope');
        util.pruneEmptyChildren(this.rules);
        return {
            rules: this.rules
        };
    };
    Generator.prototype.validateMethods = function (m, methods, allowed) {
        var _this = this;
        if (util.arrayIncludes(allowed, 'write')) {
            allowed = allowed.concat(Object.keys(writeAliases));
        }
        for (var method in methods) {
            if (!util.arrayIncludes(allowed, method)) {
                logger_1.warn(m + util.quoteString(method) +
                    " (allowed: " + allowed.map(util.quoteString).join(', ') + ")");
            }
        }
        if ('write' in methods) {
            Object.keys(writeAliases).forEach(function (alias) {
                if (alias in methods) {
                    _this.fatal(errors.badWriteAlias + alias);
                }
            });
        }
    };
    Generator.prototype.registerBuiltinSchema = function () {
        var self = this;
        var thisVar = ast.variable('this');
        function registerAsCall(name, methodName) {
            self.symbols.registerSchema(name, ast.typeType('Any'), undefined, {
                validate: ast.method(['this'], ast.call(ast.reference(ast.cast(thisVar, 'Any'), ast.string(methodName))))
            });
        }
        this.symbols.registerSchema('Any', ast.typeType('Any'), undefined, {
            validate: ast.method(['this'], ast.boolean(true))
        });
        registerAsCall('Object', 'hasChildren');
        // Because of the way firebase treats Null values, there is no way to
        // write a validation rule, that will EVER be called with this == null
        // (firebase allows values to be deleted no matter their validation rules).
        // So, comparing this == null will always return false -> that is what
        // we do here, which will be optimized away if ORed with other validations.
        this.symbols.registerSchema('Null', ast.typeType('Any'), undefined, {
            validate: ast.method(['this'], ast.boolean(false))
        });
        self.symbols.registerSchema('String', ast.typeType('Any'), undefined, {
            validate: ast.method(['this'], ast.call(ast.reference(ast.cast(thisVar, 'Any'), ast.string('isString')))),
            includes: ast.method(['this', 's'], ast.call(ast.reference(ast.value(thisVar), ast.string('contains')), [ast.value(ast.variable('s'))])),
            startsWith: ast.method(['this', 's'], ast.call(ast.reference(ast.value(thisVar), ast.string('beginsWith')), [ast.value(ast.variable('s'))])),
            endsWith: ast.method(['this', 's'], ast.call(ast.reference(ast.value(thisVar), ast.string('endsWith')), [ast.value(ast.variable('s'))])),
            replace: ast.method(['this', 's', 'r'], ast.call(ast.reference(ast.value(thisVar), ast.string('replace')), [ast.value(ast.variable('s')), ast.value(ast.variable('r'))])),
            test: ast.method(['this', 'r'], ast.call(ast.reference(ast.value(thisVar), ast.string('matches')), [ast.call(ast.variable('@RegExp'), [ast.variable('r')])]))
        });
        registerAsCall('Number', 'isNumber');
        registerAsCall('Boolean', 'isBoolean');
        this.symbols.registerFunction('@RegExp', ['r'], ast.builtin(this.ensureType.bind(this, 'RegExp')));
        var map = this.symbols.registerSchema('Map', ast.typeType('Any'), undefined, undefined, ['Key', 'Value']);
        map.getValidator = this.getMapValidator.bind(this);
    };
    // type Map<Key, Value> => {
    //   $key: {
    //     '.validate': $key instanceof Key and this instanceof Value;
    //   '.validate': 'newData.hasChildren()'
    // }
    // Key must derive from String
    Generator.prototype.getMapValidator = function (params) {
        var keyType = params[0];
        var valueType = params[1];
        if (keyType.type !== 'type' || !this.symbols.isDerivedFrom(keyType, 'String')) {
            throw new Error(errors.invalidMapKey + "  (" + ast.decodeExpression(keyType) + " does not)");
        }
        var validator = {};
        var index = this.uniqueKey();
        validator[index] = {};
        extendValidator(validator, this.ensureValidator(ast.typeType('Object')));
        // First validate the key (omit terminal String type validation).
        while (keyType.name !== 'String') {
            var schema = this.symbols.schema[keyType.name];
            if (schema.methods['validate']) {
                var exp = this.partialEval(schema.methods['validate'].body, { 'this': ast.literal(index) });
                extendValidator(validator[index], { '.validate': [exp] });
            }
            keyType = schema.derivedFrom;
        }
        extendValidator(validator[index], this.ensureValidator(valueType));
        return validator;
    };
    Generator.prototype.uniqueKey = function () {
        this.keyIndex += 1;
        return '$key' + this.keyIndex;
    };
    // Collection schema has exactly one $wildchild property
    Generator.prototype.isCollectionSchema = function (schema) {
        var props = Object.keys(schema.properties);
        var result = props.length === 1 && props[0][0] === '$';
        return result;
    };
    // Ensure we have a definition for a validator for the given schema.
    Generator.prototype.ensureValidator = function (type) {
        var key = ast.decodeExpression(type);
        if (!this.validators[key]) {
            this.validators[key] = { '.validate': ast.literal('***TYPE RECURSION***') };
            var allowSave = this.allowUndefinedFunctions;
            this.allowUndefinedFunctions = true;
            this.validators[key] = this.createValidator(type);
            this.allowUndefinedFunctions = allowSave;
        }
        return this.validators[key];
    };
    Generator.prototype.createValidator = function (type) {
        var _this = this;
        switch (type.type) {
            case 'type':
                return this.createValidatorFromSchemaName(type.name);
            case 'union':
                var union_1 = {};
                type.types.forEach(function (typePart) {
                    // Make a copy
                    var singleType = extendValidator({}, _this.ensureValidator(typePart));
                    mapValidator(singleType, ast.andArray);
                    extendValidator(union_1, singleType);
                });
                mapValidator(union_1, ast.orArray);
                return union_1;
            case 'generic':
                var genericType = type;
                return this.createValidatorFromGeneric(genericType.name, genericType.params);
            default:
                throw new Error(errors.application + "invalid internal type: " + type.type);
        }
    };
    Generator.prototype.createValidatorFromGeneric = function (schemaName, params) {
        var schema = this.symbols.schema[schemaName];
        if (schema === undefined || !ast.Schema.isGeneric(schema)) {
            throw new Error(errors.noSuchType + schemaName + " (generic)");
        }
        var schemaParams = schema.params;
        if (params.length !== schemaParams.length) {
            throw new Error(errors.invalidGeneric + " expected <" + schemaParams.join(', ') + ">");
        }
        // Call custom validator, if given.
        if (schema.getValidator) {
            return schema.getValidator(params);
        }
        var bindings = {};
        for (var i = 0; i < params.length; i++) {
            bindings[schemaParams[i]] = params[i];
        }
        // Expand generics and generate validator from schema.
        schema = this.replaceGenericsInSchema(schema, bindings);
        return this.createValidatorFromSchema(schema);
    };
    Generator.prototype.replaceGenericsInSchema = function (schema, bindings) {
        var _this = this;
        var expandedSchema = {
            derivedFrom: this.replaceGenericsInExp(schema.derivedFrom, bindings),
            properties: {},
            methods: {}
        };
        var props = Object.keys(schema.properties);
        props.forEach(function (prop) {
            expandedSchema.properties[prop] =
                _this.replaceGenericsInExp(schema.properties[prop], bindings);
        });
        var methods = Object.keys(schema.methods);
        methods.forEach(function (methodName) {
            expandedSchema.methods[methodName] = _this.replaceGenericsInMethod(schema.methods[methodName], bindings);
        });
        return expandedSchema;
    };
    Generator.prototype.replaceGenericsInExp = function (exp, bindings) {
        var self = this;
        function replaceGenericsInArray(exps) {
            return exps.map(function (expPart) {
                return self.replaceGenericsInExp(expPart, bindings);
            });
        }
        switch (exp.type) {
            case 'op':
            case 'call':
                var opType = ast.copyExp(exp);
                opType.args = replaceGenericsInArray(opType.args);
                return opType;
            case 'type':
                var simpleType = exp;
                return bindings[simpleType.name] || simpleType;
            case 'union':
                var unionType = exp;
                return ast.unionType(replaceGenericsInArray(unionType.types));
            case 'generic':
                var genericType = exp;
                return ast.genericType(genericType.name, replaceGenericsInArray(genericType.params));
            default:
                return exp;
        }
    };
    Generator.prototype.replaceGenericsInMethod = function (method, bindings) {
        var expandedMethod = {
            params: method.params,
            body: method.body
        };
        expandedMethod.body = this.replaceGenericsInExp(method.body, bindings);
        return expandedMethod;
    };
    Generator.prototype.createValidatorFromSchemaName = function (schemaName) {
        var schema = this.symbols.schema[schemaName];
        if (!schema) {
            throw new Error(errors.noSuchType + schemaName);
        }
        if (ast.Schema.isGeneric(schema)) {
            throw new Error(errors.noSuchType + schemaName + " used as non-generic type.");
        }
        return this.createValidatorFromSchema(schema);
    };
    Generator.prototype.createValidatorFromSchema = function (schema) {
        var _this = this;
        var hasProps = Object.keys(schema.properties).length > 0 &&
            !this.isCollectionSchema(schema);
        if (hasProps && !this.symbols.isDerivedFrom(schema.derivedFrom, 'Object')) {
            this.fatal(errors.nonObject + " (is " + ast.decodeExpression(schema.derivedFrom) + ")");
            return {};
        }
        var validator = {};
        if (!(schema.derivedFrom.type === 'type' &&
            schema.derivedFrom.name === 'Any')) {
            extendValidator(validator, this.ensureValidator(schema.derivedFrom));
        }
        var requiredProperties = [];
        var wildProperties = 0;
        Object.keys(schema.properties).forEach(function (propName) {
            if (propName[0] === '$') {
                wildProperties += 1;
                if (INVALID_KEY_REGEX.test(propName.slice(1))) {
                    _this.fatal(errors.invalidPropertyName + propName);
                }
            }
            else {
                if (INVALID_KEY_REGEX.test(propName)) {
                    _this.fatal(errors.invalidPropertyName + propName);
                }
            }
            if (!validator[propName]) {
                validator[propName] = {};
            }
            var propType = schema.properties[propName];
            if (propName[0] !== '$' && !_this.isNullableType(propType)) {
                requiredProperties.push(propName);
            }
            extendValidator(validator[propName], _this.ensureValidator(propType));
        });
        if (wildProperties > 1 || wildProperties === 1 && requiredProperties.length > 0) {
            this.fatal(errors.invalidWildChildren);
        }
        if (requiredProperties.length > 0) {
            // this.hasChildren(requiredProperties)
            extendValidator(validator, { '.validate': [hasChildrenExp(requiredProperties)] });
        }
        // Disallow $other properties by default
        if (hasProps) {
            validator['$other'] = {};
            extendValidator(validator['$other'], { '.validate': ast.boolean(false) });
        }
        this.extendValidationMethods(validator, schema.methods);
        return validator;
    };
    Generator.prototype.isNullableType = function (type) {
        var result = this.symbols.isDerivedFrom(type, 'Null') ||
            this.symbols.isDerivedFrom(type, 'Map');
        return result;
    };
    // Update rules based on the given path expression.
    Generator.prototype.updateRules = function (path) {
        var i;
        var location = util.ensureObjectPath(this.rules, path.template.getLabels());
        var exp;
        extendValidator(location, this.ensureValidator(path.isType));
        location['.scope'] = path.template.getScope();
        this.extendValidationMethods(location, path.methods);
        // Write indices
        if (path.methods['index']) {
            switch (path.methods['index'].body.type) {
                case 'String':
                    exp = ast.array([path.methods['index'].body]);
                    break;
                case 'Array':
                    exp = path.methods['index'].body;
                    break;
                default:
                    this.fatal(errors.badIndex);
                    return;
            }
            var indices = [];
            for (i = 0; i < exp.value.length; i++) {
                if (exp.value[i].type !== 'String') {
                    this.fatal(errors.badIndex + " (not " + exp.value[i].type + ")");
                }
                else {
                    indices.push(exp.value[i].value);
                }
            }
            // TODO: Error check not over-writing index rules.
            location['.indexOn'] = indices;
        }
    };
    Generator.prototype.extendValidationMethods = function (validator, methods) {
        var writeMethods = [];
        ['create', 'update', 'delete'].forEach(function (method) {
            if (method in methods) {
                writeMethods.push(ast.andArray([writeAliases[method], methods[method].body]));
            }
        });
        if (writeMethods.length !== 0) {
            extendValidator(validator, { '.write': ast.orArray(writeMethods) });
        }
        ['validate', 'read', 'write'].forEach(function (method) {
            if (method in methods) {
                var methodValidator = {};
                methodValidator['.' + method] = methods[method].body;
                extendValidator(validator, methodValidator);
            }
        });
    };
    // Return union validator (||) over each schema
    Generator.prototype.unionValidators = function (schema) {
        var union = {};
        schema.forEach(function (typeName) {
            // First and the validator terms for a single type
            // Todo extend to unions and generics
            var singleType = extendValidator({}, this.ensureValidator(typeName));
            mapValidator(singleType, ast.andArray);
            extendValidator(union, singleType);
        }.bind(this));
        mapValidator(union, ast.orArray);
        return union;
    };
    // Convert expressions to text, and at the same time, apply pruning operations
    // to remove no-op rules.
    Generator.prototype.convertExpressions = function (validator) {
        var _this = this;
        var methodThisIs = { '.validate': 'newData',
            '.read': 'data',
            '.write': 'newData' };
        function hasWildcardSibling(path) {
            var parts = path.getLabels();
            var childPart = parts.pop();
            var parent = util.deepLookup(validator, parts);
            if (parent === undefined) {
                return false;
            }
            for (var _i = 0, _a = Object.keys(parent); _i < _a.length; _i++) {
                var prop = _a[_i];
                if (prop === childPart) {
                    continue;
                }
                if (prop[0] === '$') {
                    return true;
                }
            }
            return false;
        }
        mapValidator(validator, function (value, prop, scope, path) {
            if (prop in methodThisIs) {
                var result = _this.getExpressionText(ast.andArray(collapseHasChildren(value)), methodThisIs[prop], scope, path);
                // Remove no-op .read or .write rule if no sibling wildcard props.
                if ((prop === '.read' || prop === '.write') && result === 'false') {
                    if (!hasWildcardSibling(path)) {
                        return undefined;
                    }
                }
                // Remove no-op .validate rule if no sibling wildcard props.
                if (prop === '.validate' && result === 'true') {
                    if (!hasWildcardSibling(path)) {
                        return undefined;
                    }
                }
                return result;
            }
            return value;
        });
    };
    Generator.prototype.getExpressionText = function (exp, thisIs, scope, path) {
        if (!('type' in exp)) {
            throw new Error(errors.application + "Not an expression: " + util.prettyJSON(exp));
        }
        // First evaluate w/o binding of this to specific location.
        this.allowUndefinedFunctions = true;
        scope = util.extend({}, scope, { 'this': ast.cast(ast.call(ast.variable('@getThis')), 'Snapshot') });
        exp = this.partialEval(exp, scope);
        // Now re-evaluate the flattened expression.
        this.allowUndefinedFunctions = false;
        this.thisIs = thisIs;
        this.symbols.registerFunction('@getThis', [], ast.builtin(this.getThis.bind(this)));
        this.symbols.registerFunction('@root', [], ast.builtin(this.getRootReference.bind(this, path)));
        this.symbols.registerFunction('prior', ['exp'], ast.builtin(this.prior.bind(this)));
        this.symbols.registerFunction('key', [], ast.builtin(this.getKey.bind(this, path.length() === 0 ? '' : path.getPart(-1).label)));
        exp = this.partialEval(exp);
        delete this.symbols.functions['@getThis'];
        delete this.symbols.functions['@root'];
        delete this.symbols.functions['prior'];
        delete this.symbols.functions['key'];
        // Top level expressions should never be to a snapshot reference - should
        // always evaluate to a boolean.
        exp = ast.ensureBoolean(exp);
        return ast.decodeExpression(exp);
    };
    /*
     *  Wrapper for partialEval debugging.
     */
    Generator.prototype.partialEval = function (exp, params, functionCalls) {
        if (params === void 0) { params = {}; }
        if (functionCalls === void 0) { functionCalls = {}; }
        // Wrap real call for debugging.
        var result = this.partialEvalReal(exp, params, functionCalls);
        // console.log(ast.decodeExpression(exp) + " => " + ast.decodeExpression(result));
        return result;
    };
    // Partial evaluation of expressions - copy of expression tree (immutable).
    //
    // - Expand inline function calls.
    // - Replace local and global variables with their values.
    // - Expand snapshot references using child('ref').
    // - Coerce snapshot references to values as needed.
    Generator.prototype.partialEvalReal = function (exp, params, functionCalls) {
        if (params === void 0) { params = {}; }
        if (functionCalls === void 0) { functionCalls = {}; }
        var self = this;
        function subExpression(exp2) {
            return self.partialEval(exp2, params, functionCalls);
        }
        function valueExpression(exp2) {
            return ast.ensureValue(subExpression(exp2));
        }
        function booleanExpression(exp2) {
            return ast.ensureBoolean(subExpression(exp2));
        }
        function lookupVar(exp2) {
            // TODO: Unbound variable access should be an error.
            return params[exp2.name] || self.globals[exp2.name] || exp2;
        }
        // Convert ref[prop] => ref.child(prop)
        function snapshotChild(ref) {
            return ast.cast(ast.call(ast.reference(ref.base, ast.string('child')), [ref.accessor]), 'Snapshot');
        }
        switch (exp.type) {
            case 'op':
                var expOp = ast.copyExp(exp);
                // Ensure arguments are boolean (or values) where needed.
                if (expOp.op === 'value') {
                    expOp.args[0] = valueExpression(expOp.args[0]);
                }
                else if (expOp.op === '||' || expOp.op === '&&' || expOp.op === '!') {
                    for (var i = 0; i < expOp.args.length; i++) {
                        expOp.args[i] = booleanExpression(expOp.args[i]);
                    }
                }
                else if (expOp.op === '?:') {
                    expOp.args[0] = booleanExpression(expOp.args[0]);
                    expOp.args[1] = valueExpression(expOp.args[1]);
                    expOp.args[2] = valueExpression(expOp.args[2]);
                }
                else {
                    for (var i = 0; i < expOp.args.length; i++) {
                        expOp.args[i] = valueExpression(expOp.args[i]);
                    }
                }
                return expOp;
            case 'var':
                return lookupVar(exp);
            case 'ref':
                var expRef = ast.copyExp(exp);
                expRef.base = subExpression(expRef.base);
                // var[ref] => var[ref]
                if (expRef.base.valueType !== 'Snapshot') {
                    expRef.accessor = subExpression(expRef.accessor);
                    return expRef;
                }
                var propName = ast.getPropName(expRef);
                // snapshot.prop (static string property)
                if (propName !== '') {
                    // snapshot.valueMethod => snapshot.val().valueMethod
                    if (util.arrayIncludes(valueMethods, propName)) {
                        expRef.base = valueExpression(expRef.base);
                        return expRef;
                    }
                    // snapshot.ssMethod => snapshot.ssMethod
                    if (util.arrayIncludes(snapshotMethods, propName)) {
                        return expRef;
                    }
                }
                // snapshot[exp] => snapshot.child(exp) or
                // snapshot[ref] => snapshot.child(ref.val())
                expRef.accessor = valueExpression(expRef.accessor);
                return snapshotChild(expRef);
            case 'call':
                var expCall = ast.copyExp(exp);
                expCall.ref = subExpression(expCall.ref);
                var callee = this.lookupFunction(expCall.ref);
                // Expand the function call inline
                if (callee) {
                    var fn = callee.fn;
                    if (callee.self) {
                        expCall.args.unshift(ast.ensureValue(callee.self));
                    }
                    if (fn.params.length !== expCall.args.length) {
                        this.fatal(errors.mismatchParams + " ( " +
                            callee.methodName + " expects " + fn.params.length +
                            " but actually passed " + expCall.args.length + ")");
                        return exp;
                    }
                    if (fn.body.type === 'builtin') {
                        return fn.body.fn(expCall.args, params);
                    }
                    var innerParams = {};
                    for (var i = 0; i < fn.params.length; i++) {
                        innerParams[fn.params[i]] = subExpression(expCall.args[i]);
                    }
                    if (functionCalls[callee.methodName]) {
                        throw new Error(errors.recursive + " (" + callee.methodName + ")");
                    }
                    functionCalls[callee.methodName] = true;
                    var result = this.partialEval(fn.body, innerParams, functionCalls);
                    functionCalls[callee.methodName] = false;
                    return result;
                }
                // Can't expand function - but just expand the arguments.
                if (!this.allowUndefinedFunctions) {
                    var funcName = ast.getMethodName(expCall);
                    if (funcName !== '' && !(funcName in this.symbols.schema['String'].methods ||
                        util.arrayIncludes(snapshotMethods, funcName))) {
                        this.fatal(errors.undefinedFunction + ast.decodeExpression(expCall.ref));
                    }
                }
                for (var i = 0; i < expCall.args.length; i++) {
                    expCall.args[i] = subExpression(expCall.args[i]);
                }
                // Hack for snapshot.parent().val()
                // Todo - build table-based method signatures.
                if (ast.getMethodName(expCall) === 'parent') {
                    expCall = ast.cast(expCall, 'Snapshot');
                }
                return expCall;
            // Expression types (like literals) than need no expansion.
            default:
                return exp;
        }
    };
    // Builtin function - convert all 'this' to 'data' (from 'newData').
    // Args are function arguments, and params are the local (function) scope variables.
    Generator.prototype.prior = function (args, params) {
        var lastThisIs = this.thisIs;
        this.thisIs = 'data';
        var exp = this.partialEval(args[0], params);
        this.thisIs = lastThisIs;
        return exp;
    };
    // Builtin function - current value of 'this'
    Generator.prototype.getThis = function (args, params) {
        return ast.snapshotVariable(this.thisIs);
    };
    // Builtin function - ensure type of argument
    Generator.prototype.ensureType = function (type, args, params) {
        if (args.length !== 1) {
            throw new Error(errors.application + "ensureType arguments.");
        }
        var exp = this.partialEval(args[0], params);
        if (exp.type !== type) {
            throw new Error(errors.coercion + ast.decodeExpression(exp) + " => " + type);
        }
        return exp;
    };
    // Builtin function - return the parent key of 'this'.
    Generator.prototype.getKey = function (key, args, params) {
        if (args.length !== 0) {
            throw new Error(errors.mismatchParams + "(found " + args.length + " but expected 1)");
        }
        return key[0] === '$' ? ast.literal(key) : ast.string(key);
    };
    // Builtin function - return the reference to the root
    // When in read mode - use 'root'
    // When in write/validate - use path to root via newData.parent()...
    Generator.prototype.getRootReference = function (path, args, params) {
        if (args.length !== 0) {
            throw new Error(errors.application + "@root arguments.");
        }
        // 'data' case
        if (this.thisIs === 'data') {
            return ast.snapshotVariable('root');
        }
        // TODO(koss): Remove this special case if JSON supports newRoot instead.
        // 'newData' case - traverse to root via parent()'s.
        var result = ast.snapshotVariable('newData');
        for (var i = 0; i < path.length(); i++) {
            result = ast.snapshotParent(result);
        }
        return result;
    };
    // Lookup globally defined function.
    Generator.prototype.lookupFunction = function (ref) {
        // Function call.
        if (ref.type === 'var') {
            var refVar = ref;
            var fn = this.symbols.functions[refVar.name];
            if (!fn) {
                return undefined;
            }
            return { self: undefined, fn: fn, methodName: refVar.name };
        }
        // Method call.
        if (ref.type === 'ref') {
            var refRef = ref;
            // TODO: Require static type validation before calling String methods.
            if (refRef.base.op !== 'value' &&
                refRef.accessor.value in this.symbols.schema['String'].methods) {
                var methodName = refRef.accessor.value;
                return { self: refRef.base,
                    fn: this.symbols.schema['String'].methods[methodName],
                    methodName: 'String.' + methodName
                };
            }
        }
        return undefined;
    };
    Generator.prototype.fatal = function (s) {
        logger_1.error(s);
        this.errorCount += 1;
    };
    return Generator;
}());
exports.Generator = Generator;
;
// Merge all .X terms into target.
function extendValidator(target, src) {
    if (src === undefined) {
        throw new Error(errors.application + "Illegal validation source.");
    }
    for (var prop in src) {
        if (!src.hasOwnProperty(prop)) {
            continue;
        }
        if (prop[0] === '.') {
            if (target[prop] === undefined) {
                target[prop] = [];
            }
            if (util.isType(src[prop], 'array')) {
                util.extendArray(target[prop], src[prop]);
            }
            else {
                target[prop].push(src[prop]);
            }
        }
        else {
            if (!target[prop]) {
                target[prop] = {};
            }
            extendValidator(target[prop], src[prop]);
        }
    }
    return target;
}
exports.extendValidator = extendValidator;
// Call fn(value, prop, path) on all '.props' and assiging the value back into the
// validator.
function mapValidator(v, fn, scope, path) {
    if (!scope) {
        scope = {};
    }
    if (!path) {
        path = new ast.PathTemplate();
    }
    if ('.scope' in v) {
        scope = v['.scope'];
    }
    for (var prop in v) {
        if (!v.hasOwnProperty(prop)) {
            continue;
        }
        if (prop[0] === '.') {
            var value = fn(v[prop], prop, scope, path);
            if (value !== undefined) {
                v[prop] = value;
            }
            else {
                delete v[prop];
            }
        }
        else if (!util.isType(v[prop], 'object')) {
            continue;
        }
        else {
            var child = new ast.PathTemplate([prop]);
            path.push(child);
            mapValidator(v[prop], fn, scope, path);
            path.pop(child);
        }
    }
}
exports.mapValidator = mapValidator;
// Collapse all hasChildren calls into one (combining their arguments).
// E.g. [newData.hasChildren(), newData.hasChildren(['x']), newData.hasChildren(['y'])] =>
//      newData.hasChildren(['x', 'y'])
function collapseHasChildren(exps) {
    var hasHasChildren = false;
    var combined = [];
    var result = [];
    exps.forEach(function (exp) {
        if (exp.type !== 'call') {
            result.push(exp);
            return;
        }
        var expCall = exp;
        if (ast.getMethodName(expCall) !== 'hasChildren') {
            result.push(exp);
            return;
        }
        if (expCall.args.length === 0) {
            hasHasChildren = true;
            return;
        }
        // Expect one argument of Array type.
        if (expCall.args.length !== 1 || expCall.args[0].type !== 'Array') {
            throw new Error(errors.application + "Invalid argument to hasChildren(): " +
                expCall.args[0].type);
        }
        var args = expCall.args[0].value;
        args.forEach(function (arg) {
            hasHasChildren = true;
            if (arg.type !== 'String') {
                throw new Error(errors.application + "Expect string argument to hasChildren(), not: " +
                    arg.type);
            }
            combined.push(arg.value);
        });
    });
    if (hasHasChildren) {
        result.unshift(hasChildrenExp(combined));
    }
    return result;
}
// Generate this.hasChildren([props, ...]) or this.hasChildren()
function hasChildrenExp(props) {
    var args = props.length === 0 ? [] : [ast.array(props.map(ast.string))];
    return ast.call(ast.reference(ast.cast(ast.variable('this'), 'Any'), ast.string('hasChildren')), args);
}

//# sourceMappingURL=data:application/json;charset=utf8;base64,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TyxNQUFNLENBQUM7QUFDaEIsQ0FBQztBQUVELGdFQUFnRTtBQUNoRSx3QkFBd0IsS0FBZTtJQUNyQyxJQUFJLElBQUksR0FBRyxLQUFLLENBQUMsTUFBTSxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ3hFLE9BQU8sR0FBRyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsRUFBRSxLQUFLLENBQUMsRUFBRSxHQUFHLENBQUMsTUFBTSxDQUFDLGFBQWEsQ0FBQyxDQUFDLEVBQy9FLElBQUksQ0FBQyxDQUFDO0FBQ3hCLENBQUMiLCJmaWxlIjoicnVsZXMtZ2VuZXJhdG9yLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIENvcHlyaWdodCAyMDE1IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5pbXBvcnQgKiBhcyB1dGlsIGZyb20gJy4vdXRpbCc7XG5pbXBvcnQgKiBhcyBhc3QgZnJvbSAnLi9hc3QnO1xuaW1wb3J0IHt3YXJuLCBlcnJvcn0gZnJvbSAnLi9sb2dnZXInO1xubGV0IHBhcnNlciA9IHJlcXVpcmUoJy4vcnVsZXMtcGFyc2VyJyk7XG5pbXBvcnQge3BhcnNlRXhwcmVzc2lvbn0gZnJvbSAnLi9wYXJzZS11dGlsJztcblxudmFyIGVycm9ycyA9IHtcbiAgYmFkSW5kZXg6IFwiVGhlIGluZGV4IGZ1bmN0aW9uIG11c3QgcmV0dXJuIGEgU3RyaW5nIG9yIGFuIGFycmF5IG9mIFN0cmluZ3MuXCIsXG4gIG5vUGF0aHM6IFwiTXVzdCBoYXZlIGF0IGxlYXN0IG9uZSBwYXRoIGV4cHJlc3Npb24uXCIsXG4gIG5vbk9iamVjdDogXCJUeXBlIGNvbnRhaW5zIHByb3BlcnRpZXMgYW5kIG11c3QgZXh0ZW5kICdPYmplY3QnLlwiLFxuICBtaXNzaW5nU2NoZW1hOiBcIk1pc3NpbmcgZGVmaW5pdGlvbiBmb3IgdHlwZS5cIixcbiAgcmVjdXJzaXZlOiBcIlJlY3Vyc2l2ZSBmdW5jdGlvbiBjYWxsLlwiLFxuICBtaXNtYXRjaFBhcmFtczogXCJJbmNvcnJlY3QgbnVtYmVyIG9mIGZ1bmN0aW9uIGFyZ3VtZW50cy5cIixcbiAgZ2VuZXJhdGVGYWlsZWQ6IFwiQ291bGQgbm90IGdlbmVyYXRlIEpTT046IFwiLFxuICBub1N1Y2hUeXBlOiBcIk5vIHR5cGUgZGVmaW5pdGlvbiBmb3I6IFwiLFxuICBiYWRTY2hlbWFNZXRob2Q6IFwiVW5zdXBwb3J0ZWQgbWV0aG9kIG5hbWUgaW4gdHlwZSBzdGF0ZW1lbnQ6IFwiLFxuICBiYWRQYXRoTWV0aG9kOiBcIlVuc3VwcG9ydGVkIG1ldGhvZCBuYW1lIGluIHBhdGggc3RhdGVtZW50OiBcIixcbiAgYmFkV3JpdGVBbGlhczogXCJDYW5ub3QgaGF2ZSBib3RoIGEgd3JpdGUoKSBtZXRob2QgYW5kIGEgd3JpdGUtYWxpYXNpbmcgbWV0aG9kOiBcIixcbiAgY29lcmNpb246IFwiQ2Fubm90IGNvbnZlcnQgdmFsdWU6IFwiLFxuICB1bmRlZmluZWRGdW5jdGlvbjogXCJVbmRlZmluZWQgZnVuY3Rpb246IFwiLFxuICBhcHBsaWNhdGlvbjogXCJCb2x0IGFwcGxpY2F0aW9uIGVycm9yOiBcIixcbiAgaW52YWxpZEdlbmVyaWM6IFwiSW52YWxpZCBnZW5lcmljIHNjaGVtYSB1c2FnZTogXCIsXG4gIGludmFsaWRNYXBLZXk6IFwiTWFwPEtleSwgVD4gLSBLZXkgbXVzdCBkZXJpdmUgZnJvbSBTdHJpbmcgdHlwZS5cIixcbiAgaW52YWxpZFdpbGRDaGlsZHJlbjogXCJUeXBlcyBjYW4gaGF2ZSBhdCBtb3N0IG9uZSAkd2lsZCBwcm9wZXJ0eSBhbmQgY2Fubm90IG1peCB3aXRoIG90aGVyIHByb3BlcnRpZXMuXCIsXG4gIGludmFsaWRQcm9wZXJ0eU5hbWU6IFwiUHJvcGVydHkgbmFtZXMgY2Fubm90IGNvbnRhaW4gYW55IG9mOiAuICQgIyBbIF0gLyBvciBjb250cm9sIGNoYXJhY3RlcnM6IFwiLFxufTtcblxubGV0IElOVkFMSURfS0VZX1JFR0VYID0gL1tcXFtcXF0uIyRcXC9cXHUwMDAwLVxcdTAwMUZcXHUwMDdGXS87XG5cbi8qXG4gICBBIFZhbGlkYXRvciBpcyBhIEpTT04gaGVyaWFyY2hpY2FsIHN0cnVjdHVyZS4gVGhlIFwibGVhdmVzXCIgYXJlIFwiZG90LXByb3BlcnRpZXNcIlxuICAgKHNlZSBiZWxvdykuIFRoZSBpbnRlcm1lZGlhdGUgbm9kZXMgaW4gdGhlIHRyZWUgYXJlIFwicHJvcFwiIG9yIFwiJHByb3BcIlxuICAgcHJvcGVydGllcy5cblxuICAgQSBWYWxpZGF0b3IgaXMgbXV0YXRlZCB0byBoYXZlIGRpZmZlcmVudCBmb3JtcyBiYXNlZCBvbiB0aGUgdGhlIHBoYXNlIG9mXG4gICBnZW5lcmF0aW9uLlxuXG4gICBJbiB0aGUgZmlyc3QgcGhhc2UsIHRoZXkgYXJlIEV4cFtdLiBMYXRlciB0aGUgRXhwW10gYXJlIEFORGVkIHRvZ2V0aGVyIGFuZFxuICAgY29tYmluZWQgaW50byBleHByZXNzaW9uIHRleHQgKGFuZCByZXR1cm5lZCBhcyB0aGUgZmluYWwgSlNPTi1ydWxlcyB0aGF0XG4gICBGaXJlYmFzZSB1c2VzLlxuXG4gICBOb3RlOiBUUyBkb2VzIG5vdCBhbGxvdyBmb3Igc3BlY2lhbCBwcm9wZXJ0aWVzIHRvIGhhdmUgZGlzdGluY3RcbiAgIHR5cGVzIGZyb20gdGhlICdpbmRleCcgcHJvcGVydHkgZ2l2ZW4gZm9yIHRoZSBpbnRlcmZhY2UuICA6LShcblxuICAgJy5yZWFkJzogYXN0LkV4cFtdIHwgc3RyaW5nO1xuICAgJy53cml0ZSc6IGFzdC5FeHBbXSB8IHN0cmluZztcbiAgICcudmFsaWRhdGUnOiBhc3QuRXhwW10gfCBzdHJpbmc7XG4gICAnLmluZGV4T24nOiBzdHJpbmdbXTtcbiAgICcuc2NvcGUnOiB7IFt2YXJpYWJsZTogc3RyaW5nXTogc3RyaW5nIH1cbiovXG5leHBvcnQgdHlwZSBWYWxpZGF0b3JWYWx1ZSA9IGFzdC5FeHAgfCBhc3QuRXhwW10gfCBzdHJpbmcgfCBzdHJpbmdbXSB8IFZhbGlkYXRvcjtcbmV4cG9ydCBpbnRlcmZhY2UgVmFsaWRhdG9yIHtcbiAgW25hbWU6IHN0cmluZ106IFZhbGlkYXRvclZhbHVlO1xufTtcblxudmFyIGJ1aWx0aW5TY2hlbWFOYW1lcyA9IFsnQW55JywgJ051bGwnLCAnU3RyaW5nJywgJ051bWJlcicsICdCb29sZWFuJywgJ09iamVjdCddO1xuLy8gTWV0aG9kIG5hbWVzIGFsbG93ZWQgaW4gQm9sdCBmaWxlcy5cbnZhciB2YWx1ZU1ldGhvZHMgPSBbJ2xlbmd0aCcsICdpbmNsdWRlcycsICdzdGFydHNXaXRoJywgJ2JlZ2luc1dpdGgnLCAnZW5kc1dpdGgnLFxuICAgICAgICAgICAgICAgICAgICAncmVwbGFjZScsICd0b0xvd2VyQ2FzZScsICd0b1VwcGVyQ2FzZScsICd0ZXN0JywgJ2NvbnRhaW5zJyxcbiAgICAgICAgICAgICAgICAgICAgJ21hdGNoZXMnXTtcbi8vIFRPRE86IE1ha2Ugc3VyZSB1c2VycyBkb24ndCBjYWxsIGludGVybmFsIG1ldGhvZHMuLi5tYWtlIHByaXZhdGUgdG8gaW1wbC5cbnZhciBzbmFwc2hvdE1ldGhvZHMgPSBbJ3BhcmVudCcsICdjaGlsZCcsICdoYXNDaGlsZHJlbicsICd2YWwnLCAnaXNTdHJpbmcnLCAnaXNOdW1iZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAnaXNCb29sZWFuJ10uY29uY2F0KHZhbHVlTWV0aG9kcyk7XG5cbnZhciB3cml0ZUFsaWFzZXMgPSA8eyBbbWV0aG9kOiBzdHJpbmddOiBhc3QuRXhwIH0+IHtcbiAgJ2NyZWF0ZSc6IHBhcnNlRXhwcmVzc2lvbigncHJpb3IodGhpcykgPT0gbnVsbCcpLFxuICAndXBkYXRlJzogcGFyc2VFeHByZXNzaW9uKCdwcmlvcih0aGlzKSAhPSBudWxsICYmIHRoaXMgIT0gbnVsbCcpLFxuICAnZGVsZXRlJzogcGFyc2VFeHByZXNzaW9uKCdwcmlvcih0aGlzKSAhPSBudWxsICYmIHRoaXMgPT0gbnVsbCcpXG59O1xuXG4vLyBVc2FnZTpcbi8vICAganNvbiA9IGJvbHQuZ2VuZXJhdGUoYm9sdC10ZXh0KVxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlKHN5bWJvbHM6IHN0cmluZyB8IGFzdC5TeW1ib2xzKTogVmFsaWRhdG9yIHtcbiAgaWYgKHR5cGVvZiBzeW1ib2xzID09PSAnc3RyaW5nJykge1xuICAgIHN5bWJvbHMgPSBwYXJzZXIucGFyc2Uoc3ltYm9scyk7XG4gIH1cbiAgdmFyIGdlbiA9IG5ldyBHZW5lcmF0b3IoPGFzdC5TeW1ib2xzPiBzeW1ib2xzKTtcbiAgcmV0dXJuIGdlbi5nZW5lcmF0ZVJ1bGVzKCk7XG59XG5cbi8vIFN5bWJvbHMgY29udGFpbnM6XG4vLyAgIGZ1bmN0aW9uczoge31cbi8vICAgc2NoZW1hOiB7fVxuLy8gICBwYXRoczoge31cbmV4cG9ydCBjbGFzcyBHZW5lcmF0b3Ige1xuICBzeW1ib2xzOiBhc3QuU3ltYm9scztcbiAgdmFsaWRhdG9yczogeyBbc2NoZW1hTmFtZTogc3RyaW5nXTogVmFsaWRhdG9yOyB9O1xuICBydWxlczogVmFsaWRhdG9yO1xuICBlcnJvckNvdW50OiBudW1iZXI7XG4gIHJ1blNpbGVudGx5OiBib29sZWFuO1xuICBhbGxvd1VuZGVmaW5lZEZ1bmN0aW9uczogYm9vbGVhbjtcbiAgZ2xvYmFsczogYXN0LlBhcmFtcztcbiAgdGhpc0lzOiBzdHJpbmc7XG4gIGtleUluZGV4OiBudW1iZXI7XG5cbiAgY29uc3RydWN0b3Ioc3ltYm9sczogYXN0LlN5bWJvbHMpIHtcbiAgICB0aGlzLnN5bWJvbHMgPSBzeW1ib2xzO1xuICAgIHRoaXMudmFsaWRhdG9ycyA9IHt9O1xuICAgIHRoaXMucnVsZXMgPSB7fTtcbiAgICB0aGlzLmVycm9yQ291bnQgPSAwO1xuICAgIHRoaXMucnVuU2lsZW50bHkgPSBmYWxzZTtcbiAgICB0aGlzLmFsbG93VW5kZWZpbmVkRnVuY3Rpb25zID0gZmFsc2U7XG4gICAgdGhpcy5rZXlJbmRleCA9IDA7XG5cbiAgICAvLyBUT0RPOiBnbG9iYWxzIHNob3VsZCBiZSBwYXJ0IG9mIHRoaXMuc3ltYm9scyAobmVzdGVkIHNjb3BlcylcbiAgICB0aGlzLmdsb2JhbHMgPSB7XG4gICAgICBcInJvb3RcIjogYXN0LmNhbGwoYXN0LnZhcmlhYmxlKCdAcm9vdCcpKSxcbiAgICB9O1xuXG4gICAgdGhpcy5yZWdpc3RlckJ1aWx0aW5TY2hlbWEoKTtcbiAgfVxuXG4gIC8vIFJldHVybiBGaXJlYmFzZSBjb21wYXRpYmxlIFJ1bGVzIEpTT04gZm9yIGEgdGhlIGdpdmVuIHN5bWJvbHMgZGVmaW5pdGlvbnMuXG4gIGdlbmVyYXRlUnVsZXMoKTogVmFsaWRhdG9yIHtcbiAgICB0aGlzLmVycm9yQ291bnQgPSAwO1xuICAgIHZhciBwYXRocyA9IHRoaXMuc3ltYm9scy5wYXRocztcbiAgICB2YXIgc2NoZW1hID0gdGhpcy5zeW1ib2xzLnNjaGVtYTtcbiAgICB2YXIgbmFtZTogc3RyaW5nO1xuXG4gICAgcGF0aHMuZm9yRWFjaCgocGF0aCkgPT4ge1xuICAgICAgdGhpcy52YWxpZGF0ZU1ldGhvZHMoZXJyb3JzLmJhZFBhdGhNZXRob2QsIHBhdGgubWV0aG9kcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIFsndmFsaWRhdGUnLCAncmVhZCcsICd3cml0ZScsICdpbmRleCddKTtcbiAgICB9KTtcblxuICAgIGZvciAobmFtZSBpbiBzY2hlbWEpIHtcbiAgICAgIGlmICghdXRpbC5hcnJheUluY2x1ZGVzKGJ1aWx0aW5TY2hlbWFOYW1lcywgbmFtZSkpIHtcbiAgICAgICAgdGhpcy52YWxpZGF0ZU1ldGhvZHMoZXJyb3JzLmJhZFNjaGVtYU1ldGhvZCwgc2NoZW1hW25hbWVdLm1ldGhvZHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIFsndmFsaWRhdGUnLCAncmVhZCcsICd3cml0ZSddKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocGF0aHMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLmZhdGFsKGVycm9ycy5ub1BhdGhzKTtcbiAgICB9XG5cbiAgICBwYXRocy5mb3JFYWNoKChwYXRoKSA9PiB0aGlzLnVwZGF0ZVJ1bGVzKHBhdGgpKTtcbiAgICB0aGlzLmNvbnZlcnRFeHByZXNzaW9ucyh0aGlzLnJ1bGVzKTtcblxuICAgIGlmICh0aGlzLmVycm9yQ291bnQgIT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMuZ2VuZXJhdGVGYWlsZWQgKyB0aGlzLmVycm9yQ291bnQgKyBcIiBlcnJvcnMuXCIpO1xuICAgIH1cblxuICAgIHV0aWwuZGVsZXRlUHJvcE5hbWUodGhpcy5ydWxlcywgJy5zY29wZScpO1xuICAgIHV0aWwucHJ1bmVFbXB0eUNoaWxkcmVuKHRoaXMucnVsZXMpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHJ1bGVzOiB0aGlzLnJ1bGVzXG4gICAgfTtcbiAgfVxuXG4gIHZhbGlkYXRlTWV0aG9kcyhtOiBzdHJpbmcsIG1ldGhvZHM6IHsgW25hbWU6IHN0cmluZ106IGFzdC5NZXRob2QgfSwgYWxsb3dlZDogc3RyaW5nW10pIHtcbiAgICBpZiAodXRpbC5hcnJheUluY2x1ZGVzKGFsbG93ZWQsICd3cml0ZScpKSB7XG4gICAgICBhbGxvd2VkID0gYWxsb3dlZC5jb25jYXQoT2JqZWN0LmtleXMod3JpdGVBbGlhc2VzKSk7XG4gICAgfVxuICAgIGZvciAodmFyIG1ldGhvZCBpbiBtZXRob2RzKSB7XG4gICAgICBpZiAoIXV0aWwuYXJyYXlJbmNsdWRlcyhhbGxvd2VkLCBtZXRob2QpKSB7XG4gICAgICAgIHdhcm4obSArIHV0aWwucXVvdGVTdHJpbmcobWV0aG9kKSArXG4gICAgICAgICAgICAgXCIgKGFsbG93ZWQ6IFwiICsgYWxsb3dlZC5tYXAodXRpbC5xdW90ZVN0cmluZykuam9pbignLCAnKSArIFwiKVwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCd3cml0ZScgaW4gbWV0aG9kcykge1xuICAgICAgT2JqZWN0LmtleXMod3JpdGVBbGlhc2VzKS5mb3JFYWNoKChhbGlhcykgPT4ge1xuICAgICAgICBpZiAoYWxpYXMgaW4gbWV0aG9kcykge1xuICAgICAgICAgIHRoaXMuZmF0YWwoZXJyb3JzLmJhZFdyaXRlQWxpYXMgKyBhbGlhcyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHJlZ2lzdGVyQnVpbHRpblNjaGVtYSgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHRoaXNWYXIgPSBhc3QudmFyaWFibGUoJ3RoaXMnKTtcblxuICAgIGZ1bmN0aW9uIHJlZ2lzdGVyQXNDYWxsKG5hbWU6IHN0cmluZywgbWV0aG9kTmFtZTogc3RyaW5nKTogdm9pZCB7XG4gICAgICBzZWxmLnN5bWJvbHMucmVnaXN0ZXJTY2hlbWEobmFtZSwgYXN0LnR5cGVUeXBlKCdBbnknKSwgdW5kZWZpbmVkLCB7XG4gICAgICAgIHZhbGlkYXRlOiBhc3QubWV0aG9kKFsndGhpcyddLCBhc3QuY2FsbChhc3QucmVmZXJlbmNlKGFzdC5jYXN0KHRoaXNWYXIsICdBbnknKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXN0LnN0cmluZyhtZXRob2ROYW1lKSkpKVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5zeW1ib2xzLnJlZ2lzdGVyU2NoZW1hKCdBbnknLCBhc3QudHlwZVR5cGUoJ0FueScpLCB1bmRlZmluZWQsIHtcbiAgICAgIHZhbGlkYXRlOiBhc3QubWV0aG9kKFsndGhpcyddLCBhc3QuYm9vbGVhbih0cnVlKSlcbiAgICB9KTtcblxuICAgIHJlZ2lzdGVyQXNDYWxsKCdPYmplY3QnLCAnaGFzQ2hpbGRyZW4nKTtcblxuICAgIC8vIEJlY2F1c2Ugb2YgdGhlIHdheSBmaXJlYmFzZSB0cmVhdHMgTnVsbCB2YWx1ZXMsIHRoZXJlIGlzIG5vIHdheSB0b1xuICAgIC8vIHdyaXRlIGEgdmFsaWRhdGlvbiBydWxlLCB0aGF0IHdpbGwgRVZFUiBiZSBjYWxsZWQgd2l0aCB0aGlzID09IG51bGxcbiAgICAvLyAoZmlyZWJhc2UgYWxsb3dzIHZhbHVlcyB0byBiZSBkZWxldGVkIG5vIG1hdHRlciB0aGVpciB2YWxpZGF0aW9uIHJ1bGVzKS5cbiAgICAvLyBTbywgY29tcGFyaW5nIHRoaXMgPT0gbnVsbCB3aWxsIGFsd2F5cyByZXR1cm4gZmFsc2UgLT4gdGhhdCBpcyB3aGF0XG4gICAgLy8gd2UgZG8gaGVyZSwgd2hpY2ggd2lsbCBiZSBvcHRpbWl6ZWQgYXdheSBpZiBPUmVkIHdpdGggb3RoZXIgdmFsaWRhdGlvbnMuXG4gICAgdGhpcy5zeW1ib2xzLnJlZ2lzdGVyU2NoZW1hKCdOdWxsJywgYXN0LnR5cGVUeXBlKCdBbnknKSwgdW5kZWZpbmVkLCB7XG4gICAgICB2YWxpZGF0ZTogYXN0Lm1ldGhvZChbJ3RoaXMnXSwgYXN0LmJvb2xlYW4oZmFsc2UpKVxuICAgIH0pO1xuXG4gICAgc2VsZi5zeW1ib2xzLnJlZ2lzdGVyU2NoZW1hKCdTdHJpbmcnLCBhc3QudHlwZVR5cGUoJ0FueScpLCB1bmRlZmluZWQsIHtcbiAgICAgIHZhbGlkYXRlOiBhc3QubWV0aG9kKFsndGhpcyddLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgYXN0LmNhbGwoYXN0LnJlZmVyZW5jZShhc3QuY2FzdCh0aGlzVmFyLCAnQW55JyksIGFzdC5zdHJpbmcoJ2lzU3RyaW5nJykpKSksXG4gICAgICBpbmNsdWRlczogYXN0Lm1ldGhvZChbJ3RoaXMnLCAncyddLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgYXN0LmNhbGwoYXN0LnJlZmVyZW5jZShhc3QudmFsdWUodGhpc1ZhciksIGFzdC5zdHJpbmcoJ2NvbnRhaW5zJykpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgWyBhc3QudmFsdWUoYXN0LnZhcmlhYmxlKCdzJykpIF0pKSxcbiAgICAgIHN0YXJ0c1dpdGg6IGFzdC5tZXRob2QoWyd0aGlzJywgJ3MnXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXN0LmNhbGwoYXN0LnJlZmVyZW5jZShhc3QudmFsdWUodGhpc1ZhciksIGFzdC5zdHJpbmcoJ2JlZ2luc1dpdGgnKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFsgYXN0LnZhbHVlKGFzdC52YXJpYWJsZSgncycpKSBdKSksXG4gICAgICBlbmRzV2l0aDogYXN0Lm1ldGhvZChbJ3RoaXMnLCAncyddLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgYXN0LmNhbGwoYXN0LnJlZmVyZW5jZShhc3QudmFsdWUodGhpc1ZhciksIGFzdC5zdHJpbmcoJ2VuZHNXaXRoJykpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgWyBhc3QudmFsdWUoYXN0LnZhcmlhYmxlKCdzJykpIF0pKSxcbiAgICAgIHJlcGxhY2U6IGFzdC5tZXRob2QoWyd0aGlzJywgJ3MnLCAnciddLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBhc3QuY2FsbChhc3QucmVmZXJlbmNlKGFzdC52YWx1ZSh0aGlzVmFyKSwgYXN0LnN0cmluZygncmVwbGFjZScpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgWyBhc3QudmFsdWUoYXN0LnZhcmlhYmxlKCdzJykpLCBhc3QudmFsdWUoYXN0LnZhcmlhYmxlKCdyJykpIF0pKSxcbiAgICAgIHRlc3Q6IGFzdC5tZXRob2QoWyd0aGlzJywgJ3InXSxcbiAgICAgICAgICAgICAgICAgICAgICAgYXN0LmNhbGwoYXN0LnJlZmVyZW5jZShhc3QudmFsdWUodGhpc1ZhciksIGFzdC5zdHJpbmcoJ21hdGNoZXMnKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFsgYXN0LmNhbGwoYXN0LnZhcmlhYmxlKCdAUmVnRXhwJyksIFthc3QudmFyaWFibGUoJ3InKV0pIF0pKSxcbiAgICB9KTtcblxuICAgIHJlZ2lzdGVyQXNDYWxsKCdOdW1iZXInLCAnaXNOdW1iZXInKTtcbiAgICByZWdpc3RlckFzQ2FsbCgnQm9vbGVhbicsICdpc0Jvb2xlYW4nKTtcblxuICAgIHRoaXMuc3ltYm9scy5yZWdpc3RlckZ1bmN0aW9uKCdAUmVnRXhwJywgWydyJ10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXN0LmJ1aWx0aW4odGhpcy5lbnN1cmVUeXBlLmJpbmQodGhpcywgJ1JlZ0V4cCcpKSk7XG5cbiAgICBsZXQgbWFwID0gdGhpcy5zeW1ib2xzLnJlZ2lzdGVyU2NoZW1hKCdNYXAnLCBhc3QudHlwZVR5cGUoJ0FueScpLCB1bmRlZmluZWQsIHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFsnS2V5JywgJ1ZhbHVlJ10pO1xuICAgIG1hcC5nZXRWYWxpZGF0b3IgPSB0aGlzLmdldE1hcFZhbGlkYXRvci5iaW5kKHRoaXMpO1xuICB9XG5cbiAgLy8gdHlwZSBNYXA8S2V5LCBWYWx1ZT4gPT4ge1xuICAvLyAgICRrZXk6IHtcbiAgLy8gICAgICcudmFsaWRhdGUnOiAka2V5IGluc3RhbmNlb2YgS2V5IGFuZCB0aGlzIGluc3RhbmNlb2YgVmFsdWU7XG4gIC8vICAgJy52YWxpZGF0ZSc6ICduZXdEYXRhLmhhc0NoaWxkcmVuKCknXG4gIC8vIH1cbiAgLy8gS2V5IG11c3QgZGVyaXZlIGZyb20gU3RyaW5nXG4gIGdldE1hcFZhbGlkYXRvcihwYXJhbXM6IGFzdC5FeHBbXSk6IFZhbGlkYXRvciB7XG4gICAgbGV0IGtleVR5cGUgPSA8YXN0LkV4cFNpbXBsZVR5cGU+IHBhcmFtc1swXTtcbiAgICBsZXQgdmFsdWVUeXBlID0gPGFzdC5FeHBUeXBlPiBwYXJhbXNbMV07XG4gICAgaWYgKGtleVR5cGUudHlwZSAhPT0gJ3R5cGUnIHx8ICF0aGlzLnN5bWJvbHMuaXNEZXJpdmVkRnJvbShrZXlUeXBlLCAnU3RyaW5nJykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMuaW52YWxpZE1hcEtleSArIFwiICAoXCIgKyBhc3QuZGVjb2RlRXhwcmVzc2lvbihrZXlUeXBlKSArIFwiIGRvZXMgbm90KVwiKTtcbiAgICB9XG5cbiAgICBsZXQgdmFsaWRhdG9yID0gPFZhbGlkYXRvcj4ge307XG4gICAgbGV0IGluZGV4ID0gdGhpcy51bmlxdWVLZXkoKTtcbiAgICB2YWxpZGF0b3JbaW5kZXhdID0gPFZhbGlkYXRvcj4ge307XG4gICAgZXh0ZW5kVmFsaWRhdG9yKHZhbGlkYXRvciwgdGhpcy5lbnN1cmVWYWxpZGF0b3IoYXN0LnR5cGVUeXBlKCdPYmplY3QnKSkpO1xuXG4gICAgLy8gRmlyc3QgdmFsaWRhdGUgdGhlIGtleSAob21pdCB0ZXJtaW5hbCBTdHJpbmcgdHlwZSB2YWxpZGF0aW9uKS5cbiAgICB3aGlsZSAoa2V5VHlwZS5uYW1lICE9PSAnU3RyaW5nJykge1xuICAgICAgbGV0IHNjaGVtYSA9IHRoaXMuc3ltYm9scy5zY2hlbWFba2V5VHlwZS5uYW1lXTtcbiAgICAgIGlmIChzY2hlbWEubWV0aG9kc1sndmFsaWRhdGUnXSkge1xuICAgICAgICBsZXQgZXhwID0gdGhpcy5wYXJ0aWFsRXZhbChzY2hlbWEubWV0aG9kc1sndmFsaWRhdGUnXS5ib2R5LCB7J3RoaXMnOiBhc3QubGl0ZXJhbChpbmRleCl9KTtcbiAgICAgICAgZXh0ZW5kVmFsaWRhdG9yKDxWYWxpZGF0b3I+IHZhbGlkYXRvcltpbmRleF0sIDxWYWxpZGF0b3I+IHsnLnZhbGlkYXRlJzogW2V4cF19KTtcbiAgICAgIH1cbiAgICAgIGtleVR5cGUgPSA8YXN0LkV4cFNpbXBsZVR5cGU+IHNjaGVtYS5kZXJpdmVkRnJvbTtcbiAgICB9XG5cbiAgICBleHRlbmRWYWxpZGF0b3IoPFZhbGlkYXRvcj4gdmFsaWRhdG9yW2luZGV4XSwgdGhpcy5lbnN1cmVWYWxpZGF0b3IodmFsdWVUeXBlKSk7XG4gICAgcmV0dXJuIHZhbGlkYXRvcjtcbiAgfVxuXG4gIHVuaXF1ZUtleSgpOiBzdHJpbmcge1xuICAgIHRoaXMua2V5SW5kZXggKz0gMTtcbiAgICByZXR1cm4gJyRrZXknICsgdGhpcy5rZXlJbmRleDtcbiAgfVxuXG4gIC8vIENvbGxlY3Rpb24gc2NoZW1hIGhhcyBleGFjdGx5IG9uZSAkd2lsZGNoaWxkIHByb3BlcnR5XG4gIGlzQ29sbGVjdGlvblNjaGVtYShzY2hlbWE6IGFzdC5TY2hlbWEpOiBib29sZWFuIHtcbiAgICBsZXQgcHJvcHMgPSBPYmplY3Qua2V5cyhzY2hlbWEucHJvcGVydGllcyk7XG4gICAgbGV0IHJlc3VsdCA9IHByb3BzLmxlbmd0aCA9PT0gMSAmJiBwcm9wc1swXVswXSA9PT0gJyQnO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBFbnN1cmUgd2UgaGF2ZSBhIGRlZmluaXRpb24gZm9yIGEgdmFsaWRhdG9yIGZvciB0aGUgZ2l2ZW4gc2NoZW1hLlxuICBlbnN1cmVWYWxpZGF0b3IodHlwZTogYXN0LkV4cFR5cGUpOiBWYWxpZGF0b3Ige1xuICAgIHZhciBrZXkgPSBhc3QuZGVjb2RlRXhwcmVzc2lvbih0eXBlKTtcbiAgICBpZiAoIXRoaXMudmFsaWRhdG9yc1trZXldKSB7XG4gICAgICB0aGlzLnZhbGlkYXRvcnNba2V5XSA9IHsnLnZhbGlkYXRlJzogYXN0LmxpdGVyYWwoJyoqKlRZUEUgUkVDVVJTSU9OKioqJykgfTtcblxuICAgICAgbGV0IGFsbG93U2F2ZSA9IHRoaXMuYWxsb3dVbmRlZmluZWRGdW5jdGlvbnM7XG4gICAgICB0aGlzLmFsbG93VW5kZWZpbmVkRnVuY3Rpb25zID0gdHJ1ZTtcbiAgICAgIHRoaXMudmFsaWRhdG9yc1trZXldID0gdGhpcy5jcmVhdGVWYWxpZGF0b3IodHlwZSk7XG4gICAgICB0aGlzLmFsbG93VW5kZWZpbmVkRnVuY3Rpb25zID0gYWxsb3dTYXZlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy52YWxpZGF0b3JzW2tleV07XG4gIH1cblxuICBjcmVhdGVWYWxpZGF0b3IodHlwZTogYXN0LkV4cFR5cGUpOiBWYWxpZGF0b3Ige1xuICAgIHN3aXRjaCAodHlwZS50eXBlKSB7XG4gICAgY2FzZSAndHlwZSc6XG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGVWYWxpZGF0b3JGcm9tU2NoZW1hTmFtZSgoPGFzdC5FeHBTaW1wbGVUeXBlPiB0eXBlKS5uYW1lKTtcblxuICAgIGNhc2UgJ3VuaW9uJzpcbiAgICAgIGxldCB1bmlvbiA9IDxWYWxpZGF0b3I+IHt9O1xuICAgICAgKDxhc3QuRXhwVW5pb25UeXBlPiB0eXBlKS50eXBlcy5mb3JFYWNoKCh0eXBlUGFydDogYXN0LkV4cFR5cGUpID0+IHtcbiAgICAgICAgLy8gTWFrZSBhIGNvcHlcbiAgICAgICAgdmFyIHNpbmdsZVR5cGUgPSBleHRlbmRWYWxpZGF0b3Ioe30sIHRoaXMuZW5zdXJlVmFsaWRhdG9yKHR5cGVQYXJ0KSk7XG4gICAgICAgIG1hcFZhbGlkYXRvcihzaW5nbGVUeXBlLCBhc3QuYW5kQXJyYXkpO1xuICAgICAgICBleHRlbmRWYWxpZGF0b3IodW5pb24sIHNpbmdsZVR5cGUpO1xuICAgICAgfSk7XG4gICAgICBtYXBWYWxpZGF0b3IodW5pb24sIGFzdC5vckFycmF5KTtcbiAgICAgIHJldHVybiB1bmlvbjtcblxuICAgIGNhc2UgJ2dlbmVyaWMnOlxuICAgICAgbGV0IGdlbmVyaWNUeXBlID0gPGFzdC5FeHBHZW5lcmljVHlwZT4gdHlwZTtcbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVZhbGlkYXRvckZyb21HZW5lcmljKGdlbmVyaWNUeXBlLm5hbWUsIGdlbmVyaWNUeXBlLnBhcmFtcyk7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9ycy5hcHBsaWNhdGlvbiArIFwiaW52YWxpZCBpbnRlcm5hbCB0eXBlOiBcIiArIHR5cGUudHlwZSk7XG4gICAgfVxuICB9XG5cbiAgY3JlYXRlVmFsaWRhdG9yRnJvbUdlbmVyaWMoc2NoZW1hTmFtZTogc3RyaW5nLCBwYXJhbXM6IGFzdC5FeHBUeXBlW10pOiBWYWxpZGF0b3Ige1xuICAgIHZhciBzY2hlbWEgPSB0aGlzLnN5bWJvbHMuc2NoZW1hW3NjaGVtYU5hbWVdO1xuXG4gICAgaWYgKHNjaGVtYSA9PT0gdW5kZWZpbmVkIHx8ICFhc3QuU2NoZW1hLmlzR2VuZXJpYyhzY2hlbWEpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLm5vU3VjaFR5cGUgKyBzY2hlbWFOYW1lICsgXCIgKGdlbmVyaWMpXCIpO1xuICAgIH1cblxuICAgIGxldCBzY2hlbWFQYXJhbXMgPSA8c3RyaW5nW10+IHNjaGVtYS5wYXJhbXM7XG5cbiAgICBpZiAocGFyYW1zLmxlbmd0aCAhPT0gc2NoZW1hUGFyYW1zLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9ycy5pbnZhbGlkR2VuZXJpYyArIFwiIGV4cGVjdGVkIDxcIiArIHNjaGVtYVBhcmFtcy5qb2luKCcsICcpICsgXCI+XCIpO1xuICAgIH1cblxuICAgIC8vIENhbGwgY3VzdG9tIHZhbGlkYXRvciwgaWYgZ2l2ZW4uXG4gICAgaWYgKHNjaGVtYS5nZXRWYWxpZGF0b3IpIHtcbiAgICAgIHJldHVybiBzY2hlbWEuZ2V0VmFsaWRhdG9yKHBhcmFtcyk7XG4gICAgfVxuXG4gICAgbGV0IGJpbmRpbmdzID0gPGFzdC5UeXBlUGFyYW1zPiB7fTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcmFtcy5sZW5ndGg7IGkrKykge1xuICAgICAgYmluZGluZ3Nbc2NoZW1hUGFyYW1zW2ldXSA9IHBhcmFtc1tpXTtcbiAgICB9XG5cbiAgICAvLyBFeHBhbmQgZ2VuZXJpY3MgYW5kIGdlbmVyYXRlIHZhbGlkYXRvciBmcm9tIHNjaGVtYS5cbiAgICBzY2hlbWEgPSB0aGlzLnJlcGxhY2VHZW5lcmljc0luU2NoZW1hKHNjaGVtYSwgYmluZGluZ3MpO1xuICAgIHJldHVybiB0aGlzLmNyZWF0ZVZhbGlkYXRvckZyb21TY2hlbWEoc2NoZW1hKTtcbiAgfVxuXG4gIHJlcGxhY2VHZW5lcmljc0luU2NoZW1hKHNjaGVtYTogYXN0LlNjaGVtYSwgYmluZGluZ3M6IGFzdC5UeXBlUGFyYW1zKTogYXN0LlNjaGVtYSB7XG4gICAgdmFyIGV4cGFuZGVkU2NoZW1hID0gPGFzdC5TY2hlbWE+IHtcbiAgICAgIGRlcml2ZWRGcm9tOiA8YXN0LkV4cFR5cGU+IHRoaXMucmVwbGFjZUdlbmVyaWNzSW5FeHAoc2NoZW1hLmRlcml2ZWRGcm9tLCBiaW5kaW5ncyksXG4gICAgICBwcm9wZXJ0aWVzOiB7IH0sXG4gICAgICBtZXRob2RzOiB7fSxcbiAgICB9O1xuICAgIGxldCBwcm9wcyA9IE9iamVjdC5rZXlzKHNjaGVtYS5wcm9wZXJ0aWVzKTtcbiAgICBwcm9wcy5mb3JFYWNoKChwcm9wKSA9PiB7XG4gICAgICBleHBhbmRlZFNjaGVtYS5wcm9wZXJ0aWVzW3Byb3BdID1cbiAgICAgICAgPGFzdC5FeHBUeXBlPiB0aGlzLnJlcGxhY2VHZW5lcmljc0luRXhwKHNjaGVtYS5wcm9wZXJ0aWVzW3Byb3BdLCBiaW5kaW5ncyk7XG4gICAgfSk7XG5cbiAgICBsZXQgbWV0aG9kcyA9IE9iamVjdC5rZXlzKHNjaGVtYS5tZXRob2RzKTtcbiAgICBtZXRob2RzLmZvckVhY2goKG1ldGhvZE5hbWUpID0+IHtcbiAgICAgIGV4cGFuZGVkU2NoZW1hLm1ldGhvZHNbbWV0aG9kTmFtZV0gPSB0aGlzLnJlcGxhY2VHZW5lcmljc0luTWV0aG9kKHNjaGVtYS5tZXRob2RzW21ldGhvZE5hbWVdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaW5kaW5ncyk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGV4cGFuZGVkU2NoZW1hO1xuICB9XG5cbiAgcmVwbGFjZUdlbmVyaWNzSW5FeHAoZXhwOiBhc3QuRXhwLCBiaW5kaW5nczogYXN0LlR5cGVQYXJhbXMpOiBhc3QuRXhwIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBmdW5jdGlvbiByZXBsYWNlR2VuZXJpY3NJbkFycmF5KGV4cHM6IGFzdC5FeHBbXSk6IGFzdC5FeHBbXSB7XG4gICAgICByZXR1cm4gZXhwcy5tYXAoZnVuY3Rpb24oZXhwUGFydCkge1xuICAgICAgICByZXR1cm4gc2VsZi5yZXBsYWNlR2VuZXJpY3NJbkV4cChleHBQYXJ0LCBiaW5kaW5ncyk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKGV4cC50eXBlKSB7XG4gICAgY2FzZSAnb3AnOlxuICAgIGNhc2UgJ2NhbGwnOlxuICAgICAgbGV0IG9wVHlwZSA9IDxhc3QuRXhwT3A+IGFzdC5jb3B5RXhwKGV4cCk7XG4gICAgICBvcFR5cGUuYXJncyA9IHJlcGxhY2VHZW5lcmljc0luQXJyYXkob3BUeXBlLmFyZ3MpO1xuICAgICAgcmV0dXJuIG9wVHlwZTtcblxuICAgIGNhc2UgJ3R5cGUnOlxuICAgICAgbGV0IHNpbXBsZVR5cGUgPSA8YXN0LkV4cFNpbXBsZVR5cGU+IGV4cDtcbiAgICAgIHJldHVybiBiaW5kaW5nc1tzaW1wbGVUeXBlLm5hbWVdIHx8IHNpbXBsZVR5cGU7XG5cbiAgICBjYXNlICd1bmlvbic6XG4gICAgICBsZXQgdW5pb25UeXBlID0gPGFzdC5FeHBVbmlvblR5cGU+IGV4cDtcbiAgICAgIHJldHVybiBhc3QudW5pb25UeXBlKDxhc3QuRXhwVHlwZVtdPiByZXBsYWNlR2VuZXJpY3NJbkFycmF5KHVuaW9uVHlwZS50eXBlcykpO1xuXG4gICAgY2FzZSAnZ2VuZXJpYyc6XG4gICAgICBsZXQgZ2VuZXJpY1R5cGUgPSA8YXN0LkV4cEdlbmVyaWNUeXBlPiBleHA7XG4gICAgICByZXR1cm4gYXN0LmdlbmVyaWNUeXBlKGdlbmVyaWNUeXBlLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxhc3QuRXhwVHlwZVtdPiByZXBsYWNlR2VuZXJpY3NJbkFycmF5KGdlbmVyaWNUeXBlLnBhcmFtcykpO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBleHA7XG4gICAgfVxuICB9XG5cbiAgcmVwbGFjZUdlbmVyaWNzSW5NZXRob2QobWV0aG9kOiBhc3QuTWV0aG9kLCBiaW5kaW5nczogYXN0LlR5cGVQYXJhbXMpOiBhc3QuTWV0aG9kIHtcbiAgICB2YXIgZXhwYW5kZWRNZXRob2QgPSA8YXN0Lk1ldGhvZD4ge1xuICAgICAgcGFyYW1zOiBtZXRob2QucGFyYW1zLFxuICAgICAgYm9keTogbWV0aG9kLmJvZHlcbiAgICB9O1xuXG4gICAgZXhwYW5kZWRNZXRob2QuYm9keSA9IHRoaXMucmVwbGFjZUdlbmVyaWNzSW5FeHAobWV0aG9kLmJvZHksIGJpbmRpbmdzKTtcbiAgICByZXR1cm4gZXhwYW5kZWRNZXRob2Q7XG4gIH1cblxuICBjcmVhdGVWYWxpZGF0b3JGcm9tU2NoZW1hTmFtZShzY2hlbWFOYW1lOiBzdHJpbmcpOiBWYWxpZGF0b3Ige1xuICAgIHZhciBzY2hlbWEgPSB0aGlzLnN5bWJvbHMuc2NoZW1hW3NjaGVtYU5hbWVdO1xuXG4gICAgaWYgKCFzY2hlbWEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMubm9TdWNoVHlwZSArIHNjaGVtYU5hbWUpO1xuICAgIH1cblxuICAgIGlmIChhc3QuU2NoZW1hLmlzR2VuZXJpYyhzY2hlbWEpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLm5vU3VjaFR5cGUgKyBzY2hlbWFOYW1lICsgXCIgdXNlZCBhcyBub24tZ2VuZXJpYyB0eXBlLlwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5jcmVhdGVWYWxpZGF0b3JGcm9tU2NoZW1hKHNjaGVtYSk7XG4gIH1cblxuICBjcmVhdGVWYWxpZGF0b3JGcm9tU2NoZW1hKHNjaGVtYTogYXN0LlNjaGVtYSk6IFZhbGlkYXRvciB7XG4gICAgdmFyIGhhc1Byb3BzID0gT2JqZWN0LmtleXMoc2NoZW1hLnByb3BlcnRpZXMpLmxlbmd0aCA+IDAgJiZcbiAgICAgICF0aGlzLmlzQ29sbGVjdGlvblNjaGVtYShzY2hlbWEpO1xuXG4gICAgaWYgKGhhc1Byb3BzICYmICF0aGlzLnN5bWJvbHMuaXNEZXJpdmVkRnJvbShzY2hlbWEuZGVyaXZlZEZyb20sICdPYmplY3QnKSkge1xuICAgICAgdGhpcy5mYXRhbChlcnJvcnMubm9uT2JqZWN0ICsgXCIgKGlzIFwiICsgYXN0LmRlY29kZUV4cHJlc3Npb24oc2NoZW1hLmRlcml2ZWRGcm9tKSArIFwiKVwiKTtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG5cbiAgICBsZXQgdmFsaWRhdG9yID0gPFZhbGlkYXRvcj4ge307XG5cbiAgICBpZiAoIShzY2hlbWEuZGVyaXZlZEZyb20udHlwZSA9PT0gJ3R5cGUnICYmXG4gICAgICAgICAgKDxhc3QuRXhwU2ltcGxlVHlwZT4gc2NoZW1hLmRlcml2ZWRGcm9tKS5uYW1lID09PSAnQW55JykpIHtcbiAgICAgIGV4dGVuZFZhbGlkYXRvcih2YWxpZGF0b3IsIHRoaXMuZW5zdXJlVmFsaWRhdG9yKHNjaGVtYS5kZXJpdmVkRnJvbSkpO1xuICAgIH1cblxuICAgIGxldCByZXF1aXJlZFByb3BlcnRpZXMgPSA8c3RyaW5nW10+IFtdO1xuICAgIGxldCB3aWxkUHJvcGVydGllcyA9IDA7XG4gICAgT2JqZWN0LmtleXMoc2NoZW1hLnByb3BlcnRpZXMpLmZvckVhY2goKHByb3BOYW1lKSA9PiB7XG4gICAgICBpZiAocHJvcE5hbWVbMF0gPT09ICckJykge1xuICAgICAgICB3aWxkUHJvcGVydGllcyArPSAxO1xuICAgICAgICBpZiAoSU5WQUxJRF9LRVlfUkVHRVgudGVzdChwcm9wTmFtZS5zbGljZSgxKSkpIHtcbiAgICAgICAgICB0aGlzLmZhdGFsKGVycm9ycy5pbnZhbGlkUHJvcGVydHlOYW1lICsgcHJvcE5hbWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoSU5WQUxJRF9LRVlfUkVHRVgudGVzdChwcm9wTmFtZSkpIHtcbiAgICAgICAgICB0aGlzLmZhdGFsKGVycm9ycy5pbnZhbGlkUHJvcGVydHlOYW1lICsgcHJvcE5hbWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIXZhbGlkYXRvcltwcm9wTmFtZV0pIHtcbiAgICAgICAgdmFsaWRhdG9yW3Byb3BOYW1lXSA9IHt9O1xuICAgICAgfVxuICAgICAgdmFyIHByb3BUeXBlID0gc2NoZW1hLnByb3BlcnRpZXNbcHJvcE5hbWVdO1xuICAgICAgaWYgKHByb3BOYW1lWzBdICE9PSAnJCcgJiYgIXRoaXMuaXNOdWxsYWJsZVR5cGUocHJvcFR5cGUpKSB7XG4gICAgICAgIHJlcXVpcmVkUHJvcGVydGllcy5wdXNoKHByb3BOYW1lKTtcbiAgICAgIH1cbiAgICAgIGV4dGVuZFZhbGlkYXRvcig8VmFsaWRhdG9yPiB2YWxpZGF0b3JbcHJvcE5hbWVdLCB0aGlzLmVuc3VyZVZhbGlkYXRvcihwcm9wVHlwZSkpO1xuICAgIH0pO1xuXG4gICAgaWYgKHdpbGRQcm9wZXJ0aWVzID4gMSB8fCB3aWxkUHJvcGVydGllcyA9PT0gMSAmJiByZXF1aXJlZFByb3BlcnRpZXMubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5mYXRhbChlcnJvcnMuaW52YWxpZFdpbGRDaGlsZHJlbik7XG4gICAgfVxuXG4gICAgaWYgKHJlcXVpcmVkUHJvcGVydGllcy5sZW5ndGggPiAwKSB7XG4gICAgICAvLyB0aGlzLmhhc0NoaWxkcmVuKHJlcXVpcmVkUHJvcGVydGllcylcbiAgICAgIGV4dGVuZFZhbGlkYXRvcih2YWxpZGF0b3IsXG4gICAgICAgICAgICAgICAgICAgICAgeycudmFsaWRhdGUnOiBbaGFzQ2hpbGRyZW5FeHAocmVxdWlyZWRQcm9wZXJ0aWVzKV19KTtcbiAgICB9XG5cbiAgICAvLyBEaXNhbGxvdyAkb3RoZXIgcHJvcGVydGllcyBieSBkZWZhdWx0XG4gICAgaWYgKGhhc1Byb3BzKSB7XG4gICAgICB2YWxpZGF0b3JbJyRvdGhlciddID0ge307XG4gICAgICBleHRlbmRWYWxpZGF0b3IoPFZhbGlkYXRvcj4gdmFsaWRhdG9yWyckb3RoZXInXSxcbiAgICAgICAgICAgICAgICAgICAgICA8VmFsaWRhdG9yPiB7Jy52YWxpZGF0ZSc6IGFzdC5ib29sZWFuKGZhbHNlKX0pO1xuICAgIH1cblxuICAgIHRoaXMuZXh0ZW5kVmFsaWRhdGlvbk1ldGhvZHModmFsaWRhdG9yLCBzY2hlbWEubWV0aG9kcyk7XG5cbiAgICByZXR1cm4gdmFsaWRhdG9yO1xuICB9XG5cbiAgaXNOdWxsYWJsZVR5cGUodHlwZTogYXN0LkV4cFR5cGUpOiBib29sZWFuIHtcbiAgICBsZXQgcmVzdWx0ID0gdGhpcy5zeW1ib2xzLmlzRGVyaXZlZEZyb20odHlwZSwgJ051bGwnKSB8fFxuICAgICAgdGhpcy5zeW1ib2xzLmlzRGVyaXZlZEZyb20odHlwZSwgJ01hcCcpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBVcGRhdGUgcnVsZXMgYmFzZWQgb24gdGhlIGdpdmVuIHBhdGggZXhwcmVzc2lvbi5cbiAgdXBkYXRlUnVsZXMocGF0aDogYXN0LlBhdGgpIHtcbiAgICB2YXIgaTogbnVtYmVyO1xuICAgIHZhciBsb2NhdGlvbiA9IDxWYWxpZGF0b3I+IHV0aWwuZW5zdXJlT2JqZWN0UGF0aCh0aGlzLnJ1bGVzLCBwYXRoLnRlbXBsYXRlLmdldExhYmVscygpKTtcbiAgICB2YXIgZXhwOiBhc3QuRXhwVmFsdWU7XG5cbiAgICBleHRlbmRWYWxpZGF0b3IobG9jYXRpb24sIHRoaXMuZW5zdXJlVmFsaWRhdG9yKHBhdGguaXNUeXBlKSk7XG4gICAgbG9jYXRpb25bJy5zY29wZSddID0gcGF0aC50ZW1wbGF0ZS5nZXRTY29wZSgpO1xuXG4gICAgdGhpcy5leHRlbmRWYWxpZGF0aW9uTWV0aG9kcyhsb2NhdGlvbiwgcGF0aC5tZXRob2RzKTtcblxuICAgIC8vIFdyaXRlIGluZGljZXNcbiAgICBpZiAocGF0aC5tZXRob2RzWydpbmRleCddKSB7XG4gICAgICBzd2l0Y2ggKHBhdGgubWV0aG9kc1snaW5kZXgnXS5ib2R5LnR5cGUpIHtcbiAgICAgIGNhc2UgJ1N0cmluZyc6XG4gICAgICAgIGV4cCA9IGFzdC5hcnJheShbcGF0aC5tZXRob2RzWydpbmRleCddLmJvZHldKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdBcnJheSc6XG4gICAgICAgIGV4cCA9IDxhc3QuRXhwVmFsdWU+IHBhdGgubWV0aG9kc1snaW5kZXgnXS5ib2R5O1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRoaXMuZmF0YWwoZXJyb3JzLmJhZEluZGV4KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGluZGljZXMgPSA8c3RyaW5nW10+IFtdO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGV4cC52YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoZXhwLnZhbHVlW2ldLnR5cGUgIT09ICdTdHJpbmcnKSB7XG4gICAgICAgICAgdGhpcy5mYXRhbChlcnJvcnMuYmFkSW5kZXggKyBcIiAobm90IFwiICsgZXhwLnZhbHVlW2ldLnR5cGUgKyBcIilcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW5kaWNlcy5wdXNoKGV4cC52YWx1ZVtpXS52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIFRPRE86IEVycm9yIGNoZWNrIG5vdCBvdmVyLXdyaXRpbmcgaW5kZXggcnVsZXMuXG4gICAgICBsb2NhdGlvblsnLmluZGV4T24nXSA9IGluZGljZXM7XG4gICAgfVxuICB9XG5cbiAgZXh0ZW5kVmFsaWRhdGlvbk1ldGhvZHModmFsaWRhdG9yOiBWYWxpZGF0b3IsIG1ldGhvZHM6IHsgW21ldGhvZDogc3RyaW5nXTogYXN0Lk1ldGhvZCB9KSB7XG4gICAgbGV0IHdyaXRlTWV0aG9kcyA9IDxhc3QuRXhwW10+IFtdO1xuICAgIFsnY3JlYXRlJywgJ3VwZGF0ZScsICdkZWxldGUnXS5mb3JFYWNoKChtZXRob2QpID0+IHtcbiAgICAgIGlmIChtZXRob2QgaW4gbWV0aG9kcykge1xuICAgICAgICB3cml0ZU1ldGhvZHMucHVzaChhc3QuYW5kQXJyYXkoW3dyaXRlQWxpYXNlc1ttZXRob2RdLCBtZXRob2RzW21ldGhvZF0uYm9keV0pKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAod3JpdGVNZXRob2RzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgZXh0ZW5kVmFsaWRhdG9yKHZhbGlkYXRvciwgPFZhbGlkYXRvcj4geyAnLndyaXRlJzogYXN0Lm9yQXJyYXkod3JpdGVNZXRob2RzKSB9KTtcbiAgICB9XG5cbiAgICBbJ3ZhbGlkYXRlJywgJ3JlYWQnLCAnd3JpdGUnXS5mb3JFYWNoKChtZXRob2QpID0+IHtcbiAgICAgIGlmIChtZXRob2QgaW4gbWV0aG9kcykge1xuICAgICAgICB2YXIgbWV0aG9kVmFsaWRhdG9yID0gPFZhbGlkYXRvcj4ge307XG4gICAgICAgIG1ldGhvZFZhbGlkYXRvclsnLicgKyBtZXRob2RdID0gbWV0aG9kc1ttZXRob2RdLmJvZHk7XG4gICAgICAgIGV4dGVuZFZhbGlkYXRvcih2YWxpZGF0b3IsIG1ldGhvZFZhbGlkYXRvcik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvLyBSZXR1cm4gdW5pb24gdmFsaWRhdG9yICh8fCkgb3ZlciBlYWNoIHNjaGVtYVxuICB1bmlvblZhbGlkYXRvcnMoc2NoZW1hOiBzdHJpbmdbXSk6IFZhbGlkYXRvciB7XG4gICAgdmFyIHVuaW9uID0gPFZhbGlkYXRvcj4ge307XG4gICAgc2NoZW1hLmZvckVhY2goZnVuY3Rpb24odHlwZU5hbWU6IHN0cmluZykge1xuICAgICAgLy8gRmlyc3QgYW5kIHRoZSB2YWxpZGF0b3IgdGVybXMgZm9yIGEgc2luZ2xlIHR5cGVcbiAgICAgIC8vIFRvZG8gZXh0ZW5kIHRvIHVuaW9ucyBhbmQgZ2VuZXJpY3NcbiAgICAgIHZhciBzaW5nbGVUeXBlID0gZXh0ZW5kVmFsaWRhdG9yKHt9LCB0aGlzLmVuc3VyZVZhbGlkYXRvcih0eXBlTmFtZSkpO1xuICAgICAgbWFwVmFsaWRhdG9yKHNpbmdsZVR5cGUsIGFzdC5hbmRBcnJheSk7XG4gICAgICBleHRlbmRWYWxpZGF0b3IodW5pb24sIHNpbmdsZVR5cGUpO1xuICAgIH0uYmluZCh0aGlzKSk7XG4gICAgbWFwVmFsaWRhdG9yKHVuaW9uLCBhc3Qub3JBcnJheSk7XG4gICAgcmV0dXJuIHVuaW9uO1xuICB9XG5cbiAgLy8gQ29udmVydCBleHByZXNzaW9ucyB0byB0ZXh0LCBhbmQgYXQgdGhlIHNhbWUgdGltZSwgYXBwbHkgcHJ1bmluZyBvcGVyYXRpb25zXG4gIC8vIHRvIHJlbW92ZSBuby1vcCBydWxlcy5cbiAgY29udmVydEV4cHJlc3Npb25zKHZhbGlkYXRvcjogVmFsaWRhdG9yKSB7XG4gICAgdmFyIG1ldGhvZFRoaXNJcyA9IDx7W3Byb3A6IHN0cmluZ106IHN0cmluZ30+IHsgJy52YWxpZGF0ZSc6ICduZXdEYXRhJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnLnJlYWQnOiAnZGF0YScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJy53cml0ZSc6ICduZXdEYXRhJyB9O1xuXG4gICAgZnVuY3Rpb24gaGFzV2lsZGNhcmRTaWJsaW5nKHBhdGg6IGFzdC5QYXRoVGVtcGxhdGUpOiBib29sZWFuIHtcbiAgICAgIGxldCBwYXJ0cyA9IHBhdGguZ2V0TGFiZWxzKCk7XG4gICAgICBsZXQgY2hpbGRQYXJ0ID0gcGFydHMucG9wKCk7XG4gICAgICBsZXQgcGFyZW50ID0gdXRpbC5kZWVwTG9va3VwKHZhbGlkYXRvciwgcGFydHMpO1xuICAgICAgaWYgKHBhcmVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IHByb3Agb2YgT2JqZWN0LmtleXMocGFyZW50KSkge1xuICAgICAgICBpZiAocHJvcCA9PT0gY2hpbGRQYXJ0KSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3BbMF0gPT09ICckJykge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgbWFwVmFsaWRhdG9yKHZhbGlkYXRvciwgKHZhbHVlOiBhc3QuRXhwW10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3A6IHN0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGU6IGFzdC5QYXJhbXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6IGFzdC5QYXRoVGVtcGxhdGUpID0+IHtcbiAgICAgIGlmIChwcm9wIGluIG1ldGhvZFRoaXNJcykge1xuICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5nZXRFeHByZXNzaW9uVGV4dChhc3QuYW5kQXJyYXkoY29sbGFwc2VIYXNDaGlsZHJlbih2YWx1ZSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRob2RUaGlzSXNbcHJvcF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoKTtcbiAgICAgICAgLy8gUmVtb3ZlIG5vLW9wIC5yZWFkIG9yIC53cml0ZSBydWxlIGlmIG5vIHNpYmxpbmcgd2lsZGNhcmQgcHJvcHMuXG4gICAgICAgIGlmICgocHJvcCA9PT0gJy5yZWFkJyB8fCBwcm9wID09PSAnLndyaXRlJykgJiYgcmVzdWx0ID09PSAnZmFsc2UnKSB7XG4gICAgICAgICAgaWYgKCFoYXNXaWxkY2FyZFNpYmxpbmcocGF0aCkpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVtb3ZlIG5vLW9wIC52YWxpZGF0ZSBydWxlIGlmIG5vIHNpYmxpbmcgd2lsZGNhcmQgcHJvcHMuXG4gICAgICAgIGlmIChwcm9wID09PSAnLnZhbGlkYXRlJyAmJiByZXN1bHQgPT09ICd0cnVlJykge1xuICAgICAgICAgIGlmICghaGFzV2lsZGNhcmRTaWJsaW5nKHBhdGgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSk7XG4gIH1cblxuICBnZXRFeHByZXNzaW9uVGV4dChleHA6IGFzdC5FeHAsIHRoaXNJczogc3RyaW5nLCBzY29wZTogYXN0LlBhcmFtcywgcGF0aDogYXN0LlBhdGhUZW1wbGF0ZSk6IHN0cmluZyB7XG4gICAgaWYgKCEoJ3R5cGUnIGluIGV4cCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMuYXBwbGljYXRpb24gKyBcIk5vdCBhbiBleHByZXNzaW9uOiBcIiArIHV0aWwucHJldHR5SlNPTihleHApKTtcbiAgICB9XG4gICAgLy8gRmlyc3QgZXZhbHVhdGUgdy9vIGJpbmRpbmcgb2YgdGhpcyB0byBzcGVjaWZpYyBsb2NhdGlvbi5cbiAgICB0aGlzLmFsbG93VW5kZWZpbmVkRnVuY3Rpb25zID0gdHJ1ZTtcbiAgICBzY29wZSA9IDxhc3QuUGFyYW1zPiB1dGlsLmV4dGVuZCh7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29wZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7ICd0aGlzJzogYXN0LmNhc3QoYXN0LmNhbGwoYXN0LnZhcmlhYmxlKCdAZ2V0VGhpcycpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1NuYXBzaG90JykgfSk7XG4gICAgZXhwID0gdGhpcy5wYXJ0aWFsRXZhbChleHAsIHNjb3BlKTtcbiAgICAvLyBOb3cgcmUtZXZhbHVhdGUgdGhlIGZsYXR0ZW5lZCBleHByZXNzaW9uLlxuICAgIHRoaXMuYWxsb3dVbmRlZmluZWRGdW5jdGlvbnMgPSBmYWxzZTtcbiAgICB0aGlzLnRoaXNJcyA9IHRoaXNJcztcbiAgICB0aGlzLnN5bWJvbHMucmVnaXN0ZXJGdW5jdGlvbignQGdldFRoaXMnLCBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3QuYnVpbHRpbih0aGlzLmdldFRoaXMuYmluZCh0aGlzKSkpO1xuICAgIHRoaXMuc3ltYm9scy5yZWdpc3RlckZ1bmN0aW9uKCdAcm9vdCcsIFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzdC5idWlsdGluKHRoaXMuZ2V0Um9vdFJlZmVyZW5jZS5iaW5kKHRoaXMsIHBhdGgpKSk7XG4gICAgdGhpcy5zeW1ib2xzLnJlZ2lzdGVyRnVuY3Rpb24oJ3ByaW9yJywgWydleHAnXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3QuYnVpbHRpbih0aGlzLnByaW9yLmJpbmQodGhpcykpKTtcbiAgICB0aGlzLnN5bWJvbHMucmVnaXN0ZXJGdW5jdGlvbigna2V5JywgW10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXN0LmJ1aWx0aW4odGhpcy5nZXRLZXkuYmluZChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoLmxlbmd0aCgpID09PSAwID8gJycgOiBwYXRoLmdldFBhcnQoLTEpLmxhYmVsKSkpO1xuXG4gICAgZXhwID0gdGhpcy5wYXJ0aWFsRXZhbChleHApO1xuXG4gICAgZGVsZXRlIHRoaXMuc3ltYm9scy5mdW5jdGlvbnNbJ0BnZXRUaGlzJ107XG4gICAgZGVsZXRlIHRoaXMuc3ltYm9scy5mdW5jdGlvbnNbJ0Byb290J107XG4gICAgZGVsZXRlIHRoaXMuc3ltYm9scy5mdW5jdGlvbnNbJ3ByaW9yJ107XG4gICAgZGVsZXRlIHRoaXMuc3ltYm9scy5mdW5jdGlvbnNbJ2tleSddO1xuXG4gICAgLy8gVG9wIGxldmVsIGV4cHJlc3Npb25zIHNob3VsZCBuZXZlciBiZSB0byBhIHNuYXBzaG90IHJlZmVyZW5jZSAtIHNob3VsZFxuICAgIC8vIGFsd2F5cyBldmFsdWF0ZSB0byBhIGJvb2xlYW4uXG4gICAgZXhwID0gYXN0LmVuc3VyZUJvb2xlYW4oZXhwKTtcbiAgICByZXR1cm4gYXN0LmRlY29kZUV4cHJlc3Npb24oZXhwKTtcbiAgfVxuXG4gIC8qXG4gICAqICBXcmFwcGVyIGZvciBwYXJ0aWFsRXZhbCBkZWJ1Z2dpbmcuXG4gICAqL1xuXG4gIHBhcnRpYWxFdmFsKGV4cDogYXN0LkV4cCxcbiAgICAgICAgICAgICAgcGFyYW1zID0gPGFzdC5QYXJhbXM+IHt9LFxuICAgICAgICAgICAgICBmdW5jdGlvbkNhbGxzOiB7IFtuYW1lOiBzdHJpbmddOiBib29sZWFuIH0gPSB7fSlcbiAgOiBhc3QuRXhwIHtcbiAgICAvLyBXcmFwIHJlYWwgY2FsbCBmb3IgZGVidWdnaW5nLlxuICAgIGxldCByZXN1bHQgPSB0aGlzLnBhcnRpYWxFdmFsUmVhbChleHAsIHBhcmFtcywgZnVuY3Rpb25DYWxscyk7XG4gICAgLy8gY29uc29sZS5sb2coYXN0LmRlY29kZUV4cHJlc3Npb24oZXhwKSArIFwiID0+IFwiICsgYXN0LmRlY29kZUV4cHJlc3Npb24ocmVzdWx0KSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIFBhcnRpYWwgZXZhbHVhdGlvbiBvZiBleHByZXNzaW9ucyAtIGNvcHkgb2YgZXhwcmVzc2lvbiB0cmVlIChpbW11dGFibGUpLlxuICAvL1xuICAvLyAtIEV4cGFuZCBpbmxpbmUgZnVuY3Rpb24gY2FsbHMuXG4gIC8vIC0gUmVwbGFjZSBsb2NhbCBhbmQgZ2xvYmFsIHZhcmlhYmxlcyB3aXRoIHRoZWlyIHZhbHVlcy5cbiAgLy8gLSBFeHBhbmQgc25hcHNob3QgcmVmZXJlbmNlcyB1c2luZyBjaGlsZCgncmVmJykuXG4gIC8vIC0gQ29lcmNlIHNuYXBzaG90IHJlZmVyZW5jZXMgdG8gdmFsdWVzIGFzIG5lZWRlZC5cbiAgcGFydGlhbEV2YWxSZWFsKGV4cDogYXN0LkV4cCxcbiAgICAgICAgICAgICAgcGFyYW1zID0gPGFzdC5QYXJhbXM+IHt9LFxuICAgICAgICAgICAgICBmdW5jdGlvbkNhbGxzID0gPHsgW25hbWU6IHN0cmluZ106IGJvb2xlYW4gfT4ge30pXG4gIDogYXN0LkV4cCB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgZnVuY3Rpb24gc3ViRXhwcmVzc2lvbihleHAyOiBhc3QuRXhwKTogYXN0LkV4cCB7XG4gICAgICByZXR1cm4gc2VsZi5wYXJ0aWFsRXZhbChleHAyLCBwYXJhbXMsIGZ1bmN0aW9uQ2FsbHMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZhbHVlRXhwcmVzc2lvbihleHAyOiBhc3QuRXhwKTogYXN0LkV4cCB7XG4gICAgICByZXR1cm4gYXN0LmVuc3VyZVZhbHVlKHN1YkV4cHJlc3Npb24oZXhwMikpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJvb2xlYW5FeHByZXNzaW9uKGV4cDI6IGFzdC5FeHApOiBhc3QuRXhwIHtcbiAgICAgIHJldHVybiBhc3QuZW5zdXJlQm9vbGVhbihzdWJFeHByZXNzaW9uKGV4cDIpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb29rdXBWYXIoZXhwMjogYXN0LkV4cFZhcmlhYmxlKSB7XG4gICAgICAvLyBUT0RPOiBVbmJvdW5kIHZhcmlhYmxlIGFjY2VzcyBzaG91bGQgYmUgYW4gZXJyb3IuXG4gICAgICByZXR1cm4gcGFyYW1zW2V4cDIubmFtZV0gfHwgc2VsZi5nbG9iYWxzW2V4cDIubmFtZV0gfHwgZXhwMjtcbiAgICB9XG5cbiAgICAvLyBDb252ZXJ0IHJlZltwcm9wXSA9PiByZWYuY2hpbGQocHJvcClcbiAgICBmdW5jdGlvbiBzbmFwc2hvdENoaWxkKHJlZjogYXN0LkV4cFJlZmVyZW5jZSk6IGFzdC5FeHAge1xuICAgICAgcmV0dXJuIGFzdC5jYXN0KGFzdC5jYWxsKGFzdC5yZWZlcmVuY2UocmVmLmJhc2UsIGFzdC5zdHJpbmcoJ2NoaWxkJykpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtyZWYuYWNjZXNzb3JdKSxcbiAgICAgICAgICAgICAgICAgICAgICAnU25hcHNob3QnKTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKGV4cC50eXBlKSB7XG4gICAgY2FzZSAnb3AnOlxuICAgICAgbGV0IGV4cE9wID0gPGFzdC5FeHBPcD4gYXN0LmNvcHlFeHAoZXhwKTtcbiAgICAgIC8vIEVuc3VyZSBhcmd1bWVudHMgYXJlIGJvb2xlYW4gKG9yIHZhbHVlcykgd2hlcmUgbmVlZGVkLlxuICAgICAgaWYgKGV4cE9wLm9wID09PSAndmFsdWUnKSB7XG4gICAgICAgIGV4cE9wLmFyZ3NbMF0gPSB2YWx1ZUV4cHJlc3Npb24oZXhwT3AuYXJnc1swXSk7XG4gICAgICB9IGVsc2UgaWYgKGV4cE9wLm9wID09PSAnfHwnIHx8IGV4cE9wLm9wID09PSAnJiYnIHx8IGV4cE9wLm9wID09PSAnIScpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBleHBPcC5hcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgZXhwT3AuYXJnc1tpXSA9IGJvb2xlYW5FeHByZXNzaW9uKGV4cE9wLmFyZ3NbaV0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGV4cE9wLm9wID09PSAnPzonKSB7XG4gICAgICAgIGV4cE9wLmFyZ3NbMF0gPSBib29sZWFuRXhwcmVzc2lvbihleHBPcC5hcmdzWzBdKTtcbiAgICAgICAgZXhwT3AuYXJnc1sxXSA9IHZhbHVlRXhwcmVzc2lvbihleHBPcC5hcmdzWzFdKTtcbiAgICAgICAgZXhwT3AuYXJnc1syXSA9IHZhbHVlRXhwcmVzc2lvbihleHBPcC5hcmdzWzJdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXhwT3AuYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGV4cE9wLmFyZ3NbaV0gPSB2YWx1ZUV4cHJlc3Npb24oZXhwT3AuYXJnc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBleHBPcDtcblxuICAgIGNhc2UgJ3Zhcic6XG4gICAgICByZXR1cm4gbG9va3VwVmFyKDxhc3QuRXhwVmFyaWFibGU+IGV4cCk7XG5cbiAgICBjYXNlICdyZWYnOlxuICAgICAgbGV0IGV4cFJlZiA9IDxhc3QuRXhwUmVmZXJlbmNlPiBhc3QuY29weUV4cChleHApO1xuICAgICAgZXhwUmVmLmJhc2UgPSBzdWJFeHByZXNzaW9uKGV4cFJlZi5iYXNlKTtcblxuICAgICAgLy8gdmFyW3JlZl0gPT4gdmFyW3JlZl1cbiAgICAgIGlmIChleHBSZWYuYmFzZS52YWx1ZVR5cGUgIT09ICdTbmFwc2hvdCcpIHtcbiAgICAgICAgZXhwUmVmLmFjY2Vzc29yID0gc3ViRXhwcmVzc2lvbihleHBSZWYuYWNjZXNzb3IpO1xuICAgICAgICByZXR1cm4gZXhwUmVmO1xuICAgICAgfVxuXG4gICAgICBsZXQgcHJvcE5hbWUgPSBhc3QuZ2V0UHJvcE5hbWUoZXhwUmVmKTtcblxuICAgICAgLy8gc25hcHNob3QucHJvcCAoc3RhdGljIHN0cmluZyBwcm9wZXJ0eSlcbiAgICAgIGlmIChwcm9wTmFtZSAhPT0gJycpIHtcbiAgICAgICAgLy8gc25hcHNob3QudmFsdWVNZXRob2QgPT4gc25hcHNob3QudmFsKCkudmFsdWVNZXRob2RcbiAgICAgICAgaWYgKHV0aWwuYXJyYXlJbmNsdWRlcyh2YWx1ZU1ldGhvZHMsIHByb3BOYW1lKSkge1xuICAgICAgICAgIGV4cFJlZi5iYXNlID0gdmFsdWVFeHByZXNzaW9uKGV4cFJlZi5iYXNlKTtcbiAgICAgICAgICByZXR1cm4gZXhwUmVmO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc25hcHNob3Quc3NNZXRob2QgPT4gc25hcHNob3Quc3NNZXRob2RcbiAgICAgICAgaWYgKHV0aWwuYXJyYXlJbmNsdWRlcyhzbmFwc2hvdE1ldGhvZHMsIHByb3BOYW1lKSkge1xuICAgICAgICAgIHJldHVybiBleHBSZWY7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gc25hcHNob3RbZXhwXSA9PiBzbmFwc2hvdC5jaGlsZChleHApIG9yXG4gICAgICAvLyBzbmFwc2hvdFtyZWZdID0+IHNuYXBzaG90LmNoaWxkKHJlZi52YWwoKSlcbiAgICAgIGV4cFJlZi5hY2Nlc3NvciA9IHZhbHVlRXhwcmVzc2lvbihleHBSZWYuYWNjZXNzb3IpO1xuICAgICAgcmV0dXJuIHNuYXBzaG90Q2hpbGQoZXhwUmVmKTtcblxuICAgIGNhc2UgJ2NhbGwnOlxuICAgICAgbGV0IGV4cENhbGwgPSA8YXN0LkV4cENhbGw+IGFzdC5jb3B5RXhwKGV4cCk7XG4gICAgICBleHBDYWxsLnJlZiA9IDxhc3QuRXhwVmFyaWFibGUgfCBhc3QuRXhwUmVmZXJlbmNlPiBzdWJFeHByZXNzaW9uKGV4cENhbGwucmVmKTtcbiAgICAgIHZhciBjYWxsZWUgPSB0aGlzLmxvb2t1cEZ1bmN0aW9uKGV4cENhbGwucmVmKTtcblxuICAgICAgLy8gRXhwYW5kIHRoZSBmdW5jdGlvbiBjYWxsIGlubGluZVxuICAgICAgaWYgKGNhbGxlZSkge1xuICAgICAgICB2YXIgZm4gPSBjYWxsZWUuZm47XG5cbiAgICAgICAgaWYgKGNhbGxlZS5zZWxmKSB7XG4gICAgICAgICAgZXhwQ2FsbC5hcmdzLnVuc2hpZnQoYXN0LmVuc3VyZVZhbHVlKGNhbGxlZS5zZWxmKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZm4ucGFyYW1zLmxlbmd0aCAhPT0gZXhwQ2FsbC5hcmdzLmxlbmd0aCkge1xuICAgICAgICAgIHRoaXMuZmF0YWwoZXJyb3JzLm1pc21hdGNoUGFyYW1zICsgXCIgKCBcIiArXG4gICAgICAgICAgICAgICAgICAgICBjYWxsZWUubWV0aG9kTmFtZSArIFwiIGV4cGVjdHMgXCIgKyBmbi5wYXJhbXMubGVuZ3RoICtcbiAgICAgICAgICAgICAgICAgICAgIFwiIGJ1dCBhY3R1YWxseSBwYXNzZWQgXCIgKyBleHBDYWxsLmFyZ3MubGVuZ3RoICsgXCIpXCIpO1xuICAgICAgICAgIHJldHVybiBleHA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZm4uYm9keS50eXBlID09PSAnYnVpbHRpbicpIHtcbiAgICAgICAgICByZXR1cm4gKDxhc3QuRXhwQnVpbHRpbj4gZm4uYm9keSkuZm4oZXhwQ2FsbC5hcmdzLCBwYXJhbXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGlubmVyUGFyYW1zID0gPGFzdC5QYXJhbXM+IHt9O1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZm4ucGFyYW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaW5uZXJQYXJhbXNbZm4ucGFyYW1zW2ldXSA9IHN1YkV4cHJlc3Npb24oZXhwQ2FsbC5hcmdzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZnVuY3Rpb25DYWxsc1tjYWxsZWUubWV0aG9kTmFtZV0pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLnJlY3Vyc2l2ZSArIFwiIChcIiArIGNhbGxlZS5tZXRob2ROYW1lICsgXCIpXCIpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uQ2FsbHNbY2FsbGVlLm1ldGhvZE5hbWVdID0gdHJ1ZTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMucGFydGlhbEV2YWwoZm4uYm9keSwgaW5uZXJQYXJhbXMsIGZ1bmN0aW9uQ2FsbHMpO1xuICAgICAgICBmdW5jdGlvbkNhbGxzW2NhbGxlZS5tZXRob2ROYW1lXSA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICAvLyBDYW4ndCBleHBhbmQgZnVuY3Rpb24gLSBidXQganVzdCBleHBhbmQgdGhlIGFyZ3VtZW50cy5cbiAgICAgIGlmICghdGhpcy5hbGxvd1VuZGVmaW5lZEZ1bmN0aW9ucykge1xuICAgICAgICB2YXIgZnVuY05hbWUgPSBhc3QuZ2V0TWV0aG9kTmFtZShleHBDYWxsKTtcbiAgICAgICAgaWYgKGZ1bmNOYW1lICE9PSAnJyAmJiAhKGZ1bmNOYW1lIGluIHRoaXMuc3ltYm9scy5zY2hlbWFbJ1N0cmluZyddLm1ldGhvZHMgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV0aWwuYXJyYXlJbmNsdWRlcyhzbmFwc2hvdE1ldGhvZHMsIGZ1bmNOYW1lKSkpIHtcbiAgICAgICAgICB0aGlzLmZhdGFsKGVycm9ycy51bmRlZmluZWRGdW5jdGlvbiArIGFzdC5kZWNvZGVFeHByZXNzaW9uKGV4cENhbGwucmVmKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBleHBDYWxsLmFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZXhwQ2FsbC5hcmdzW2ldID0gc3ViRXhwcmVzc2lvbihleHBDYWxsLmFyZ3NbaV0pO1xuICAgICAgfVxuXG4gICAgICAvLyBIYWNrIGZvciBzbmFwc2hvdC5wYXJlbnQoKS52YWwoKVxuICAgICAgLy8gVG9kbyAtIGJ1aWxkIHRhYmxlLWJhc2VkIG1ldGhvZCBzaWduYXR1cmVzLlxuICAgICAgaWYgKGFzdC5nZXRNZXRob2ROYW1lKGV4cENhbGwpID09PSAncGFyZW50Jykge1xuICAgICAgICBleHBDYWxsID0gPGFzdC5FeHBDYWxsPiBhc3QuY2FzdChleHBDYWxsLCAnU25hcHNob3QnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGV4cENhbGw7XG5cbiAgICAvLyBFeHByZXNzaW9uIHR5cGVzIChsaWtlIGxpdGVyYWxzKSB0aGFuIG5lZWQgbm8gZXhwYW5zaW9uLlxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZXhwO1xuICAgIH1cbiAgfVxuXG4gIC8vIEJ1aWx0aW4gZnVuY3Rpb24gLSBjb252ZXJ0IGFsbCAndGhpcycgdG8gJ2RhdGEnIChmcm9tICduZXdEYXRhJykuXG4gIC8vIEFyZ3MgYXJlIGZ1bmN0aW9uIGFyZ3VtZW50cywgYW5kIHBhcmFtcyBhcmUgdGhlIGxvY2FsIChmdW5jdGlvbikgc2NvcGUgdmFyaWFibGVzLlxuICBwcmlvcihhcmdzOiBhc3QuRXhwW10sIHBhcmFtczogYXN0LlBhcmFtcyk6IGFzdC5FeHAge1xuICAgIHZhciBsYXN0VGhpc0lzID0gdGhpcy50aGlzSXM7XG4gICAgdGhpcy50aGlzSXMgPSAnZGF0YSc7XG4gICAgdmFyIGV4cCA9IHRoaXMucGFydGlhbEV2YWwoYXJnc1swXSwgcGFyYW1zKTtcbiAgICB0aGlzLnRoaXNJcyA9IGxhc3RUaGlzSXM7XG4gICAgcmV0dXJuIGV4cDtcbiAgfVxuXG4gIC8vIEJ1aWx0aW4gZnVuY3Rpb24gLSBjdXJyZW50IHZhbHVlIG9mICd0aGlzJ1xuICBnZXRUaGlzKGFyZ3M6IGFzdC5FeHBbXSwgcGFyYW1zOiBhc3QuUGFyYW1zKTogYXN0LkV4cCB7XG4gICAgcmV0dXJuIGFzdC5zbmFwc2hvdFZhcmlhYmxlKHRoaXMudGhpc0lzKTtcbiAgfVxuXG4gIC8vIEJ1aWx0aW4gZnVuY3Rpb24gLSBlbnN1cmUgdHlwZSBvZiBhcmd1bWVudFxuICBlbnN1cmVUeXBlKHR5cGU6IHN0cmluZywgYXJnczogYXN0LkV4cFtdLCBwYXJhbXM6IGFzdC5QYXJhbXMpIHtcbiAgICBpZiAoYXJncy5sZW5ndGggIT09IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMuYXBwbGljYXRpb24gKyBcImVuc3VyZVR5cGUgYXJndW1lbnRzLlwiKTtcbiAgICB9XG4gICAgdmFyIGV4cCA9IDxhc3QuRXhwVmFsdWU+IHRoaXMucGFydGlhbEV2YWwoYXJnc1swXSwgcGFyYW1zKTtcbiAgICBpZiAoZXhwLnR5cGUgIT09IHR5cGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMuY29lcmNpb24gKyBhc3QuZGVjb2RlRXhwcmVzc2lvbihleHApICsgXCIgPT4gXCIgKyB0eXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIGV4cDtcbiAgfVxuXG4gIC8vIEJ1aWx0aW4gZnVuY3Rpb24gLSByZXR1cm4gdGhlIHBhcmVudCBrZXkgb2YgJ3RoaXMnLlxuICBnZXRLZXkoa2V5OiBzdHJpbmcsIGFyZ3M6IGFzdC5FeHBbXSwgcGFyYW1zOiBhc3QuUGFyYW1zKSB7XG4gICAgaWYgKGFyZ3MubGVuZ3RoICE9PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLm1pc21hdGNoUGFyYW1zICsgXCIoZm91bmQgXCIgKyBhcmdzLmxlbmd0aCArIFwiIGJ1dCBleHBlY3RlZCAxKVwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4ga2V5WzBdID09PSAnJCcgPyBhc3QubGl0ZXJhbChrZXkpIDogYXN0LnN0cmluZyhrZXkpO1xuICB9XG5cbiAgLy8gQnVpbHRpbiBmdW5jdGlvbiAtIHJldHVybiB0aGUgcmVmZXJlbmNlIHRvIHRoZSByb290XG4gIC8vIFdoZW4gaW4gcmVhZCBtb2RlIC0gdXNlICdyb290J1xuICAvLyBXaGVuIGluIHdyaXRlL3ZhbGlkYXRlIC0gdXNlIHBhdGggdG8gcm9vdCB2aWEgbmV3RGF0YS5wYXJlbnQoKS4uLlxuICBnZXRSb290UmVmZXJlbmNlKHBhdGg6IGFzdC5QYXRoVGVtcGxhdGUsIGFyZ3M6IGFzdC5FeHBbXSwgcGFyYW1zOiBhc3QuUGFyYW1zKSB7XG4gICAgaWYgKGFyZ3MubGVuZ3RoICE9PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLmFwcGxpY2F0aW9uICsgXCJAcm9vdCBhcmd1bWVudHMuXCIpO1xuICAgIH1cblxuICAgIC8vICdkYXRhJyBjYXNlXG4gICAgaWYgKHRoaXMudGhpc0lzID09PSAnZGF0YScpIHtcbiAgICAgIHJldHVybiBhc3Quc25hcHNob3RWYXJpYWJsZSgncm9vdCcpO1xuICAgIH1cblxuICAgIC8vIFRPRE8oa29zcyk6IFJlbW92ZSB0aGlzIHNwZWNpYWwgY2FzZSBpZiBKU09OIHN1cHBvcnRzIG5ld1Jvb3QgaW5zdGVhZC5cbiAgICAvLyAnbmV3RGF0YScgY2FzZSAtIHRyYXZlcnNlIHRvIHJvb3QgdmlhIHBhcmVudCgpJ3MuXG4gICAgbGV0IHJlc3VsdDogYXN0LkV4cCA9IGFzdC5zbmFwc2hvdFZhcmlhYmxlKCduZXdEYXRhJyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aCgpOyBpKyspIHtcbiAgICAgIHJlc3VsdCA9IGFzdC5zbmFwc2hvdFBhcmVudChyZXN1bHQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gTG9va3VwIGdsb2JhbGx5IGRlZmluZWQgZnVuY3Rpb24uXG4gIGxvb2t1cEZ1bmN0aW9uKHJlZjogYXN0LkV4cFZhcmlhYmxlIHwgYXN0LkV4cFJlZmVyZW5jZSk6IHtcbiAgICBzZWxmPzogYXN0LkV4cCxcbiAgICBmbjogYXN0Lk1ldGhvZCxcbiAgICBtZXRob2ROYW1lOiBzdHJpbmdcbiAgfSB8IHVuZGVmaW5lZCB7XG4gICAgLy8gRnVuY3Rpb24gY2FsbC5cbiAgICBpZiAocmVmLnR5cGUgPT09ICd2YXInKSB7XG4gICAgICBsZXQgcmVmVmFyID0gPGFzdC5FeHBWYXJpYWJsZT4gcmVmO1xuICAgICAgdmFyIGZuID0gdGhpcy5zeW1ib2xzLmZ1bmN0aW9uc1tyZWZWYXIubmFtZV07XG4gICAgICBpZiAoIWZuKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4geyBzZWxmOiB1bmRlZmluZWQsIGZuOiBmbiwgbWV0aG9kTmFtZTogcmVmVmFyLm5hbWV9O1xuICAgIH1cblxuICAgIC8vIE1ldGhvZCBjYWxsLlxuICAgIGlmIChyZWYudHlwZSA9PT0gJ3JlZicpIHtcbiAgICAgIGxldCByZWZSZWYgPSA8YXN0LkV4cFJlZmVyZW5jZT4gcmVmO1xuICAgICAgLy8gVE9ETzogUmVxdWlyZSBzdGF0aWMgdHlwZSB2YWxpZGF0aW9uIGJlZm9yZSBjYWxsaW5nIFN0cmluZyBtZXRob2RzLlxuICAgICAgaWYgKCg8YXN0LkV4cE9wPiByZWZSZWYuYmFzZSkub3AgIT09ICd2YWx1ZScgJiZcbiAgICAgICAgICA8c3RyaW5nPiAoPGFzdC5FeHBWYWx1ZT4gcmVmUmVmLmFjY2Vzc29yKS52YWx1ZSBpbiB0aGlzLnN5bWJvbHMuc2NoZW1hWydTdHJpbmcnXS5tZXRob2RzKSB7XG4gICAgICAgIGxldCBtZXRob2ROYW1lID0gPHN0cmluZz4gKDxhc3QuRXhwVmFsdWU+IHJlZlJlZi5hY2Nlc3NvcikudmFsdWU7XG4gICAgICAgIHJldHVybiB7IHNlbGY6IHJlZlJlZi5iYXNlLFxuICAgICAgICAgICAgICAgICBmbjogdGhpcy5zeW1ib2xzLnNjaGVtYVsnU3RyaW5nJ10ubWV0aG9kc1ttZXRob2ROYW1lXSxcbiAgICAgICAgICAgICAgICAgbWV0aG9kTmFtZTogJ1N0cmluZy4nICsgbWV0aG9kTmFtZVxuICAgICAgICAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIGZhdGFsKHM6IHN0cmluZykge1xuICAgIGVycm9yKHMpO1xuICAgIHRoaXMuZXJyb3JDb3VudCArPSAxO1xuICB9XG59O1xuXG4vLyBNZXJnZSBhbGwgLlggdGVybXMgaW50byB0YXJnZXQuXG5leHBvcnQgZnVuY3Rpb24gZXh0ZW5kVmFsaWRhdG9yKHRhcmdldDogVmFsaWRhdG9yLCBzcmM6IFZhbGlkYXRvcik6IFZhbGlkYXRvciB7XG4gIGlmIChzcmMgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMuYXBwbGljYXRpb24gKyBcIklsbGVnYWwgdmFsaWRhdGlvbiBzb3VyY2UuXCIpO1xuICB9XG4gIGZvciAodmFyIHByb3AgaW4gc3JjKSB7XG4gICAgaWYgKCFzcmMuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAocHJvcFswXSA9PT0gJy4nKSB7XG4gICAgICBpZiAodGFyZ2V0W3Byb3BdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGFyZ2V0W3Byb3BdID0gW107XG4gICAgICB9XG4gICAgICBpZiAodXRpbC5pc1R5cGUoc3JjW3Byb3BdLCAnYXJyYXknKSkge1xuICAgICAgICB1dGlsLmV4dGVuZEFycmF5KDxhbnlbXT4gdGFyZ2V0W3Byb3BdLCA8YW55W10+IHNyY1twcm9wXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAoPGFzdC5FeHBbXT4gdGFyZ2V0W3Byb3BdKS5wdXNoKDxhc3QuRXhwPiBzcmNbcHJvcF0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIXRhcmdldFtwcm9wXSkge1xuICAgICAgICB0YXJnZXRbcHJvcF0gPSB7fTtcbiAgICAgIH1cbiAgICAgIGV4dGVuZFZhbGlkYXRvcig8VmFsaWRhdG9yPiB0YXJnZXRbcHJvcF0sIDxWYWxpZGF0b3I+IHNyY1twcm9wXSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuLy8gQ2FsbCBmbih2YWx1ZSwgcHJvcCwgcGF0aCkgb24gYWxsICcucHJvcHMnIGFuZCBhc3NpZ2luZyB0aGUgdmFsdWUgYmFjayBpbnRvIHRoZVxuLy8gdmFsaWRhdG9yLlxuZXhwb3J0IGZ1bmN0aW9uIG1hcFZhbGlkYXRvcih2OiBWYWxpZGF0b3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZuOiAodmFsOiBWYWxpZGF0b3JWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wOiBzdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGU6IGFzdC5QYXJhbXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogYXN0LlBhdGhUZW1wbGF0ZSkgPT4gVmFsaWRhdG9yVmFsdWUgfCB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlPzogYXN0LlBhcmFtcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aD86IGFzdC5QYXRoVGVtcGxhdGUpIHtcbiAgaWYgKCFzY29wZSkge1xuICAgIHNjb3BlID0gPGFzdC5QYXJhbXM+IHt9O1xuICB9XG4gIGlmICghcGF0aCkge1xuICAgIHBhdGggPSBuZXcgYXN0LlBhdGhUZW1wbGF0ZSgpO1xuICB9XG4gIGlmICgnLnNjb3BlJyBpbiB2KSB7XG4gICAgc2NvcGUgPSA8YXN0LlBhcmFtcz4gdlsnLnNjb3BlJ107XG4gIH1cbiAgZm9yICh2YXIgcHJvcCBpbiB2KSB7XG4gICAgaWYgKCF2Lmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHByb3BbMF0gPT09ICcuJykge1xuICAgICAgbGV0IHZhbHVlID0gZm4odltwcm9wXSwgcHJvcCwgc2NvcGUsIHBhdGgpO1xuICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdltwcm9wXSA9IHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlIHZbcHJvcF07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghdXRpbC5pc1R5cGUodltwcm9wXSwgJ29iamVjdCcpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGNoaWxkID0gbmV3IGFzdC5QYXRoVGVtcGxhdGUoW3Byb3BdKTtcbiAgICAgIHBhdGgucHVzaChjaGlsZCk7XG4gICAgICBtYXBWYWxpZGF0b3IoPFZhbGlkYXRvcj4gdltwcm9wXSwgZm4sIHNjb3BlLCBwYXRoKTtcbiAgICAgIHBhdGgucG9wKGNoaWxkKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gQ29sbGFwc2UgYWxsIGhhc0NoaWxkcmVuIGNhbGxzIGludG8gb25lIChjb21iaW5pbmcgdGhlaXIgYXJndW1lbnRzKS5cbi8vIEUuZy4gW25ld0RhdGEuaGFzQ2hpbGRyZW4oKSwgbmV3RGF0YS5oYXNDaGlsZHJlbihbJ3gnXSksIG5ld0RhdGEuaGFzQ2hpbGRyZW4oWyd5J10pXSA9PlxuLy8gICAgICBuZXdEYXRhLmhhc0NoaWxkcmVuKFsneCcsICd5J10pXG5mdW5jdGlvbiBjb2xsYXBzZUhhc0NoaWxkcmVuKGV4cHM6IGFzdC5FeHBbXSk6IGFzdC5FeHBbXSB7XG4gIHZhciBoYXNIYXNDaGlsZHJlbjogYm9vbGVhbiA9IGZhbHNlO1xuICB2YXIgY29tYmluZWQgPSA8c3RyaW5nW10+IFtdO1xuICB2YXIgcmVzdWx0ID0gPGFzdC5FeHBbXT4gW107XG4gIGV4cHMuZm9yRWFjaChmdW5jdGlvbihleHApIHtcbiAgICBpZiAoZXhwLnR5cGUgIT09ICdjYWxsJykge1xuICAgICAgcmVzdWx0LnB1c2goZXhwKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgZXhwQ2FsbCA9IDxhc3QuRXhwQ2FsbD4gZXhwO1xuICAgIGlmIChhc3QuZ2V0TWV0aG9kTmFtZShleHBDYWxsKSAhPT0gJ2hhc0NoaWxkcmVuJykge1xuICAgICAgcmVzdWx0LnB1c2goZXhwKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZXhwQ2FsbC5hcmdzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgaGFzSGFzQ2hpbGRyZW4gPSB0cnVlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEV4cGVjdCBvbmUgYXJndW1lbnQgb2YgQXJyYXkgdHlwZS5cbiAgICBpZiAoZXhwQ2FsbC5hcmdzLmxlbmd0aCAhPT0gMSB8fCBleHBDYWxsLmFyZ3NbMF0udHlwZSAhPT0gJ0FycmF5Jykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9ycy5hcHBsaWNhdGlvbiArIFwiSW52YWxpZCBhcmd1bWVudCB0byBoYXNDaGlsZHJlbigpOiBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgZXhwQ2FsbC5hcmdzWzBdLnR5cGUpO1xuICAgIH1cbiAgICBsZXQgYXJncyA9ICg8YXN0LkV4cFZhbHVlPiBleHBDYWxsLmFyZ3NbMF0pLnZhbHVlO1xuXG4gICAgYXJncy5mb3JFYWNoKGZ1bmN0aW9uKGFyZzogYXN0LkV4cFZhbHVlKSB7XG4gICAgICBoYXNIYXNDaGlsZHJlbiA9IHRydWU7XG4gICAgICBpZiAoYXJnLnR5cGUgIT09ICdTdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMuYXBwbGljYXRpb24gKyBcIkV4cGVjdCBzdHJpbmcgYXJndW1lbnQgdG8gaGFzQ2hpbGRyZW4oKSwgbm90OiBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmcudHlwZSk7XG4gICAgICB9XG4gICAgICBjb21iaW5lZC5wdXNoKGFyZy52YWx1ZSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGlmIChoYXNIYXNDaGlsZHJlbikge1xuICAgIHJlc3VsdC51bnNoaWZ0KGhhc0NoaWxkcmVuRXhwKGNvbWJpbmVkKSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gR2VuZXJhdGUgdGhpcy5oYXNDaGlsZHJlbihbcHJvcHMsIC4uLl0pIG9yIHRoaXMuaGFzQ2hpbGRyZW4oKVxuZnVuY3Rpb24gaGFzQ2hpbGRyZW5FeHAocHJvcHM6IHN0cmluZ1tdKTogYXN0LkV4cCB7XG4gIHZhciBhcmdzID0gcHJvcHMubGVuZ3RoID09PSAwID8gW10gOiBbYXN0LmFycmF5KHByb3BzLm1hcChhc3Quc3RyaW5nKSldO1xuICByZXR1cm4gYXN0LmNhbGwoYXN0LnJlZmVyZW5jZShhc3QuY2FzdChhc3QudmFyaWFibGUoJ3RoaXMnKSwgJ0FueScpLCBhc3Quc3RyaW5nKCdoYXNDaGlsZHJlbicpKSxcbiAgICAgICAgICAgICAgICAgIGFyZ3MpO1xufVxuIl19
