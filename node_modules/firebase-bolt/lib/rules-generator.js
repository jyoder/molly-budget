"use strict";
/*
 * Copyright 2015 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var util = require('./util');
var ast = require('./ast');
var logger_1 = require('./logger');
var parser = require('./rules-parser');
var parse_util_1 = require('./parse-util');
var errors = {
    badIndex: "The index function must return a String or an array of Strings.",
    noPaths: "Must have at least one path expression.",
    nonObject: "Type contains properties and must extend 'Object'.",
    missingSchema: "Missing definition for type.",
    recursive: "Recursive function call.",
    mismatchParams: "Incorrect number of function arguments.",
    generateFailed: "Could not generate JSON: ",
    noSuchType: "No type definition for: ",
    badSchemaMethod: "Unsupported method name in type statement: ",
    badPathMethod: "Unsupported method name in path statement: ",
    badWriteAlias: "Cannot have both a write() method and a write-aliasing method: ",
    coercion: "Cannot convert value: ",
    undefinedFunction: "Undefined function: ",
    application: "Bolt application error: ",
    invalidGeneric: "Invalid generic schema usage: ",
    invalidMapKey: "Map<Key, T> - Key must derive from String type.",
    invalidWildChildren: "Types can have at most one $wild property and cannot mix with other properties.",
    invalidPropertyName: "Property names cannot contain any of: . $ # [ ] / or control characters: "
};
var INVALID_KEY_REGEX = /[\[\].#$\/\u0000-\u001F\u007F]/;
;
var builtinSchemaNames = ['Any', 'Null', 'String', 'Number', 'Boolean', 'Object'];
// Method names allowed in Bolt files.
var valueMethods = ['length', 'includes', 'startsWith', 'beginsWith', 'endsWith',
    'replace', 'toLowerCase', 'toUpperCase', 'test', 'contains',
    'matches'];
// TODO: Make sure users don't call internal methods...make private to impl.
var snapshotMethods = ['parent', 'child', 'hasChildren', 'val', 'isString', 'isNumber',
    'isBoolean'].concat(valueMethods);
var writeAliases = {
    'create': parse_util_1.parseExpression('prior(this) == null'),
    'update': parse_util_1.parseExpression('prior(this) != null && this != null'),
    'delete': parse_util_1.parseExpression('prior(this) != null && this == null')
};
// Usage:
//   json = bolt.generate(bolt-text)
function generate(symbols) {
    if (typeof symbols === 'string') {
        symbols = parser.parse(symbols);
    }
    var gen = new Generator(symbols);
    return gen.generateRules();
}
exports.generate = generate;
// Symbols contains:
//   functions: {}
//   schema: {}
//   paths: {}
var Generator = (function () {
    function Generator(symbols) {
        this.symbols = symbols;
        this.validators = {};
        this.rules = {};
        this.errorCount = 0;
        this.runSilently = false;
        this.allowUndefinedFunctions = false;
        this.keyIndex = 0;
        // TODO: globals should be part of this.symbols (nested scopes)
        this.globals = {
            "root": ast.call(ast.variable('@root'))
        };
        this.registerBuiltinSchema();
    }
    // Return Firebase compatible Rules JSON for a the given symbols definitions.
    Generator.prototype.generateRules = function () {
        var _this = this;
        this.errorCount = 0;
        var paths = this.symbols.paths;
        var schema = this.symbols.schema;
        var name;
        paths.forEach(function (path) {
            _this.validateMethods(errors.badPathMethod, path.methods, ['validate', 'read', 'write', 'index']);
        });
        for (name in schema) {
            if (!util.arrayIncludes(builtinSchemaNames, name)) {
                this.validateMethods(errors.badSchemaMethod, schema[name].methods, ['validate', 'read', 'write']);
            }
        }
        if (paths.length === 0) {
            this.fatal(errors.noPaths);
        }
        paths.forEach(function (path) { return _this.updateRules(path); });
        this.convertExpressions(this.rules);
        if (this.errorCount !== 0) {
            throw new Error(errors.generateFailed + this.errorCount + " errors.");
        }
        util.deletePropName(this.rules, '.scope');
        util.pruneEmptyChildren(this.rules);
        return {
            rules: this.rules
        };
    };
    Generator.prototype.validateMethods = function (m, methods, allowed) {
        var _this = this;
        if (util.arrayIncludes(allowed, 'write')) {
            allowed = allowed.concat(Object.keys(writeAliases));
        }
        for (var method in methods) {
            if (!util.arrayIncludes(allowed, method)) {
                logger_1.warn(m + util.quoteString(method) +
                    " (allowed: " + allowed.map(util.quoteString).join(', ') + ")");
            }
        }
        if ('write' in methods) {
            Object.keys(writeAliases).forEach(function (alias) {
                if (alias in methods) {
                    _this.fatal(errors.badWriteAlias + alias);
                }
            });
        }
    };
    Generator.prototype.registerBuiltinSchema = function () {
        var self = this;
        var thisVar = ast.variable('this');
        function registerAsCall(name, methodName) {
            self.symbols.registerSchema(name, ast.typeType('Any'), undefined, {
                validate: ast.method(['this'], ast.call(ast.reference(ast.cast(thisVar, 'Any'), ast.string(methodName))))
            });
        }
        this.symbols.registerSchema('Any', ast.typeType('Any'), undefined, {
            validate: ast.method(['this'], ast.boolean(true))
        });
        registerAsCall('Object', 'hasChildren');
        // Because of the way firebase treats Null values, there is no way to
        // write a validation rule, that will EVER be called with this == null
        // (firebase allows values to be deleted no matter their validation rules).
        // So, comparing this == null will always return false -> that is what
        // we do here, which will be optimized away if ORed with other validations.
        this.symbols.registerSchema('Null', ast.typeType('Any'), undefined, {
            validate: ast.method(['this'], ast.boolean(false))
        });
        self.symbols.registerSchema('String', ast.typeType('Any'), undefined, {
            validate: ast.method(['this'], ast.call(ast.reference(ast.cast(thisVar, 'Any'), ast.string('isString')))),
            includes: ast.method(['this', 's'], ast.call(ast.reference(ast.value(thisVar), ast.string('contains')), [ast.value(ast.variable('s'))])),
            startsWith: ast.method(['this', 's'], ast.call(ast.reference(ast.value(thisVar), ast.string('beginsWith')), [ast.value(ast.variable('s'))])),
            endsWith: ast.method(['this', 's'], ast.call(ast.reference(ast.value(thisVar), ast.string('endsWith')), [ast.value(ast.variable('s'))])),
            replace: ast.method(['this', 's', 'r'], ast.call(ast.reference(ast.value(thisVar), ast.string('replace')), [ast.value(ast.variable('s')), ast.value(ast.variable('r'))])),
            test: ast.method(['this', 'r'], ast.call(ast.reference(ast.value(thisVar), ast.string('matches')), [ast.call(ast.variable('@RegExp'), [ast.variable('r')])]))
        });
        registerAsCall('Number', 'isNumber');
        registerAsCall('Boolean', 'isBoolean');
        this.symbols.registerFunction('@RegExp', ['r'], ast.builtin(this.ensureType.bind(this, 'RegExp')));
        var map = this.symbols.registerSchema('Map', ast.typeType('Any'), undefined, undefined, ['Key', 'Value']);
        map.getValidator = this.getMapValidator.bind(this);
    };
    // type Map<Key, Value> => {
    //   $key: {
    //     '.validate': $key instanceof Key and this instanceof Value;
    //   '.validate': 'newData.hasChildren()'
    // }
    // Key must derive from String
    Generator.prototype.getMapValidator = function (params) {
        var keyType = params[0];
        var valueType = params[1];
        if (keyType.type !== 'type' || !this.symbols.isDerivedFrom(keyType, 'String')) {
            throw new Error(errors.invalidMapKey + "  (" + ast.decodeExpression(keyType) + " does not)");
        }
        var validator = {};
        var index = this.uniqueKey();
        validator[index] = {};
        extendValidator(validator, this.ensureValidator(ast.typeType('Object')));
        // First validate the key (omit terminal String type validation).
        while (keyType.name !== 'String') {
            var schema = this.symbols.schema[keyType.name];
            if (schema.methods['validate']) {
                var exp = this.partialEval(schema.methods['validate'].body, { 'this': ast.literal(index) });
                extendValidator(validator[index], { '.validate': [exp] });
            }
            keyType = schema.derivedFrom;
        }
        extendValidator(validator[index], this.ensureValidator(valueType));
        return validator;
    };
    Generator.prototype.uniqueKey = function () {
        this.keyIndex += 1;
        return '$key' + this.keyIndex;
    };
    // Collection schema has exactly one $wildchild property
    Generator.prototype.isCollectionSchema = function (schema) {
        var props = Object.keys(schema.properties);
        var result = props.length === 1 && props[0][0] === '$';
        return result;
    };
    // Ensure we have a definition for a validator for the given schema.
    Generator.prototype.ensureValidator = function (type) {
        var key = ast.decodeExpression(type);
        if (!this.validators[key]) {
            this.validators[key] = { '.validate': ast.literal('***TYPE RECURSION***') };
            var allowSave = this.allowUndefinedFunctions;
            this.allowUndefinedFunctions = true;
            this.validators[key] = this.createValidator(type);
            this.allowUndefinedFunctions = allowSave;
        }
        return this.validators[key];
    };
    Generator.prototype.createValidator = function (type) {
        var _this = this;
        switch (type.type) {
            case 'type':
                return this.createValidatorFromSchemaName(type.name);
            case 'union':
                var union_1 = {};
                type.types.forEach(function (typePart) {
                    // Make a copy
                    var singleType = extendValidator({}, _this.ensureValidator(typePart));
                    mapValidator(singleType, ast.andArray);
                    extendValidator(union_1, singleType);
                });
                mapValidator(union_1, ast.orArray);
                return union_1;
            case 'generic':
                var genericType = type;
                return this.createValidatorFromGeneric(genericType.name, genericType.params);
            default:
                throw new Error(errors.application + "invalid internal type: " + type.type);
        }
    };
    Generator.prototype.createValidatorFromGeneric = function (schemaName, params) {
        var schema = this.symbols.schema[schemaName];
        if (schema === undefined || !ast.Schema.isGeneric(schema)) {
            throw new Error(errors.noSuchType + schemaName + " (generic)");
        }
        var schemaParams = schema.params;
        if (params.length !== schemaParams.length) {
            throw new Error(errors.invalidGeneric + " expected <" + schemaParams.join(', ') + ">");
        }
        // Call custom validator, if given.
        if (schema.getValidator) {
            return schema.getValidator(params);
        }
        var bindings = {};
        for (var i = 0; i < params.length; i++) {
            bindings[schemaParams[i]] = params[i];
        }
        // Expand generics and generate validator from schema.
        schema = this.replaceGenericsInSchema(schema, bindings);
        return this.createValidatorFromSchema(schema);
    };
    Generator.prototype.replaceGenericsInSchema = function (schema, bindings) {
        var _this = this;
        var expandedSchema = {
            derivedFrom: this.replaceGenericsInExp(schema.derivedFrom, bindings),
            properties: {},
            methods: {}
        };
        var props = Object.keys(schema.properties);
        props.forEach(function (prop) {
            expandedSchema.properties[prop] =
                _this.replaceGenericsInExp(schema.properties[prop], bindings);
        });
        var methods = Object.keys(schema.methods);
        methods.forEach(function (methodName) {
            expandedSchema.methods[methodName] = _this.replaceGenericsInMethod(schema.methods[methodName], bindings);
        });
        return expandedSchema;
    };
    Generator.prototype.replaceGenericsInExp = function (exp, bindings) {
        var self = this;
        function replaceGenericsInArray(exps) {
            return exps.map(function (expPart) {
                return self.replaceGenericsInExp(expPart, bindings);
            });
        }
        switch (exp.type) {
            case 'op':
            case 'call':
                var opType = ast.copyExp(exp);
                opType.args = replaceGenericsInArray(opType.args);
                return opType;
            case 'type':
                var simpleType = exp;
                return bindings[simpleType.name] || simpleType;
            case 'union':
                var unionType = exp;
                return ast.unionType(replaceGenericsInArray(unionType.types));
            case 'generic':
                var genericType = exp;
                return ast.genericType(genericType.name, replaceGenericsInArray(genericType.params));
            default:
                return exp;
        }
    };
    Generator.prototype.replaceGenericsInMethod = function (method, bindings) {
        var expandedMethod = {
            params: method.params,
            body: method.body
        };
        expandedMethod.body = this.replaceGenericsInExp(method.body, bindings);
        return expandedMethod;
    };
    Generator.prototype.createValidatorFromSchemaName = function (schemaName) {
        var schema = this.symbols.schema[schemaName];
        if (!schema) {
            throw new Error(errors.noSuchType + schemaName);
        }
        if (ast.Schema.isGeneric(schema)) {
            throw new Error(errors.noSuchType + schemaName + " used as non-generic type.");
        }
        return this.createValidatorFromSchema(schema);
    };
    Generator.prototype.createValidatorFromSchema = function (schema) {
        var _this = this;
        var hasProps = Object.keys(schema.properties).length > 0 &&
            !this.isCollectionSchema(schema);
        if (hasProps && !this.symbols.isDerivedFrom(schema.derivedFrom, 'Object')) {
            this.fatal(errors.nonObject + " (is " + ast.decodeExpression(schema.derivedFrom) + ")");
            return {};
        }
        var validator = {};
        if (!(schema.derivedFrom.type === 'type' &&
            schema.derivedFrom.name === 'Any')) {
            extendValidator(validator, this.ensureValidator(schema.derivedFrom));
        }
        var requiredProperties = [];
        var wildProperties = 0;
        Object.keys(schema.properties).forEach(function (propName) {
            if (propName[0] === '$') {
                wildProperties += 1;
                if (INVALID_KEY_REGEX.test(propName.slice(1))) {
                    _this.fatal(errors.invalidPropertyName + propName);
                }
            }
            else {
                if (INVALID_KEY_REGEX.test(propName)) {
                    _this.fatal(errors.invalidPropertyName + propName);
                }
            }
            if (!validator[propName]) {
                validator[propName] = {};
            }
            var propType = schema.properties[propName];
            if (propName[0] !== '$' && !_this.isNullableType(propType)) {
                requiredProperties.push(propName);
            }
            extendValidator(validator[propName], _this.ensureValidator(propType));
        });
        if (wildProperties > 1 || wildProperties === 1 && requiredProperties.length > 0) {
            this.fatal(errors.invalidWildChildren);
        }
        if (requiredProperties.length > 0) {
            // this.hasChildren(requiredProperties)
            extendValidator(validator, { '.validate': [hasChildrenExp(requiredProperties)] });
        }
        // Disallow $other properties by default
        if (hasProps) {
            validator['$other'] = {};
            extendValidator(validator['$other'], { '.validate': ast.boolean(false) });
        }
        this.extendValidationMethods(validator, schema.methods);
        return validator;
    };
    Generator.prototype.isNullableType = function (type) {
        var result = this.symbols.isDerivedFrom(type, 'Null') ||
            this.symbols.isDerivedFrom(type, 'Map');
        return result;
    };
    // Update rules based on the given path expression.
    Generator.prototype.updateRules = function (path) {
        var i;
        var location = util.ensureObjectPath(this.rules, path.template.getLabels());
        var exp;
        extendValidator(location, this.ensureValidator(path.isType));
        location['.scope'] = path.template.getScope();
        this.extendValidationMethods(location, path.methods);
        // Write indices
        if (path.methods['index']) {
            switch (path.methods['index'].body.type) {
                case 'String':
                    exp = ast.array([path.methods['index'].body]);
                    break;
                case 'Array':
                    exp = path.methods['index'].body;
                    break;
                default:
                    this.fatal(errors.badIndex);
                    return;
            }
            var indices = [];
            for (i = 0; i < exp.value.length; i++) {
                if (exp.value[i].type !== 'String') {
                    this.fatal(errors.badIndex + " (not " + exp.value[i].type + ")");
                }
                else {
                    indices.push(exp.value[i].value);
                }
            }
            // TODO: Error check not over-writing index rules.
            location['.indexOn'] = indices;
        }
    };
    Generator.prototype.extendValidationMethods = function (validator, methods) {
        var writeMethods = [];
        ['create', 'update', 'delete'].forEach(function (method) {
            if (method in methods) {
                writeMethods.push(ast.andArray([writeAliases[method], methods[method].body]));
            }
        });
        if (writeMethods.length !== 0) {
            extendValidator(validator, { '.write': ast.orArray(writeMethods) });
        }
        ['validate', 'read', 'write'].forEach(function (method) {
            if (method in methods) {
                var methodValidator = {};
                methodValidator['.' + method] = methods[method].body;
                extendValidator(validator, methodValidator);
            }
        });
    };
    // Return union validator (||) over each schema
    Generator.prototype.unionValidators = function (schema) {
        var union = {};
        schema.forEach(function (typeName) {
            // First and the validator terms for a single type
            // Todo extend to unions and generics
            var singleType = extendValidator({}, this.ensureValidator(typeName));
            mapValidator(singleType, ast.andArray);
            extendValidator(union, singleType);
        }.bind(this));
        mapValidator(union, ast.orArray);
        return union;
    };
    // Convert expressions to text, and at the same time, apply pruning operations
    // to remove no-op rules.
    Generator.prototype.convertExpressions = function (validator) {
        var _this = this;
        var methodThisIs = { '.validate': 'newData',
            '.read': 'data',
            '.write': 'newData' };
        function hasWildcardSibling(path) {
            var parts = path.getLabels();
            var childPart = parts.pop();
            var parent = util.deepLookup(validator, parts);
            if (parent === undefined) {
                return false;
            }
            for (var _i = 0, _a = Object.keys(parent); _i < _a.length; _i++) {
                var prop = _a[_i];
                if (prop === childPart) {
                    continue;
                }
                if (prop[0] === '$') {
                    return true;
                }
            }
            return false;
        }
        mapValidator(validator, function (value, prop, scope, path) {
            if (prop in methodThisIs) {
                var result = _this.getExpressionText(ast.andArray(collapseHasChildren(value)), methodThisIs[prop], scope, path);
                // Remove no-op .read or .write rule if no sibling wildcard props.
                if ((prop === '.read' || prop === '.write') && result === 'false') {
                    if (!hasWildcardSibling(path)) {
                        return undefined;
                    }
                }
                // Remove no-op .validate rule if no sibling wildcard props.
                if (prop === '.validate' && result === 'true') {
                    if (!hasWildcardSibling(path)) {
                        return undefined;
                    }
                }
                return result;
            }
            return value;
        });
    };
    Generator.prototype.getExpressionText = function (exp, thisIs, scope, path) {
        if (!('type' in exp)) {
            throw new Error(errors.application + "Not an expression: " + util.prettyJSON(exp));
        }
        // First evaluate w/o binding of this to specific location.
        this.allowUndefinedFunctions = true;
        scope = util.extend({}, scope, { 'this': ast.cast(ast.call(ast.variable('@getThis')), 'Snapshot') });
        exp = this.partialEval(exp, scope);
        // Now re-evaluate the flattened expression.
        this.allowUndefinedFunctions = false;
        this.thisIs = thisIs;
        this.symbols.registerFunction('@getThis', [], ast.builtin(this.getThis.bind(this)));
        this.symbols.registerFunction('@root', [], ast.builtin(this.getRootReference.bind(this, path)));
        this.symbols.registerFunction('prior', ['exp'], ast.builtin(this.prior.bind(this)));
        this.symbols.registerFunction('key', [], ast.builtin(this.getKey.bind(this, path.length() === 0 ? '' : path.getPart(-1).label)));
        exp = this.partialEval(exp);
        delete this.symbols.functions['@getThis'];
        delete this.symbols.functions['@root'];
        delete this.symbols.functions['prior'];
        delete this.symbols.functions['key'];
        // Top level expressions should never be to a snapshot reference - should
        // always evaluate to a boolean.
        exp = ast.ensureBoolean(exp);
        return ast.decodeExpression(exp);
    };
    /*
     *  Wrapper for partialEval debugging.
     */
    Generator.prototype.partialEval = function (exp, params, functionCalls) {
        if (params === void 0) { params = {}; }
        if (functionCalls === void 0) { functionCalls = {}; }
        // Wrap real call for debugging.
        var result = this.partialEvalReal(exp, params, functionCalls);
        // console.log(ast.decodeExpression(exp) + " => " + ast.decodeExpression(result));
        return result;
    };
    // Partial evaluation of expressions - copy of expression tree (immutable).
    //
    // - Expand inline function calls.
    // - Replace local and global variables with their values.
    // - Expand snapshot references using child('ref').
    // - Coerce snapshot references to values as needed.
    Generator.prototype.partialEvalReal = function (exp, params, functionCalls) {
        if (params === void 0) { params = {}; }
        if (functionCalls === void 0) { functionCalls = {}; }
        var self = this;
        function subExpression(exp2) {
            return self.partialEval(exp2, params, functionCalls);
        }
        function valueExpression(exp2) {
            return ast.ensureValue(subExpression(exp2));
        }
        function booleanExpression(exp2) {
            return ast.ensureBoolean(subExpression(exp2));
        }
        function lookupVar(exp2) {
            // TODO: Unbound variable access should be an error.
            return params[exp2.name] || self.globals[exp2.name] || exp2;
        }
        // Convert ref[prop] => ref.child(prop)
        function snapshotChild(ref) {
            return ast.cast(ast.call(ast.reference(ref.base, ast.string('child')), [ref.accessor]), 'Snapshot');
        }
        switch (exp.type) {
            case 'op':
                var expOp = ast.copyExp(exp);
                // Ensure arguments are boolean (or values) where needed.
                if (expOp.op === 'value') {
                    expOp.args[0] = valueExpression(expOp.args[0]);
                }
                else if (expOp.op === '||' || expOp.op === '&&' || expOp.op === '!') {
                    for (var i = 0; i < expOp.args.length; i++) {
                        expOp.args[i] = booleanExpression(expOp.args[i]);
                    }
                }
                else if (expOp.op === '?:') {
                    expOp.args[0] = booleanExpression(expOp.args[0]);
                    expOp.args[1] = valueExpression(expOp.args[1]);
                    expOp.args[2] = valueExpression(expOp.args[2]);
                }
                else {
                    for (var i = 0; i < expOp.args.length; i++) {
                        expOp.args[i] = valueExpression(expOp.args[i]);
                    }
                }
                return expOp;
            case 'var':
                return lookupVar(exp);
            case 'ref':
                var expRef = ast.copyExp(exp);
                expRef.base = subExpression(expRef.base);
                // var[ref] => var[ref]
                if (expRef.base.valueType !== 'Snapshot') {
                    expRef.accessor = subExpression(expRef.accessor);
                    return expRef;
                }
                var propName = ast.getPropName(expRef);
                // snapshot.prop (static string property)
                if (propName !== '') {
                    // snapshot.valueMethod => snapshot.val().valueMethod
                    if (util.arrayIncludes(valueMethods, propName)) {
                        expRef.base = valueExpression(expRef.base);
                        return expRef;
                    }
                    // snapshot.ssMethod => snapshot.ssMethod
                    if (util.arrayIncludes(snapshotMethods, propName)) {
                        return expRef;
                    }
                }
                // snapshot[exp] => snapshot.child(exp) or
                // snapshot[ref] => snapshot.child(ref.val())
                expRef.accessor = valueExpression(expRef.accessor);
                return snapshotChild(expRef);
            case 'call':
                var expCall = ast.copyExp(exp);
                expCall.ref = subExpression(expCall.ref);
                var callee = this.lookupFunction(expCall.ref);
                // Expand the function call inline
                if (callee) {
                    var fn = callee.fn;
                    if (callee.self) {
                        expCall.args.unshift(ast.ensureValue(callee.self));
                    }
                    if (fn.params.length !== expCall.args.length) {
                        this.fatal(errors.mismatchParams + " ( " +
                            callee.methodName + " expects " + fn.params.length +
                            " but actually passed " + expCall.args.length + ")");
                        return exp;
                    }
                    if (fn.body.type === 'builtin') {
                        return fn.body.fn(expCall.args, params);
                    }
                    var innerParams = {};
                    for (var i = 0; i < fn.params.length; i++) {
                        innerParams[fn.params[i]] = subExpression(expCall.args[i]);
                    }
                    if (functionCalls[callee.methodName]) {
                        throw new Error(errors.recursive + " (" + callee.methodName + ")");
                    }
                    functionCalls[callee.methodName] = true;
                    var result = this.partialEval(fn.body, innerParams, functionCalls);
                    functionCalls[callee.methodName] = false;
                    return result;
                }
                // Can't expand function - but just expand the arguments.
                if (!this.allowUndefinedFunctions) {
                    var funcName = ast.getMethodName(expCall);
                    if (funcName !== '' && !(funcName in this.symbols.schema['String'].methods ||
                        util.arrayIncludes(snapshotMethods, funcName))) {
                        this.fatal(errors.undefinedFunction + ast.decodeExpression(expCall.ref));
                    }
                }
                for (var i = 0; i < expCall.args.length; i++) {
                    expCall.args[i] = subExpression(expCall.args[i]);
                }
                // Hack for snapshot.parent().val()
                // Todo - build table-based method signatures.
                if (ast.getMethodName(expCall) === 'parent') {
                    expCall = ast.cast(expCall, 'Snapshot');
                }
                return expCall;
            // Expression types (like literals) than need no expansion.
            default:
                return exp;
        }
    };
    // Builtin function - convert all 'this' to 'data' (from 'newData').
    // Args are function arguments, and params are the local (function) scope variables.
    Generator.prototype.prior = function (args, params) {
        var lastThisIs = this.thisIs;
        this.thisIs = 'data';
        var exp = this.partialEval(args[0], params);
        this.thisIs = lastThisIs;
        return exp;
    };
    // Builtin function - current value of 'this'
    Generator.prototype.getThis = function (args, params) {
        return ast.snapshotVariable(this.thisIs);
    };
    // Builtin function - ensure type of argument
    Generator.prototype.ensureType = function (type, args, params) {
        if (args.length !== 1) {
            throw new Error(errors.application + "ensureType arguments.");
        }
        var exp = this.partialEval(args[0], params);
        if (exp.type !== type) {
            throw new Error(errors.coercion + ast.decodeExpression(exp) + " => " + type);
        }
        return exp;
    };
    // Builtin function - return the parent key of 'this'.
    Generator.prototype.getKey = function (key, args, params) {
        if (args.length !== 0) {
            throw new Error(errors.mismatchParams + "(found " + args.length + " but expected 1)");
        }
        return key[0] === '$' ? ast.literal(key) : ast.string(key);
    };
    // Builtin function - return the reference to the root
    // When in read mode - use 'root'
    // When in write/validate - use path to root via newData.parent()...
    Generator.prototype.getRootReference = function (path, args, params) {
        if (args.length !== 0) {
            throw new Error(errors.application + "@root arguments.");
        }
        // 'data' case
        if (this.thisIs === 'data') {
            return ast.snapshotVariable('root');
        }
        // TODO(koss): Remove this special case if JSON supports newRoot instead.
        // 'newData' case - traverse to root via parent()'s.
        var result = ast.snapshotVariable('newData');
        for (var i = 0; i < path.length(); i++) {
            result = ast.snapshotParent(result);
        }
        return result;
    };
    // Lookup globally defined function.
    Generator.prototype.lookupFunction = function (ref) {
        // Function call.
        if (ref.type === 'var') {
            var refVar = ref;
            var fn = this.symbols.functions[refVar.name];
            if (!fn) {
                return undefined;
            }
            return { self: undefined, fn: fn, methodName: refVar.name };
        }
        // Method call.
        if (ref.type === 'ref') {
            var refRef = ref;
            // TODO: Require static type validation before calling String methods.
            if (refRef.base.op !== 'value' &&
                refRef.accessor.value in this.symbols.schema['String'].methods) {
                var methodName = refRef.accessor.value;
                return { self: refRef.base,
                    fn: this.symbols.schema['String'].methods[methodName],
                    methodName: 'String.' + methodName
                };
            }
        }
        return undefined;
    };
    Generator.prototype.fatal = function (s) {
        logger_1.error(s);
        this.errorCount += 1;
    };
    return Generator;
}());
exports.Generator = Generator;
;
// Merge all .X terms into target.
function extendValidator(target, src) {
    if (src === undefined) {
        throw new Error(errors.application + "Illegal validation source.");
    }
    for (var prop in src) {
        if (!src.hasOwnProperty(prop)) {
            continue;
        }
        if (prop[0] === '.') {
            if (target[prop] === undefined) {
                target[prop] = [];
            }
            if (util.isType(src[prop], 'array')) {
                util.extendArray(target[prop], src[prop]);
            }
            else {
                target[prop].push(src[prop]);
            }
        }
        else {
            if (!target[prop]) {
                target[prop] = {};
            }
            extendValidator(target[prop], src[prop]);
        }
    }
    return target;
}
exports.extendValidator = extendValidator;
// Call fn(value, prop, path) on all '.props' and assiging the value back into the
// validator.
function mapValidator(v, fn, scope, path) {
    if (!scope) {
        scope = {};
    }
    if (!path) {
        path = new ast.PathTemplate();
    }
    if ('.scope' in v) {
        scope = v['.scope'];
    }
    for (var prop in v) {
        if (!v.hasOwnProperty(prop)) {
            continue;
        }
        if (prop[0] === '.') {
            var value = fn(v[prop], prop, scope, path);
            if (value !== undefined) {
                v[prop] = value;
            }
            else {
                delete v[prop];
            }
        }
        else if (!util.isType(v[prop], 'object')) {
            continue;
        }
        else {
            var child = new ast.PathTemplate([prop]);
            path.push(child);
            mapValidator(v[prop], fn, scope, path);
            path.pop(child);
        }
    }
}
exports.mapValidator = mapValidator;
// Collapse all hasChildren calls into one (combining their arguments).
// E.g. [newData.hasChildren(), newData.hasChildren(['x']), newData.hasChildren(['y'])] =>
//      newData.hasChildren(['x', 'y'])
function collapseHasChildren(exps) {
    var hasHasChildren = false;
    var combined = [];
    var result = [];
    exps.forEach(function (exp) {
        if (exp.type !== 'call') {
            result.push(exp);
            return;
        }
        var expCall = exp;
        if (ast.getMethodName(expCall) !== 'hasChildren') {
            result.push(exp);
            return;
        }
        if (expCall.args.length === 0) {
            hasHasChildren = true;
            return;
        }
        // Expect one argument of Array type.
        if (expCall.args.length !== 1 || expCall.args[0].type !== 'Array') {
            throw new Error(errors.application + "Invalid argument to hasChildren(): " +
                expCall.args[0].type);
        }
        var args = expCall.args[0].value;
        args.forEach(function (arg) {
            hasHasChildren = true;
            if (arg.type !== 'String') {
                throw new Error(errors.application + "Expect string argument to hasChildren(), not: " +
                    arg.type);
            }
            combined.push(arg.value);
        });
    });
    if (hasHasChildren) {
        result.unshift(hasChildrenExp(combined));
    }
    return result;
}
// Generate this.hasChildren([props, ...]) or this.hasChildren()
function hasChildrenExp(props) {
    var args = props.length === 0 ? [] : [ast.array(props.map(ast.string))];
    return ast.call(ast.reference(ast.cast(ast.variable('this'), 'Any'), ast.string('hasChildren')), args);
}

//# sourceMappingURL=data:application/json;charset=utf8;base64,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Q0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLEtBQUssUUFBUSxDQUFDLENBQUMsQ0FBQztnQkFDMUIsTUFBTSxJQUFJLEtBQUssQ0FBQyxNQUFNLENBQUMsV0FBVyxHQUFHLGdEQUFnRDtvQkFDckUsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDO1lBQzVCLENBQUM7WUFDRCxRQUFRLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUMzQixDQUFDLENBQUMsQ0FBQztJQUNMLENBQUMsQ0FBQyxDQUFDO0lBRUgsRUFBRSxDQUFDLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQztRQUNuQixNQUFNLENBQUMsT0FBTyxDQUFDLGNBQWMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO0lBQzNDLENBQUM7SUFDRCxNQUFNLENBQUMsTUFBTSxDQUFDO0FBQ2hCLENBQUM7QUFFRCxnRUFBZ0U7QUFDaEUsd0JBQXdCLEtBQWU7SUFDckMsSUFBSSxJQUFJLEdBQUcsS0FBSyxDQUFDLE1BQU0sS0FBSyxDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDeEUsTUFBTSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLEVBQUUsS0FBSyxDQUFDLEVBQUUsR0FBRyxDQUFDLE1BQU0sQ0FBQyxhQUFhLENBQUMsQ0FBQyxFQUMvRSxJQUFJLENBQUMsQ0FBQztBQUN4QixDQUFDIiwiZmlsZSI6InJ1bGVzLWdlbmVyYXRvci5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBDb3B5cmlnaHQgMjAxNSBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuaW1wb3J0ICogYXMgdXRpbCBmcm9tICcuL3V0aWwnO1xuaW1wb3J0ICogYXMgYXN0IGZyb20gJy4vYXN0JztcbmltcG9ydCB7d2FybiwgZXJyb3J9IGZyb20gJy4vbG9nZ2VyJztcbmxldCBwYXJzZXIgPSByZXF1aXJlKCcuL3J1bGVzLXBhcnNlcicpO1xuaW1wb3J0IHtwYXJzZUV4cHJlc3Npb259IGZyb20gJy4vcGFyc2UtdXRpbCc7XG5cbnZhciBlcnJvcnMgPSB7XG4gIGJhZEluZGV4OiBcIlRoZSBpbmRleCBmdW5jdGlvbiBtdXN0IHJldHVybiBhIFN0cmluZyBvciBhbiBhcnJheSBvZiBTdHJpbmdzLlwiLFxuICBub1BhdGhzOiBcIk11c3QgaGF2ZSBhdCBsZWFzdCBvbmUgcGF0aCBleHByZXNzaW9uLlwiLFxuICBub25PYmplY3Q6IFwiVHlwZSBjb250YWlucyBwcm9wZXJ0aWVzIGFuZCBtdXN0IGV4dGVuZCAnT2JqZWN0Jy5cIixcbiAgbWlzc2luZ1NjaGVtYTogXCJNaXNzaW5nIGRlZmluaXRpb24gZm9yIHR5cGUuXCIsXG4gIHJlY3Vyc2l2ZTogXCJSZWN1cnNpdmUgZnVuY3Rpb24gY2FsbC5cIixcbiAgbWlzbWF0Y2hQYXJhbXM6IFwiSW5jb3JyZWN0IG51bWJlciBvZiBmdW5jdGlvbiBhcmd1bWVudHMuXCIsXG4gIGdlbmVyYXRlRmFpbGVkOiBcIkNvdWxkIG5vdCBnZW5lcmF0ZSBKU09OOiBcIixcbiAgbm9TdWNoVHlwZTogXCJObyB0eXBlIGRlZmluaXRpb24gZm9yOiBcIixcbiAgYmFkU2NoZW1hTWV0aG9kOiBcIlVuc3VwcG9ydGVkIG1ldGhvZCBuYW1lIGluIHR5cGUgc3RhdGVtZW50OiBcIixcbiAgYmFkUGF0aE1ldGhvZDogXCJVbnN1cHBvcnRlZCBtZXRob2QgbmFtZSBpbiBwYXRoIHN0YXRlbWVudDogXCIsXG4gIGJhZFdyaXRlQWxpYXM6IFwiQ2Fubm90IGhhdmUgYm90aCBhIHdyaXRlKCkgbWV0aG9kIGFuZCBhIHdyaXRlLWFsaWFzaW5nIG1ldGhvZDogXCIsXG4gIGNvZXJjaW9uOiBcIkNhbm5vdCBjb252ZXJ0IHZhbHVlOiBcIixcbiAgdW5kZWZpbmVkRnVuY3Rpb246IFwiVW5kZWZpbmVkIGZ1bmN0aW9uOiBcIixcbiAgYXBwbGljYXRpb246IFwiQm9sdCBhcHBsaWNhdGlvbiBlcnJvcjogXCIsXG4gIGludmFsaWRHZW5lcmljOiBcIkludmFsaWQgZ2VuZXJpYyBzY2hlbWEgdXNhZ2U6IFwiLFxuICBpbnZhbGlkTWFwS2V5OiBcIk1hcDxLZXksIFQ+IC0gS2V5IG11c3QgZGVyaXZlIGZyb20gU3RyaW5nIHR5cGUuXCIsXG4gIGludmFsaWRXaWxkQ2hpbGRyZW46IFwiVHlwZXMgY2FuIGhhdmUgYXQgbW9zdCBvbmUgJHdpbGQgcHJvcGVydHkgYW5kIGNhbm5vdCBtaXggd2l0aCBvdGhlciBwcm9wZXJ0aWVzLlwiLFxuICBpbnZhbGlkUHJvcGVydHlOYW1lOiBcIlByb3BlcnR5IG5hbWVzIGNhbm5vdCBjb250YWluIGFueSBvZjogLiAkICMgWyBdIC8gb3IgY29udHJvbCBjaGFyYWN0ZXJzOiBcIixcbn07XG5cbmxldCBJTlZBTElEX0tFWV9SRUdFWCA9IC9bXFxbXFxdLiMkXFwvXFx1MDAwMC1cXHUwMDFGXFx1MDA3Rl0vO1xuXG4vKlxuICAgQSBWYWxpZGF0b3IgaXMgYSBKU09OIGhlcmlhcmNoaWNhbCBzdHJ1Y3R1cmUuIFRoZSBcImxlYXZlc1wiIGFyZSBcImRvdC1wcm9wZXJ0aWVzXCJcbiAgIChzZWUgYmVsb3cpLiBUaGUgaW50ZXJtZWRpYXRlIG5vZGVzIGluIHRoZSB0cmVlIGFyZSBcInByb3BcIiBvciBcIiRwcm9wXCJcbiAgIHByb3BlcnRpZXMuXG5cbiAgIEEgVmFsaWRhdG9yIGlzIG11dGF0ZWQgdG8gaGF2ZSBkaWZmZXJlbnQgZm9ybXMgYmFzZWQgb24gdGhlIHRoZSBwaGFzZSBvZlxuICAgZ2VuZXJhdGlvbi5cblxuICAgSW4gdGhlIGZpcnN0IHBoYXNlLCB0aGV5IGFyZSBFeHBbXS4gTGF0ZXIgdGhlIEV4cFtdIGFyZSBBTkRlZCB0b2dldGhlciBhbmRcbiAgIGNvbWJpbmVkIGludG8gZXhwcmVzc2lvbiB0ZXh0IChhbmQgcmV0dXJuZWQgYXMgdGhlIGZpbmFsIEpTT04tcnVsZXMgdGhhdFxuICAgRmlyZWJhc2UgdXNlcy5cblxuICAgTm90ZTogVFMgZG9lcyBub3QgYWxsb3cgZm9yIHNwZWNpYWwgcHJvcGVydGllcyB0byBoYXZlIGRpc3RpbmN0XG4gICB0eXBlcyBmcm9tIHRoZSAnaW5kZXgnIHByb3BlcnR5IGdpdmVuIGZvciB0aGUgaW50ZXJmYWNlLiAgOi0oXG5cbiAgICcucmVhZCc6IGFzdC5FeHBbXSB8IHN0cmluZztcbiAgICcud3JpdGUnOiBhc3QuRXhwW10gfCBzdHJpbmc7XG4gICAnLnZhbGlkYXRlJzogYXN0LkV4cFtdIHwgc3RyaW5nO1xuICAgJy5pbmRleE9uJzogc3RyaW5nW107XG4gICAnLnNjb3BlJzogeyBbdmFyaWFibGU6IHN0cmluZ106IHN0cmluZyB9XG4qL1xuZXhwb3J0IHR5cGUgVmFsaWRhdG9yVmFsdWUgPSBhc3QuRXhwIHwgYXN0LkV4cFtdIHwgc3RyaW5nIHwgc3RyaW5nW10gfCBWYWxpZGF0b3I7XG5leHBvcnQgaW50ZXJmYWNlIFZhbGlkYXRvciB7XG4gIFtuYW1lOiBzdHJpbmddOiBWYWxpZGF0b3JWYWx1ZTtcbn07XG5cbnZhciBidWlsdGluU2NoZW1hTmFtZXMgPSBbJ0FueScsICdOdWxsJywgJ1N0cmluZycsICdOdW1iZXInLCAnQm9vbGVhbicsICdPYmplY3QnXTtcbi8vIE1ldGhvZCBuYW1lcyBhbGxvd2VkIGluIEJvbHQgZmlsZXMuXG52YXIgdmFsdWVNZXRob2RzID0gWydsZW5ndGgnLCAnaW5jbHVkZXMnLCAnc3RhcnRzV2l0aCcsICdiZWdpbnNXaXRoJywgJ2VuZHNXaXRoJyxcbiAgICAgICAgICAgICAgICAgICAgJ3JlcGxhY2UnLCAndG9Mb3dlckNhc2UnLCAndG9VcHBlckNhc2UnLCAndGVzdCcsICdjb250YWlucycsXG4gICAgICAgICAgICAgICAgICAgICdtYXRjaGVzJ107XG4vLyBUT0RPOiBNYWtlIHN1cmUgdXNlcnMgZG9uJ3QgY2FsbCBpbnRlcm5hbCBtZXRob2RzLi4ubWFrZSBwcml2YXRlIHRvIGltcGwuXG52YXIgc25hcHNob3RNZXRob2RzID0gWydwYXJlbnQnLCAnY2hpbGQnLCAnaGFzQ2hpbGRyZW4nLCAndmFsJywgJ2lzU3RyaW5nJywgJ2lzTnVtYmVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgJ2lzQm9vbGVhbiddLmNvbmNhdCh2YWx1ZU1ldGhvZHMpO1xuXG52YXIgd3JpdGVBbGlhc2VzID0gPHsgW21ldGhvZDogc3RyaW5nXTogYXN0LkV4cCB9PiB7XG4gICdjcmVhdGUnOiBwYXJzZUV4cHJlc3Npb24oJ3ByaW9yKHRoaXMpID09IG51bGwnKSxcbiAgJ3VwZGF0ZSc6IHBhcnNlRXhwcmVzc2lvbigncHJpb3IodGhpcykgIT0gbnVsbCAmJiB0aGlzICE9IG51bGwnKSxcbiAgJ2RlbGV0ZSc6IHBhcnNlRXhwcmVzc2lvbigncHJpb3IodGhpcykgIT0gbnVsbCAmJiB0aGlzID09IG51bGwnKVxufTtcblxuLy8gVXNhZ2U6XG4vLyAgIGpzb24gPSBib2x0LmdlbmVyYXRlKGJvbHQtdGV4dClcbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZShzeW1ib2xzOiBzdHJpbmcgfCBhc3QuU3ltYm9scyk6IFZhbGlkYXRvciB7XG4gIGlmICh0eXBlb2Ygc3ltYm9scyA9PT0gJ3N0cmluZycpIHtcbiAgICBzeW1ib2xzID0gcGFyc2VyLnBhcnNlKHN5bWJvbHMpO1xuICB9XG4gIHZhciBnZW4gPSBuZXcgR2VuZXJhdG9yKDxhc3QuU3ltYm9scz4gc3ltYm9scyk7XG4gIHJldHVybiBnZW4uZ2VuZXJhdGVSdWxlcygpO1xufVxuXG4vLyBTeW1ib2xzIGNvbnRhaW5zOlxuLy8gICBmdW5jdGlvbnM6IHt9XG4vLyAgIHNjaGVtYToge31cbi8vICAgcGF0aHM6IHt9XG5leHBvcnQgY2xhc3MgR2VuZXJhdG9yIHtcbiAgc3ltYm9sczogYXN0LlN5bWJvbHM7XG4gIHZhbGlkYXRvcnM6IHsgW3NjaGVtYU5hbWU6IHN0cmluZ106IFZhbGlkYXRvcjsgfTtcbiAgcnVsZXM6IFZhbGlkYXRvcjtcbiAgZXJyb3JDb3VudDogbnVtYmVyO1xuICBydW5TaWxlbnRseTogYm9vbGVhbjtcbiAgYWxsb3dVbmRlZmluZWRGdW5jdGlvbnM6IGJvb2xlYW47XG4gIGdsb2JhbHM6IGFzdC5QYXJhbXM7XG4gIHRoaXNJczogc3RyaW5nO1xuICBrZXlJbmRleDogbnVtYmVyO1xuXG4gIGNvbnN0cnVjdG9yKHN5bWJvbHM6IGFzdC5TeW1ib2xzKSB7XG4gICAgdGhpcy5zeW1ib2xzID0gc3ltYm9scztcbiAgICB0aGlzLnZhbGlkYXRvcnMgPSB7fTtcbiAgICB0aGlzLnJ1bGVzID0ge307XG4gICAgdGhpcy5lcnJvckNvdW50ID0gMDtcbiAgICB0aGlzLnJ1blNpbGVudGx5ID0gZmFsc2U7XG4gICAgdGhpcy5hbGxvd1VuZGVmaW5lZEZ1bmN0aW9ucyA9IGZhbHNlO1xuICAgIHRoaXMua2V5SW5kZXggPSAwO1xuXG4gICAgLy8gVE9ETzogZ2xvYmFscyBzaG91bGQgYmUgcGFydCBvZiB0aGlzLnN5bWJvbHMgKG5lc3RlZCBzY29wZXMpXG4gICAgdGhpcy5nbG9iYWxzID0ge1xuICAgICAgXCJyb290XCI6IGFzdC5jYWxsKGFzdC52YXJpYWJsZSgnQHJvb3QnKSksXG4gICAgfTtcblxuICAgIHRoaXMucmVnaXN0ZXJCdWlsdGluU2NoZW1hKCk7XG4gIH1cblxuICAvLyBSZXR1cm4gRmlyZWJhc2UgY29tcGF0aWJsZSBSdWxlcyBKU09OIGZvciBhIHRoZSBnaXZlbiBzeW1ib2xzIGRlZmluaXRpb25zLlxuICBnZW5lcmF0ZVJ1bGVzKCk6IFZhbGlkYXRvciB7XG4gICAgdGhpcy5lcnJvckNvdW50ID0gMDtcbiAgICB2YXIgcGF0aHMgPSB0aGlzLnN5bWJvbHMucGF0aHM7XG4gICAgdmFyIHNjaGVtYSA9IHRoaXMuc3ltYm9scy5zY2hlbWE7XG4gICAgdmFyIG5hbWU6IHN0cmluZztcblxuICAgIHBhdGhzLmZvckVhY2goKHBhdGgpID0+IHtcbiAgICAgIHRoaXMudmFsaWRhdGVNZXRob2RzKGVycm9ycy5iYWRQYXRoTWV0aG9kLCBwYXRoLm1ldGhvZHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBbJ3ZhbGlkYXRlJywgJ3JlYWQnLCAnd3JpdGUnLCAnaW5kZXgnXSk7XG4gICAgfSk7XG5cbiAgICBmb3IgKG5hbWUgaW4gc2NoZW1hKSB7XG4gICAgICBpZiAoIXV0aWwuYXJyYXlJbmNsdWRlcyhidWlsdGluU2NoZW1hTmFtZXMsIG5hbWUpKSB7XG4gICAgICAgIHRoaXMudmFsaWRhdGVNZXRob2RzKGVycm9ycy5iYWRTY2hlbWFNZXRob2QsIHNjaGVtYVtuYW1lXS5tZXRob2RzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbJ3ZhbGlkYXRlJywgJ3JlYWQnLCAnd3JpdGUnXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBhdGhzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5mYXRhbChlcnJvcnMubm9QYXRocyk7XG4gICAgfVxuXG4gICAgcGF0aHMuZm9yRWFjaCgocGF0aCkgPT4gdGhpcy51cGRhdGVSdWxlcyhwYXRoKSk7XG4gICAgdGhpcy5jb252ZXJ0RXhwcmVzc2lvbnModGhpcy5ydWxlcyk7XG5cbiAgICBpZiAodGhpcy5lcnJvckNvdW50ICE9PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLmdlbmVyYXRlRmFpbGVkICsgdGhpcy5lcnJvckNvdW50ICsgXCIgZXJyb3JzLlwiKTtcbiAgICB9XG5cbiAgICB1dGlsLmRlbGV0ZVByb3BOYW1lKHRoaXMucnVsZXMsICcuc2NvcGUnKTtcbiAgICB1dGlsLnBydW5lRW1wdHlDaGlsZHJlbih0aGlzLnJ1bGVzKTtcblxuICAgIHJldHVybiB7XG4gICAgICBydWxlczogdGhpcy5ydWxlc1xuICAgIH07XG4gIH1cblxuICB2YWxpZGF0ZU1ldGhvZHMobTogc3RyaW5nLCBtZXRob2RzOiB7IFtuYW1lOiBzdHJpbmddOiBhc3QuTWV0aG9kIH0sIGFsbG93ZWQ6IHN0cmluZ1tdKSB7XG4gICAgaWYgKHV0aWwuYXJyYXlJbmNsdWRlcyhhbGxvd2VkLCAnd3JpdGUnKSkge1xuICAgICAgYWxsb3dlZCA9IGFsbG93ZWQuY29uY2F0KE9iamVjdC5rZXlzKHdyaXRlQWxpYXNlcykpO1xuICAgIH1cbiAgICBmb3IgKHZhciBtZXRob2QgaW4gbWV0aG9kcykge1xuICAgICAgaWYgKCF1dGlsLmFycmF5SW5jbHVkZXMoYWxsb3dlZCwgbWV0aG9kKSkge1xuICAgICAgICB3YXJuKG0gKyB1dGlsLnF1b3RlU3RyaW5nKG1ldGhvZCkgK1xuICAgICAgICAgICAgIFwiIChhbGxvd2VkOiBcIiArIGFsbG93ZWQubWFwKHV0aWwucXVvdGVTdHJpbmcpLmpvaW4oJywgJykgKyBcIilcIik7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICgnd3JpdGUnIGluIG1ldGhvZHMpIHtcbiAgICAgIE9iamVjdC5rZXlzKHdyaXRlQWxpYXNlcykuZm9yRWFjaCgoYWxpYXMpID0+IHtcbiAgICAgICAgaWYgKGFsaWFzIGluIG1ldGhvZHMpIHtcbiAgICAgICAgICB0aGlzLmZhdGFsKGVycm9ycy5iYWRXcml0ZUFsaWFzICsgYWxpYXMpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICByZWdpc3RlckJ1aWx0aW5TY2hlbWEoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciB0aGlzVmFyID0gYXN0LnZhcmlhYmxlKCd0aGlzJyk7XG5cbiAgICBmdW5jdGlvbiByZWdpc3RlckFzQ2FsbChuYW1lOiBzdHJpbmcsIG1ldGhvZE5hbWU6IHN0cmluZyk6IHZvaWQge1xuICAgICAgc2VsZi5zeW1ib2xzLnJlZ2lzdGVyU2NoZW1hKG5hbWUsIGFzdC50eXBlVHlwZSgnQW55JyksIHVuZGVmaW5lZCwge1xuICAgICAgICB2YWxpZGF0ZTogYXN0Lm1ldGhvZChbJ3RoaXMnXSwgYXN0LmNhbGwoYXN0LnJlZmVyZW5jZShhc3QuY2FzdCh0aGlzVmFyLCAnQW55JyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzdC5zdHJpbmcobWV0aG9kTmFtZSkpKSlcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMuc3ltYm9scy5yZWdpc3RlclNjaGVtYSgnQW55JywgYXN0LnR5cGVUeXBlKCdBbnknKSwgdW5kZWZpbmVkLCB7XG4gICAgICB2YWxpZGF0ZTogYXN0Lm1ldGhvZChbJ3RoaXMnXSwgYXN0LmJvb2xlYW4odHJ1ZSkpXG4gICAgfSk7XG5cbiAgICByZWdpc3RlckFzQ2FsbCgnT2JqZWN0JywgJ2hhc0NoaWxkcmVuJyk7XG5cbiAgICAvLyBCZWNhdXNlIG9mIHRoZSB3YXkgZmlyZWJhc2UgdHJlYXRzIE51bGwgdmFsdWVzLCB0aGVyZSBpcyBubyB3YXkgdG9cbiAgICAvLyB3cml0ZSBhIHZhbGlkYXRpb24gcnVsZSwgdGhhdCB3aWxsIEVWRVIgYmUgY2FsbGVkIHdpdGggdGhpcyA9PSBudWxsXG4gICAgLy8gKGZpcmViYXNlIGFsbG93cyB2YWx1ZXMgdG8gYmUgZGVsZXRlZCBubyBtYXR0ZXIgdGhlaXIgdmFsaWRhdGlvbiBydWxlcykuXG4gICAgLy8gU28sIGNvbXBhcmluZyB0aGlzID09IG51bGwgd2lsbCBhbHdheXMgcmV0dXJuIGZhbHNlIC0+IHRoYXQgaXMgd2hhdFxuICAgIC8vIHdlIGRvIGhlcmUsIHdoaWNoIHdpbGwgYmUgb3B0aW1pemVkIGF3YXkgaWYgT1JlZCB3aXRoIG90aGVyIHZhbGlkYXRpb25zLlxuICAgIHRoaXMuc3ltYm9scy5yZWdpc3RlclNjaGVtYSgnTnVsbCcsIGFzdC50eXBlVHlwZSgnQW55JyksIHVuZGVmaW5lZCwge1xuICAgICAgdmFsaWRhdGU6IGFzdC5tZXRob2QoWyd0aGlzJ10sIGFzdC5ib29sZWFuKGZhbHNlKSlcbiAgICB9KTtcblxuICAgIHNlbGYuc3ltYm9scy5yZWdpc3RlclNjaGVtYSgnU3RyaW5nJywgYXN0LnR5cGVUeXBlKCdBbnknKSwgdW5kZWZpbmVkLCB7XG4gICAgICB2YWxpZGF0ZTogYXN0Lm1ldGhvZChbJ3RoaXMnXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzdC5jYWxsKGFzdC5yZWZlcmVuY2UoYXN0LmNhc3QodGhpc1ZhciwgJ0FueScpLCBhc3Quc3RyaW5nKCdpc1N0cmluZycpKSkpLFxuICAgICAgaW5jbHVkZXM6IGFzdC5tZXRob2QoWyd0aGlzJywgJ3MnXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzdC5jYWxsKGFzdC5yZWZlcmVuY2UoYXN0LnZhbHVlKHRoaXNWYXIpLCBhc3Quc3RyaW5nKCdjb250YWlucycpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFsgYXN0LnZhbHVlKGFzdC52YXJpYWJsZSgncycpKSBdKSksXG4gICAgICBzdGFydHNXaXRoOiBhc3QubWV0aG9kKFsndGhpcycsICdzJ10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzdC5jYWxsKGFzdC5yZWZlcmVuY2UoYXN0LnZhbHVlKHRoaXNWYXIpLCBhc3Quc3RyaW5nKCdiZWdpbnNXaXRoJykpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbIGFzdC52YWx1ZShhc3QudmFyaWFibGUoJ3MnKSkgXSkpLFxuICAgICAgZW5kc1dpdGg6IGFzdC5tZXRob2QoWyd0aGlzJywgJ3MnXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzdC5jYWxsKGFzdC5yZWZlcmVuY2UoYXN0LnZhbHVlKHRoaXNWYXIpLCBhc3Quc3RyaW5nKCdlbmRzV2l0aCcpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFsgYXN0LnZhbHVlKGFzdC52YXJpYWJsZSgncycpKSBdKSksXG4gICAgICByZXBsYWNlOiBhc3QubWV0aG9kKFsndGhpcycsICdzJywgJ3InXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYXN0LmNhbGwoYXN0LnJlZmVyZW5jZShhc3QudmFsdWUodGhpc1ZhciksIGFzdC5zdHJpbmcoJ3JlcGxhY2UnKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFsgYXN0LnZhbHVlKGFzdC52YXJpYWJsZSgncycpKSwgYXN0LnZhbHVlKGFzdC52YXJpYWJsZSgncicpKSBdKSksXG4gICAgICB0ZXN0OiBhc3QubWV0aG9kKFsndGhpcycsICdyJ10sXG4gICAgICAgICAgICAgICAgICAgICAgIGFzdC5jYWxsKGFzdC5yZWZlcmVuY2UoYXN0LnZhbHVlKHRoaXNWYXIpLCBhc3Quc3RyaW5nKCdtYXRjaGVzJykpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbIGFzdC5jYWxsKGFzdC52YXJpYWJsZSgnQFJlZ0V4cCcpLCBbYXN0LnZhcmlhYmxlKCdyJyldKSBdKSksXG4gICAgfSk7XG5cbiAgICByZWdpc3RlckFzQ2FsbCgnTnVtYmVyJywgJ2lzTnVtYmVyJyk7XG4gICAgcmVnaXN0ZXJBc0NhbGwoJ0Jvb2xlYW4nLCAnaXNCb29sZWFuJyk7XG5cbiAgICB0aGlzLnN5bWJvbHMucmVnaXN0ZXJGdW5jdGlvbignQFJlZ0V4cCcsIFsnciddLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzdC5idWlsdGluKHRoaXMuZW5zdXJlVHlwZS5iaW5kKHRoaXMsICdSZWdFeHAnKSkpO1xuXG4gICAgbGV0IG1hcCA9IHRoaXMuc3ltYm9scy5yZWdpc3RlclNjaGVtYSgnTWFwJywgYXN0LnR5cGVUeXBlKCdBbnknKSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbJ0tleScsICdWYWx1ZSddKTtcbiAgICBtYXAuZ2V0VmFsaWRhdG9yID0gdGhpcy5nZXRNYXBWYWxpZGF0b3IuYmluZCh0aGlzKTtcbiAgfVxuXG4gIC8vIHR5cGUgTWFwPEtleSwgVmFsdWU+ID0+IHtcbiAgLy8gICAka2V5OiB7XG4gIC8vICAgICAnLnZhbGlkYXRlJzogJGtleSBpbnN0YW5jZW9mIEtleSBhbmQgdGhpcyBpbnN0YW5jZW9mIFZhbHVlO1xuICAvLyAgICcudmFsaWRhdGUnOiAnbmV3RGF0YS5oYXNDaGlsZHJlbigpJ1xuICAvLyB9XG4gIC8vIEtleSBtdXN0IGRlcml2ZSBmcm9tIFN0cmluZ1xuICBnZXRNYXBWYWxpZGF0b3IocGFyYW1zOiBhc3QuRXhwW10pOiBWYWxpZGF0b3Ige1xuICAgIGxldCBrZXlUeXBlID0gPGFzdC5FeHBTaW1wbGVUeXBlPiBwYXJhbXNbMF07XG4gICAgbGV0IHZhbHVlVHlwZSA9IDxhc3QuRXhwVHlwZT4gcGFyYW1zWzFdO1xuICAgIGlmIChrZXlUeXBlLnR5cGUgIT09ICd0eXBlJyB8fCAhdGhpcy5zeW1ib2xzLmlzRGVyaXZlZEZyb20oa2V5VHlwZSwgJ1N0cmluZycpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLmludmFsaWRNYXBLZXkgKyBcIiAgKFwiICsgYXN0LmRlY29kZUV4cHJlc3Npb24oa2V5VHlwZSkgKyBcIiBkb2VzIG5vdClcIik7XG4gICAgfVxuXG4gICAgbGV0IHZhbGlkYXRvciA9IDxWYWxpZGF0b3I+IHt9O1xuICAgIGxldCBpbmRleCA9IHRoaXMudW5pcXVlS2V5KCk7XG4gICAgdmFsaWRhdG9yW2luZGV4XSA9IDxWYWxpZGF0b3I+IHt9O1xuICAgIGV4dGVuZFZhbGlkYXRvcih2YWxpZGF0b3IsIHRoaXMuZW5zdXJlVmFsaWRhdG9yKGFzdC50eXBlVHlwZSgnT2JqZWN0JykpKTtcblxuICAgIC8vIEZpcnN0IHZhbGlkYXRlIHRoZSBrZXkgKG9taXQgdGVybWluYWwgU3RyaW5nIHR5cGUgdmFsaWRhdGlvbikuXG4gICAgd2hpbGUgKGtleVR5cGUubmFtZSAhPT0gJ1N0cmluZycpIHtcbiAgICAgIGxldCBzY2hlbWEgPSB0aGlzLnN5bWJvbHMuc2NoZW1hW2tleVR5cGUubmFtZV07XG4gICAgICBpZiAoc2NoZW1hLm1ldGhvZHNbJ3ZhbGlkYXRlJ10pIHtcbiAgICAgICAgbGV0IGV4cCA9IHRoaXMucGFydGlhbEV2YWwoc2NoZW1hLm1ldGhvZHNbJ3ZhbGlkYXRlJ10uYm9keSwgeyd0aGlzJzogYXN0LmxpdGVyYWwoaW5kZXgpfSk7XG4gICAgICAgIGV4dGVuZFZhbGlkYXRvcig8VmFsaWRhdG9yPiB2YWxpZGF0b3JbaW5kZXhdLCA8VmFsaWRhdG9yPiB7Jy52YWxpZGF0ZSc6IFtleHBdfSk7XG4gICAgICB9XG4gICAgICBrZXlUeXBlID0gPGFzdC5FeHBTaW1wbGVUeXBlPiBzY2hlbWEuZGVyaXZlZEZyb207XG4gICAgfVxuXG4gICAgZXh0ZW5kVmFsaWRhdG9yKDxWYWxpZGF0b3I+IHZhbGlkYXRvcltpbmRleF0sIHRoaXMuZW5zdXJlVmFsaWRhdG9yKHZhbHVlVHlwZSkpO1xuICAgIHJldHVybiB2YWxpZGF0b3I7XG4gIH1cblxuICB1bmlxdWVLZXkoKTogc3RyaW5nIHtcbiAgICB0aGlzLmtleUluZGV4ICs9IDE7XG4gICAgcmV0dXJuICcka2V5JyArIHRoaXMua2V5SW5kZXg7XG4gIH1cblxuICAvLyBDb2xsZWN0aW9uIHNjaGVtYSBoYXMgZXhhY3RseSBvbmUgJHdpbGRjaGlsZCBwcm9wZXJ0eVxuICBpc0NvbGxlY3Rpb25TY2hlbWEoc2NoZW1hOiBhc3QuU2NoZW1hKTogYm9vbGVhbiB7XG4gICAgbGV0IHByb3BzID0gT2JqZWN0LmtleXMoc2NoZW1hLnByb3BlcnRpZXMpO1xuICAgIGxldCByZXN1bHQgPSBwcm9wcy5sZW5ndGggPT09IDEgJiYgcHJvcHNbMF1bMF0gPT09ICckJztcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gRW5zdXJlIHdlIGhhdmUgYSBkZWZpbml0aW9uIGZvciBhIHZhbGlkYXRvciBmb3IgdGhlIGdpdmVuIHNjaGVtYS5cbiAgZW5zdXJlVmFsaWRhdG9yKHR5cGU6IGFzdC5FeHBUeXBlKTogVmFsaWRhdG9yIHtcbiAgICB2YXIga2V5ID0gYXN0LmRlY29kZUV4cHJlc3Npb24odHlwZSk7XG4gICAgaWYgKCF0aGlzLnZhbGlkYXRvcnNba2V5XSkge1xuICAgICAgdGhpcy52YWxpZGF0b3JzW2tleV0gPSB7Jy52YWxpZGF0ZSc6IGFzdC5saXRlcmFsKCcqKipUWVBFIFJFQ1VSU0lPTioqKicpIH07XG5cbiAgICAgIGxldCBhbGxvd1NhdmUgPSB0aGlzLmFsbG93VW5kZWZpbmVkRnVuY3Rpb25zO1xuICAgICAgdGhpcy5hbGxvd1VuZGVmaW5lZEZ1bmN0aW9ucyA9IHRydWU7XG4gICAgICB0aGlzLnZhbGlkYXRvcnNba2V5XSA9IHRoaXMuY3JlYXRlVmFsaWRhdG9yKHR5cGUpO1xuICAgICAgdGhpcy5hbGxvd1VuZGVmaW5lZEZ1bmN0aW9ucyA9IGFsbG93U2F2ZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudmFsaWRhdG9yc1trZXldO1xuICB9XG5cbiAgY3JlYXRlVmFsaWRhdG9yKHR5cGU6IGFzdC5FeHBUeXBlKTogVmFsaWRhdG9yIHtcbiAgICBzd2l0Y2ggKHR5cGUudHlwZSkge1xuICAgIGNhc2UgJ3R5cGUnOlxuICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlVmFsaWRhdG9yRnJvbVNjaGVtYU5hbWUoKDxhc3QuRXhwU2ltcGxlVHlwZT4gdHlwZSkubmFtZSk7XG5cbiAgICBjYXNlICd1bmlvbic6XG4gICAgICBsZXQgdW5pb24gPSA8VmFsaWRhdG9yPiB7fTtcbiAgICAgICg8YXN0LkV4cFVuaW9uVHlwZT4gdHlwZSkudHlwZXMuZm9yRWFjaCgodHlwZVBhcnQ6IGFzdC5FeHBUeXBlKSA9PiB7XG4gICAgICAgIC8vIE1ha2UgYSBjb3B5XG4gICAgICAgIHZhciBzaW5nbGVUeXBlID0gZXh0ZW5kVmFsaWRhdG9yKHt9LCB0aGlzLmVuc3VyZVZhbGlkYXRvcih0eXBlUGFydCkpO1xuICAgICAgICBtYXBWYWxpZGF0b3Ioc2luZ2xlVHlwZSwgYXN0LmFuZEFycmF5KTtcbiAgICAgICAgZXh0ZW5kVmFsaWRhdG9yKHVuaW9uLCBzaW5nbGVUeXBlKTtcbiAgICAgIH0pO1xuICAgICAgbWFwVmFsaWRhdG9yKHVuaW9uLCBhc3Qub3JBcnJheSk7XG4gICAgICByZXR1cm4gdW5pb247XG5cbiAgICBjYXNlICdnZW5lcmljJzpcbiAgICAgIGxldCBnZW5lcmljVHlwZSA9IDxhc3QuRXhwR2VuZXJpY1R5cGU+IHR5cGU7XG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGVWYWxpZGF0b3JGcm9tR2VuZXJpYyhnZW5lcmljVHlwZS5uYW1lLCBnZW5lcmljVHlwZS5wYXJhbXMpO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMuYXBwbGljYXRpb24gKyBcImludmFsaWQgaW50ZXJuYWwgdHlwZTogXCIgKyB0eXBlLnR5cGUpO1xuICAgIH1cbiAgfVxuXG4gIGNyZWF0ZVZhbGlkYXRvckZyb21HZW5lcmljKHNjaGVtYU5hbWU6IHN0cmluZywgcGFyYW1zOiBhc3QuRXhwVHlwZVtdKTogVmFsaWRhdG9yIHtcbiAgICB2YXIgc2NoZW1hID0gdGhpcy5zeW1ib2xzLnNjaGVtYVtzY2hlbWFOYW1lXTtcblxuICAgIGlmIChzY2hlbWEgPT09IHVuZGVmaW5lZCB8fCAhYXN0LlNjaGVtYS5pc0dlbmVyaWMoc2NoZW1hKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9ycy5ub1N1Y2hUeXBlICsgc2NoZW1hTmFtZSArIFwiIChnZW5lcmljKVwiKTtcbiAgICB9XG5cbiAgICBsZXQgc2NoZW1hUGFyYW1zID0gPHN0cmluZ1tdPiBzY2hlbWEucGFyYW1zO1xuXG4gICAgaWYgKHBhcmFtcy5sZW5ndGggIT09IHNjaGVtYVBhcmFtcy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMuaW52YWxpZEdlbmVyaWMgKyBcIiBleHBlY3RlZCA8XCIgKyBzY2hlbWFQYXJhbXMuam9pbignLCAnKSArIFwiPlwiKTtcbiAgICB9XG5cbiAgICAvLyBDYWxsIGN1c3RvbSB2YWxpZGF0b3IsIGlmIGdpdmVuLlxuICAgIGlmIChzY2hlbWEuZ2V0VmFsaWRhdG9yKSB7XG4gICAgICByZXR1cm4gc2NoZW1hLmdldFZhbGlkYXRvcihwYXJhbXMpO1xuICAgIH1cblxuICAgIGxldCBiaW5kaW5ncyA9IDxhc3QuVHlwZVBhcmFtcz4ge307XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJhbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGJpbmRpbmdzW3NjaGVtYVBhcmFtc1tpXV0gPSBwYXJhbXNbaV07XG4gICAgfVxuXG4gICAgLy8gRXhwYW5kIGdlbmVyaWNzIGFuZCBnZW5lcmF0ZSB2YWxpZGF0b3IgZnJvbSBzY2hlbWEuXG4gICAgc2NoZW1hID0gdGhpcy5yZXBsYWNlR2VuZXJpY3NJblNjaGVtYShzY2hlbWEsIGJpbmRpbmdzKTtcbiAgICByZXR1cm4gdGhpcy5jcmVhdGVWYWxpZGF0b3JGcm9tU2NoZW1hKHNjaGVtYSk7XG4gIH1cblxuICByZXBsYWNlR2VuZXJpY3NJblNjaGVtYShzY2hlbWE6IGFzdC5TY2hlbWEsIGJpbmRpbmdzOiBhc3QuVHlwZVBhcmFtcyk6IGFzdC5TY2hlbWEge1xuICAgIHZhciBleHBhbmRlZFNjaGVtYSA9IDxhc3QuU2NoZW1hPiB7XG4gICAgICBkZXJpdmVkRnJvbTogPGFzdC5FeHBUeXBlPiB0aGlzLnJlcGxhY2VHZW5lcmljc0luRXhwKHNjaGVtYS5kZXJpdmVkRnJvbSwgYmluZGluZ3MpLFxuICAgICAgcHJvcGVydGllczogeyB9LFxuICAgICAgbWV0aG9kczoge30sXG4gICAgfTtcbiAgICBsZXQgcHJvcHMgPSBPYmplY3Qua2V5cyhzY2hlbWEucHJvcGVydGllcyk7XG4gICAgcHJvcHMuZm9yRWFjaCgocHJvcCkgPT4ge1xuICAgICAgZXhwYW5kZWRTY2hlbWEucHJvcGVydGllc1twcm9wXSA9XG4gICAgICAgIDxhc3QuRXhwVHlwZT4gdGhpcy5yZXBsYWNlR2VuZXJpY3NJbkV4cChzY2hlbWEucHJvcGVydGllc1twcm9wXSwgYmluZGluZ3MpO1xuICAgIH0pO1xuXG4gICAgbGV0IG1ldGhvZHMgPSBPYmplY3Qua2V5cyhzY2hlbWEubWV0aG9kcyk7XG4gICAgbWV0aG9kcy5mb3JFYWNoKChtZXRob2ROYW1lKSA9PiB7XG4gICAgICBleHBhbmRlZFNjaGVtYS5tZXRob2RzW21ldGhvZE5hbWVdID0gdGhpcy5yZXBsYWNlR2VuZXJpY3NJbk1ldGhvZChzY2hlbWEubWV0aG9kc1ttZXRob2ROYW1lXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmluZGluZ3MpO1xuICAgIH0pO1xuICAgIHJldHVybiBleHBhbmRlZFNjaGVtYTtcbiAgfVxuXG4gIHJlcGxhY2VHZW5lcmljc0luRXhwKGV4cDogYXN0LkV4cCwgYmluZGluZ3M6IGFzdC5UeXBlUGFyYW1zKTogYXN0LkV4cCB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgZnVuY3Rpb24gcmVwbGFjZUdlbmVyaWNzSW5BcnJheShleHBzOiBhc3QuRXhwW10pOiBhc3QuRXhwW10ge1xuICAgICAgcmV0dXJuIGV4cHMubWFwKGZ1bmN0aW9uKGV4cFBhcnQpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYucmVwbGFjZUdlbmVyaWNzSW5FeHAoZXhwUGFydCwgYmluZGluZ3MpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgc3dpdGNoIChleHAudHlwZSkge1xuICAgIGNhc2UgJ29wJzpcbiAgICBjYXNlICdjYWxsJzpcbiAgICAgIGxldCBvcFR5cGUgPSA8YXN0LkV4cE9wPiBhc3QuY29weUV4cChleHApO1xuICAgICAgb3BUeXBlLmFyZ3MgPSByZXBsYWNlR2VuZXJpY3NJbkFycmF5KG9wVHlwZS5hcmdzKTtcbiAgICAgIHJldHVybiBvcFR5cGU7XG5cbiAgICBjYXNlICd0eXBlJzpcbiAgICAgIGxldCBzaW1wbGVUeXBlID0gPGFzdC5FeHBTaW1wbGVUeXBlPiBleHA7XG4gICAgICByZXR1cm4gYmluZGluZ3Nbc2ltcGxlVHlwZS5uYW1lXSB8fCBzaW1wbGVUeXBlO1xuXG4gICAgY2FzZSAndW5pb24nOlxuICAgICAgbGV0IHVuaW9uVHlwZSA9IDxhc3QuRXhwVW5pb25UeXBlPiBleHA7XG4gICAgICByZXR1cm4gYXN0LnVuaW9uVHlwZSg8YXN0LkV4cFR5cGVbXT4gcmVwbGFjZUdlbmVyaWNzSW5BcnJheSh1bmlvblR5cGUudHlwZXMpKTtcblxuICAgIGNhc2UgJ2dlbmVyaWMnOlxuICAgICAgbGV0IGdlbmVyaWNUeXBlID0gPGFzdC5FeHBHZW5lcmljVHlwZT4gZXhwO1xuICAgICAgcmV0dXJuIGFzdC5nZW5lcmljVHlwZShnZW5lcmljVHlwZS5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YXN0LkV4cFR5cGVbXT4gcmVwbGFjZUdlbmVyaWNzSW5BcnJheShnZW5lcmljVHlwZS5wYXJhbXMpKTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZXhwO1xuICAgIH1cbiAgfVxuXG4gIHJlcGxhY2VHZW5lcmljc0luTWV0aG9kKG1ldGhvZDogYXN0Lk1ldGhvZCwgYmluZGluZ3M6IGFzdC5UeXBlUGFyYW1zKTogYXN0Lk1ldGhvZCB7XG4gICAgdmFyIGV4cGFuZGVkTWV0aG9kID0gPGFzdC5NZXRob2Q+IHtcbiAgICAgIHBhcmFtczogbWV0aG9kLnBhcmFtcyxcbiAgICAgIGJvZHk6IG1ldGhvZC5ib2R5XG4gICAgfTtcblxuICAgIGV4cGFuZGVkTWV0aG9kLmJvZHkgPSB0aGlzLnJlcGxhY2VHZW5lcmljc0luRXhwKG1ldGhvZC5ib2R5LCBiaW5kaW5ncyk7XG4gICAgcmV0dXJuIGV4cGFuZGVkTWV0aG9kO1xuICB9XG5cbiAgY3JlYXRlVmFsaWRhdG9yRnJvbVNjaGVtYU5hbWUoc2NoZW1hTmFtZTogc3RyaW5nKTogVmFsaWRhdG9yIHtcbiAgICB2YXIgc2NoZW1hID0gdGhpcy5zeW1ib2xzLnNjaGVtYVtzY2hlbWFOYW1lXTtcblxuICAgIGlmICghc2NoZW1hKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLm5vU3VjaFR5cGUgKyBzY2hlbWFOYW1lKTtcbiAgICB9XG5cbiAgICBpZiAoYXN0LlNjaGVtYS5pc0dlbmVyaWMoc2NoZW1hKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9ycy5ub1N1Y2hUeXBlICsgc2NoZW1hTmFtZSArIFwiIHVzZWQgYXMgbm9uLWdlbmVyaWMgdHlwZS5cIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuY3JlYXRlVmFsaWRhdG9yRnJvbVNjaGVtYShzY2hlbWEpO1xuICB9XG5cbiAgY3JlYXRlVmFsaWRhdG9yRnJvbVNjaGVtYShzY2hlbWE6IGFzdC5TY2hlbWEpOiBWYWxpZGF0b3Ige1xuICAgIHZhciBoYXNQcm9wcyA9IE9iamVjdC5rZXlzKHNjaGVtYS5wcm9wZXJ0aWVzKS5sZW5ndGggPiAwICYmXG4gICAgICAhdGhpcy5pc0NvbGxlY3Rpb25TY2hlbWEoc2NoZW1hKTtcblxuICAgIGlmIChoYXNQcm9wcyAmJiAhdGhpcy5zeW1ib2xzLmlzRGVyaXZlZEZyb20oc2NoZW1hLmRlcml2ZWRGcm9tLCAnT2JqZWN0JykpIHtcbiAgICAgIHRoaXMuZmF0YWwoZXJyb3JzLm5vbk9iamVjdCArIFwiIChpcyBcIiArIGFzdC5kZWNvZGVFeHByZXNzaW9uKHNjaGVtYS5kZXJpdmVkRnJvbSkgKyBcIilcIik7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuXG4gICAgbGV0IHZhbGlkYXRvciA9IDxWYWxpZGF0b3I+IHt9O1xuXG4gICAgaWYgKCEoc2NoZW1hLmRlcml2ZWRGcm9tLnR5cGUgPT09ICd0eXBlJyAmJlxuICAgICAgICAgICg8YXN0LkV4cFNpbXBsZVR5cGU+IHNjaGVtYS5kZXJpdmVkRnJvbSkubmFtZSA9PT0gJ0FueScpKSB7XG4gICAgICBleHRlbmRWYWxpZGF0b3IodmFsaWRhdG9yLCB0aGlzLmVuc3VyZVZhbGlkYXRvcihzY2hlbWEuZGVyaXZlZEZyb20pKTtcbiAgICB9XG5cbiAgICBsZXQgcmVxdWlyZWRQcm9wZXJ0aWVzID0gPHN0cmluZ1tdPiBbXTtcbiAgICBsZXQgd2lsZFByb3BlcnRpZXMgPSAwO1xuICAgIE9iamVjdC5rZXlzKHNjaGVtYS5wcm9wZXJ0aWVzKS5mb3JFYWNoKChwcm9wTmFtZSkgPT4ge1xuICAgICAgaWYgKHByb3BOYW1lWzBdID09PSAnJCcpIHtcbiAgICAgICAgd2lsZFByb3BlcnRpZXMgKz0gMTtcbiAgICAgICAgaWYgKElOVkFMSURfS0VZX1JFR0VYLnRlc3QocHJvcE5hbWUuc2xpY2UoMSkpKSB7XG4gICAgICAgICAgdGhpcy5mYXRhbChlcnJvcnMuaW52YWxpZFByb3BlcnR5TmFtZSArIHByb3BOYW1lKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKElOVkFMSURfS0VZX1JFR0VYLnRlc3QocHJvcE5hbWUpKSB7XG4gICAgICAgICAgdGhpcy5mYXRhbChlcnJvcnMuaW52YWxpZFByb3BlcnR5TmFtZSArIHByb3BOYW1lKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCF2YWxpZGF0b3JbcHJvcE5hbWVdKSB7XG4gICAgICAgIHZhbGlkYXRvcltwcm9wTmFtZV0gPSB7fTtcbiAgICAgIH1cbiAgICAgIHZhciBwcm9wVHlwZSA9IHNjaGVtYS5wcm9wZXJ0aWVzW3Byb3BOYW1lXTtcbiAgICAgIGlmIChwcm9wTmFtZVswXSAhPT0gJyQnICYmICF0aGlzLmlzTnVsbGFibGVUeXBlKHByb3BUeXBlKSkge1xuICAgICAgICByZXF1aXJlZFByb3BlcnRpZXMucHVzaChwcm9wTmFtZSk7XG4gICAgICB9XG4gICAgICBleHRlbmRWYWxpZGF0b3IoPFZhbGlkYXRvcj4gdmFsaWRhdG9yW3Byb3BOYW1lXSwgdGhpcy5lbnN1cmVWYWxpZGF0b3IocHJvcFR5cGUpKTtcbiAgICB9KTtcblxuICAgIGlmICh3aWxkUHJvcGVydGllcyA+IDEgfHwgd2lsZFByb3BlcnRpZXMgPT09IDEgJiYgcmVxdWlyZWRQcm9wZXJ0aWVzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuZmF0YWwoZXJyb3JzLmludmFsaWRXaWxkQ2hpbGRyZW4pO1xuICAgIH1cblxuICAgIGlmIChyZXF1aXJlZFByb3BlcnRpZXMubGVuZ3RoID4gMCkge1xuICAgICAgLy8gdGhpcy5oYXNDaGlsZHJlbihyZXF1aXJlZFByb3BlcnRpZXMpXG4gICAgICBleHRlbmRWYWxpZGF0b3IodmFsaWRhdG9yLFxuICAgICAgICAgICAgICAgICAgICAgIHsnLnZhbGlkYXRlJzogW2hhc0NoaWxkcmVuRXhwKHJlcXVpcmVkUHJvcGVydGllcyldfSk7XG4gICAgfVxuXG4gICAgLy8gRGlzYWxsb3cgJG90aGVyIHByb3BlcnRpZXMgYnkgZGVmYXVsdFxuICAgIGlmIChoYXNQcm9wcykge1xuICAgICAgdmFsaWRhdG9yWyckb3RoZXInXSA9IHt9O1xuICAgICAgZXh0ZW5kVmFsaWRhdG9yKDxWYWxpZGF0b3I+IHZhbGlkYXRvclsnJG90aGVyJ10sXG4gICAgICAgICAgICAgICAgICAgICAgPFZhbGlkYXRvcj4geycudmFsaWRhdGUnOiBhc3QuYm9vbGVhbihmYWxzZSl9KTtcbiAgICB9XG5cbiAgICB0aGlzLmV4dGVuZFZhbGlkYXRpb25NZXRob2RzKHZhbGlkYXRvciwgc2NoZW1hLm1ldGhvZHMpO1xuXG4gICAgcmV0dXJuIHZhbGlkYXRvcjtcbiAgfVxuXG4gIGlzTnVsbGFibGVUeXBlKHR5cGU6IGFzdC5FeHBUeXBlKTogYm9vbGVhbiB7XG4gICAgbGV0IHJlc3VsdCA9IHRoaXMuc3ltYm9scy5pc0Rlcml2ZWRGcm9tKHR5cGUsICdOdWxsJykgfHxcbiAgICAgIHRoaXMuc3ltYm9scy5pc0Rlcml2ZWRGcm9tKHR5cGUsICdNYXAnKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gVXBkYXRlIHJ1bGVzIGJhc2VkIG9uIHRoZSBnaXZlbiBwYXRoIGV4cHJlc3Npb24uXG4gIHVwZGF0ZVJ1bGVzKHBhdGg6IGFzdC5QYXRoKSB7XG4gICAgdmFyIGk6IG51bWJlcjtcbiAgICB2YXIgbG9jYXRpb24gPSA8VmFsaWRhdG9yPiB1dGlsLmVuc3VyZU9iamVjdFBhdGgodGhpcy5ydWxlcywgcGF0aC50ZW1wbGF0ZS5nZXRMYWJlbHMoKSk7XG4gICAgdmFyIGV4cDogYXN0LkV4cFZhbHVlO1xuXG4gICAgZXh0ZW5kVmFsaWRhdG9yKGxvY2F0aW9uLCB0aGlzLmVuc3VyZVZhbGlkYXRvcihwYXRoLmlzVHlwZSkpO1xuICAgIGxvY2F0aW9uWycuc2NvcGUnXSA9IHBhdGgudGVtcGxhdGUuZ2V0U2NvcGUoKTtcblxuICAgIHRoaXMuZXh0ZW5kVmFsaWRhdGlvbk1ldGhvZHMobG9jYXRpb24sIHBhdGgubWV0aG9kcyk7XG5cbiAgICAvLyBXcml0ZSBpbmRpY2VzXG4gICAgaWYgKHBhdGgubWV0aG9kc1snaW5kZXgnXSkge1xuICAgICAgc3dpdGNoIChwYXRoLm1ldGhvZHNbJ2luZGV4J10uYm9keS50eXBlKSB7XG4gICAgICBjYXNlICdTdHJpbmcnOlxuICAgICAgICBleHAgPSBhc3QuYXJyYXkoW3BhdGgubWV0aG9kc1snaW5kZXgnXS5ib2R5XSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnQXJyYXknOlxuICAgICAgICBleHAgPSA8YXN0LkV4cFZhbHVlPiBwYXRoLm1ldGhvZHNbJ2luZGV4J10uYm9keTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aGlzLmZhdGFsKGVycm9ycy5iYWRJbmRleCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRpY2VzID0gPHN0cmluZ1tdPiBbXTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBleHAudmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGV4cC52YWx1ZVtpXS50eXBlICE9PSAnU3RyaW5nJykge1xuICAgICAgICAgIHRoaXMuZmF0YWwoZXJyb3JzLmJhZEluZGV4ICsgXCIgKG5vdCBcIiArIGV4cC52YWx1ZVtpXS50eXBlICsgXCIpXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGluZGljZXMucHVzaChleHAudmFsdWVbaV0udmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBUT0RPOiBFcnJvciBjaGVjayBub3Qgb3Zlci13cml0aW5nIGluZGV4IHJ1bGVzLlxuICAgICAgbG9jYXRpb25bJy5pbmRleE9uJ10gPSBpbmRpY2VzO1xuICAgIH1cbiAgfVxuXG4gIGV4dGVuZFZhbGlkYXRpb25NZXRob2RzKHZhbGlkYXRvcjogVmFsaWRhdG9yLCBtZXRob2RzOiB7IFttZXRob2Q6IHN0cmluZ106IGFzdC5NZXRob2QgfSkge1xuICAgIGxldCB3cml0ZU1ldGhvZHMgPSA8YXN0LkV4cFtdPiBbXTtcbiAgICBbJ2NyZWF0ZScsICd1cGRhdGUnLCAnZGVsZXRlJ10uZm9yRWFjaCgobWV0aG9kKSA9PiB7XG4gICAgICBpZiAobWV0aG9kIGluIG1ldGhvZHMpIHtcbiAgICAgICAgd3JpdGVNZXRob2RzLnB1c2goYXN0LmFuZEFycmF5KFt3cml0ZUFsaWFzZXNbbWV0aG9kXSwgbWV0aG9kc1ttZXRob2RdLmJvZHldKSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHdyaXRlTWV0aG9kcy5sZW5ndGggIT09IDApIHtcbiAgICAgIGV4dGVuZFZhbGlkYXRvcih2YWxpZGF0b3IsIDxWYWxpZGF0b3I+IHsgJy53cml0ZSc6IGFzdC5vckFycmF5KHdyaXRlTWV0aG9kcykgfSk7XG4gICAgfVxuXG4gICAgWyd2YWxpZGF0ZScsICdyZWFkJywgJ3dyaXRlJ10uZm9yRWFjaCgobWV0aG9kKSA9PiB7XG4gICAgICBpZiAobWV0aG9kIGluIG1ldGhvZHMpIHtcbiAgICAgICAgdmFyIG1ldGhvZFZhbGlkYXRvciA9IDxWYWxpZGF0b3I+IHt9O1xuICAgICAgICBtZXRob2RWYWxpZGF0b3JbJy4nICsgbWV0aG9kXSA9IG1ldGhvZHNbbWV0aG9kXS5ib2R5O1xuICAgICAgICBleHRlbmRWYWxpZGF0b3IodmFsaWRhdG9yLCBtZXRob2RWYWxpZGF0b3IpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLy8gUmV0dXJuIHVuaW9uIHZhbGlkYXRvciAofHwpIG92ZXIgZWFjaCBzY2hlbWFcbiAgdW5pb25WYWxpZGF0b3JzKHNjaGVtYTogc3RyaW5nW10pOiBWYWxpZGF0b3Ige1xuICAgIHZhciB1bmlvbiA9IDxWYWxpZGF0b3I+IHt9O1xuICAgIHNjaGVtYS5mb3JFYWNoKGZ1bmN0aW9uKHR5cGVOYW1lOiBzdHJpbmcpIHtcbiAgICAgIC8vIEZpcnN0IGFuZCB0aGUgdmFsaWRhdG9yIHRlcm1zIGZvciBhIHNpbmdsZSB0eXBlXG4gICAgICAvLyBUb2RvIGV4dGVuZCB0byB1bmlvbnMgYW5kIGdlbmVyaWNzXG4gICAgICB2YXIgc2luZ2xlVHlwZSA9IGV4dGVuZFZhbGlkYXRvcih7fSwgdGhpcy5lbnN1cmVWYWxpZGF0b3IodHlwZU5hbWUpKTtcbiAgICAgIG1hcFZhbGlkYXRvcihzaW5nbGVUeXBlLCBhc3QuYW5kQXJyYXkpO1xuICAgICAgZXh0ZW5kVmFsaWRhdG9yKHVuaW9uLCBzaW5nbGVUeXBlKTtcbiAgICB9LmJpbmQodGhpcykpO1xuICAgIG1hcFZhbGlkYXRvcih1bmlvbiwgYXN0Lm9yQXJyYXkpO1xuICAgIHJldHVybiB1bmlvbjtcbiAgfVxuXG4gIC8vIENvbnZlcnQgZXhwcmVzc2lvbnMgdG8gdGV4dCwgYW5kIGF0IHRoZSBzYW1lIHRpbWUsIGFwcGx5IHBydW5pbmcgb3BlcmF0aW9uc1xuICAvLyB0byByZW1vdmUgbm8tb3AgcnVsZXMuXG4gIGNvbnZlcnRFeHByZXNzaW9ucyh2YWxpZGF0b3I6IFZhbGlkYXRvcikge1xuICAgIHZhciBtZXRob2RUaGlzSXMgPSA8e1twcm9wOiBzdHJpbmddOiBzdHJpbmd9PiB7ICcudmFsaWRhdGUnOiAnbmV3RGF0YScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJy5yZWFkJzogJ2RhdGEnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcud3JpdGUnOiAnbmV3RGF0YScgfTtcblxuICAgIGZ1bmN0aW9uIGhhc1dpbGRjYXJkU2libGluZyhwYXRoOiBhc3QuUGF0aFRlbXBsYXRlKTogYm9vbGVhbiB7XG4gICAgICBsZXQgcGFydHMgPSBwYXRoLmdldExhYmVscygpO1xuICAgICAgbGV0IGNoaWxkUGFydCA9IHBhcnRzLnBvcCgpO1xuICAgICAgbGV0IHBhcmVudCA9IHV0aWwuZGVlcExvb2t1cCh2YWxpZGF0b3IsIHBhcnRzKTtcbiAgICAgIGlmIChwYXJlbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBwcm9wIG9mIE9iamVjdC5rZXlzKHBhcmVudCkpIHtcbiAgICAgICAgaWYgKHByb3AgPT09IGNoaWxkUGFydCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9wWzBdID09PSAnJCcpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIG1hcFZhbGlkYXRvcih2YWxpZGF0b3IsICh2YWx1ZTogYXN0LkV4cFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wOiBzdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlOiBhc3QuUGFyYW1zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiBhc3QuUGF0aFRlbXBsYXRlKSA9PiB7XG4gICAgICBpZiAocHJvcCBpbiBtZXRob2RUaGlzSXMpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMuZ2V0RXhwcmVzc2lvblRleHQoYXN0LmFuZEFycmF5KGNvbGxhcHNlSGFzQ2hpbGRyZW4odmFsdWUpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kVGhpc0lzW3Byb3BdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29wZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aCk7XG4gICAgICAgIC8vIFJlbW92ZSBuby1vcCAucmVhZCBvciAud3JpdGUgcnVsZSBpZiBubyBzaWJsaW5nIHdpbGRjYXJkIHByb3BzLlxuICAgICAgICBpZiAoKHByb3AgPT09ICcucmVhZCcgfHwgcHJvcCA9PT0gJy53cml0ZScpICYmIHJlc3VsdCA9PT0gJ2ZhbHNlJykge1xuICAgICAgICAgIGlmICghaGFzV2lsZGNhcmRTaWJsaW5nKHBhdGgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlbW92ZSBuby1vcCAudmFsaWRhdGUgcnVsZSBpZiBubyBzaWJsaW5nIHdpbGRjYXJkIHByb3BzLlxuICAgICAgICBpZiAocHJvcCA9PT0gJy52YWxpZGF0ZScgJiYgcmVzdWx0ID09PSAndHJ1ZScpIHtcbiAgICAgICAgICBpZiAoIWhhc1dpbGRjYXJkU2libGluZyhwYXRoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0pO1xuICB9XG5cbiAgZ2V0RXhwcmVzc2lvblRleHQoZXhwOiBhc3QuRXhwLCB0aGlzSXM6IHN0cmluZywgc2NvcGU6IGFzdC5QYXJhbXMsIHBhdGg6IGFzdC5QYXRoVGVtcGxhdGUpOiBzdHJpbmcge1xuICAgIGlmICghKCd0eXBlJyBpbiBleHApKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLmFwcGxpY2F0aW9uICsgXCJOb3QgYW4gZXhwcmVzc2lvbjogXCIgKyB1dGlsLnByZXR0eUpTT04oZXhwKSk7XG4gICAgfVxuICAgIC8vIEZpcnN0IGV2YWx1YXRlIHcvbyBiaW5kaW5nIG9mIHRoaXMgdG8gc3BlY2lmaWMgbG9jYXRpb24uXG4gICAgdGhpcy5hbGxvd1VuZGVmaW5lZEZ1bmN0aW9ucyA9IHRydWU7XG4gICAgc2NvcGUgPSA8YXN0LlBhcmFtcz4gdXRpbC5leHRlbmQoe30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyAndGhpcyc6IGFzdC5jYXN0KGFzdC5jYWxsKGFzdC52YXJpYWJsZSgnQGdldFRoaXMnKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdTbmFwc2hvdCcpIH0pO1xuICAgIGV4cCA9IHRoaXMucGFydGlhbEV2YWwoZXhwLCBzY29wZSk7XG4gICAgLy8gTm93IHJlLWV2YWx1YXRlIHRoZSBmbGF0dGVuZWQgZXhwcmVzc2lvbi5cbiAgICB0aGlzLmFsbG93VW5kZWZpbmVkRnVuY3Rpb25zID0gZmFsc2U7XG4gICAgdGhpcy50aGlzSXMgPSB0aGlzSXM7XG4gICAgdGhpcy5zeW1ib2xzLnJlZ2lzdGVyRnVuY3Rpb24oJ0BnZXRUaGlzJywgW10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXN0LmJ1aWx0aW4odGhpcy5nZXRUaGlzLmJpbmQodGhpcykpKTtcbiAgICB0aGlzLnN5bWJvbHMucmVnaXN0ZXJGdW5jdGlvbignQHJvb3QnLCBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3QuYnVpbHRpbih0aGlzLmdldFJvb3RSZWZlcmVuY2UuYmluZCh0aGlzLCBwYXRoKSkpO1xuICAgIHRoaXMuc3ltYm9scy5yZWdpc3RlckZ1bmN0aW9uKCdwcmlvcicsIFsnZXhwJ10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXN0LmJ1aWx0aW4odGhpcy5wcmlvci5iaW5kKHRoaXMpKSk7XG4gICAgdGhpcy5zeW1ib2xzLnJlZ2lzdGVyRnVuY3Rpb24oJ2tleScsIFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzdC5idWlsdGluKHRoaXMuZ2V0S2V5LmJpbmQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC5sZW5ndGgoKSA9PT0gMCA/ICcnIDogcGF0aC5nZXRQYXJ0KC0xKS5sYWJlbCkpKTtcblxuICAgIGV4cCA9IHRoaXMucGFydGlhbEV2YWwoZXhwKTtcblxuICAgIGRlbGV0ZSB0aGlzLnN5bWJvbHMuZnVuY3Rpb25zWydAZ2V0VGhpcyddO1xuICAgIGRlbGV0ZSB0aGlzLnN5bWJvbHMuZnVuY3Rpb25zWydAcm9vdCddO1xuICAgIGRlbGV0ZSB0aGlzLnN5bWJvbHMuZnVuY3Rpb25zWydwcmlvciddO1xuICAgIGRlbGV0ZSB0aGlzLnN5bWJvbHMuZnVuY3Rpb25zWydrZXknXTtcblxuICAgIC8vIFRvcCBsZXZlbCBleHByZXNzaW9ucyBzaG91bGQgbmV2ZXIgYmUgdG8gYSBzbmFwc2hvdCByZWZlcmVuY2UgLSBzaG91bGRcbiAgICAvLyBhbHdheXMgZXZhbHVhdGUgdG8gYSBib29sZWFuLlxuICAgIGV4cCA9IGFzdC5lbnN1cmVCb29sZWFuKGV4cCk7XG4gICAgcmV0dXJuIGFzdC5kZWNvZGVFeHByZXNzaW9uKGV4cCk7XG4gIH1cblxuICAvKlxuICAgKiAgV3JhcHBlciBmb3IgcGFydGlhbEV2YWwgZGVidWdnaW5nLlxuICAgKi9cblxuICBwYXJ0aWFsRXZhbChleHA6IGFzdC5FeHAsXG4gICAgICAgICAgICAgIHBhcmFtcyA9IDxhc3QuUGFyYW1zPiB7fSxcbiAgICAgICAgICAgICAgZnVuY3Rpb25DYWxsczogeyBbbmFtZTogc3RyaW5nXTogYm9vbGVhbiB9ID0ge30pXG4gIDogYXN0LkV4cCB7XG4gICAgLy8gV3JhcCByZWFsIGNhbGwgZm9yIGRlYnVnZ2luZy5cbiAgICBsZXQgcmVzdWx0ID0gdGhpcy5wYXJ0aWFsRXZhbFJlYWwoZXhwLCBwYXJhbXMsIGZ1bmN0aW9uQ2FsbHMpO1xuICAgIC8vIGNvbnNvbGUubG9nKGFzdC5kZWNvZGVFeHByZXNzaW9uKGV4cCkgKyBcIiA9PiBcIiArIGFzdC5kZWNvZGVFeHByZXNzaW9uKHJlc3VsdCkpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBQYXJ0aWFsIGV2YWx1YXRpb24gb2YgZXhwcmVzc2lvbnMgLSBjb3B5IG9mIGV4cHJlc3Npb24gdHJlZSAoaW1tdXRhYmxlKS5cbiAgLy9cbiAgLy8gLSBFeHBhbmQgaW5saW5lIGZ1bmN0aW9uIGNhbGxzLlxuICAvLyAtIFJlcGxhY2UgbG9jYWwgYW5kIGdsb2JhbCB2YXJpYWJsZXMgd2l0aCB0aGVpciB2YWx1ZXMuXG4gIC8vIC0gRXhwYW5kIHNuYXBzaG90IHJlZmVyZW5jZXMgdXNpbmcgY2hpbGQoJ3JlZicpLlxuICAvLyAtIENvZXJjZSBzbmFwc2hvdCByZWZlcmVuY2VzIHRvIHZhbHVlcyBhcyBuZWVkZWQuXG4gIHBhcnRpYWxFdmFsUmVhbChleHA6IGFzdC5FeHAsXG4gICAgICAgICAgICAgIHBhcmFtcyA9IDxhc3QuUGFyYW1zPiB7fSxcbiAgICAgICAgICAgICAgZnVuY3Rpb25DYWxscyA9IDx7IFtuYW1lOiBzdHJpbmddOiBib29sZWFuIH0+IHt9KVxuICA6IGFzdC5FeHAge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGZ1bmN0aW9uIHN1YkV4cHJlc3Npb24oZXhwMjogYXN0LkV4cCk6IGFzdC5FeHAge1xuICAgICAgcmV0dXJuIHNlbGYucGFydGlhbEV2YWwoZXhwMiwgcGFyYW1zLCBmdW5jdGlvbkNhbGxzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWx1ZUV4cHJlc3Npb24oZXhwMjogYXN0LkV4cCk6IGFzdC5FeHAge1xuICAgICAgcmV0dXJuIGFzdC5lbnN1cmVWYWx1ZShzdWJFeHByZXNzaW9uKGV4cDIpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBib29sZWFuRXhwcmVzc2lvbihleHAyOiBhc3QuRXhwKTogYXN0LkV4cCB7XG4gICAgICByZXR1cm4gYXN0LmVuc3VyZUJvb2xlYW4oc3ViRXhwcmVzc2lvbihleHAyKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9va3VwVmFyKGV4cDI6IGFzdC5FeHBWYXJpYWJsZSkge1xuICAgICAgLy8gVE9ETzogVW5ib3VuZCB2YXJpYWJsZSBhY2Nlc3Mgc2hvdWxkIGJlIGFuIGVycm9yLlxuICAgICAgcmV0dXJuIHBhcmFtc1tleHAyLm5hbWVdIHx8IHNlbGYuZ2xvYmFsc1tleHAyLm5hbWVdIHx8IGV4cDI7XG4gICAgfVxuXG4gICAgLy8gQ29udmVydCByZWZbcHJvcF0gPT4gcmVmLmNoaWxkKHByb3ApXG4gICAgZnVuY3Rpb24gc25hcHNob3RDaGlsZChyZWY6IGFzdC5FeHBSZWZlcmVuY2UpOiBhc3QuRXhwIHtcbiAgICAgIHJldHVybiBhc3QuY2FzdChhc3QuY2FsbChhc3QucmVmZXJlbmNlKHJlZi5iYXNlLCBhc3Quc3RyaW5nKCdjaGlsZCcpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbcmVmLmFjY2Vzc29yXSksXG4gICAgICAgICAgICAgICAgICAgICAgJ1NuYXBzaG90Jyk7XG4gICAgfVxuXG4gICAgc3dpdGNoIChleHAudHlwZSkge1xuICAgIGNhc2UgJ29wJzpcbiAgICAgIGxldCBleHBPcCA9IDxhc3QuRXhwT3A+IGFzdC5jb3B5RXhwKGV4cCk7XG4gICAgICAvLyBFbnN1cmUgYXJndW1lbnRzIGFyZSBib29sZWFuIChvciB2YWx1ZXMpIHdoZXJlIG5lZWRlZC5cbiAgICAgIGlmIChleHBPcC5vcCA9PT0gJ3ZhbHVlJykge1xuICAgICAgICBleHBPcC5hcmdzWzBdID0gdmFsdWVFeHByZXNzaW9uKGV4cE9wLmFyZ3NbMF0pO1xuICAgICAgfSBlbHNlIGlmIChleHBPcC5vcCA9PT0gJ3x8JyB8fCBleHBPcC5vcCA9PT0gJyYmJyB8fCBleHBPcC5vcCA9PT0gJyEnKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXhwT3AuYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGV4cE9wLmFyZ3NbaV0gPSBib29sZWFuRXhwcmVzc2lvbihleHBPcC5hcmdzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChleHBPcC5vcCA9PT0gJz86Jykge1xuICAgICAgICBleHBPcC5hcmdzWzBdID0gYm9vbGVhbkV4cHJlc3Npb24oZXhwT3AuYXJnc1swXSk7XG4gICAgICAgIGV4cE9wLmFyZ3NbMV0gPSB2YWx1ZUV4cHJlc3Npb24oZXhwT3AuYXJnc1sxXSk7XG4gICAgICAgIGV4cE9wLmFyZ3NbMl0gPSB2YWx1ZUV4cHJlc3Npb24oZXhwT3AuYXJnc1syXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGV4cE9wLmFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBleHBPcC5hcmdzW2ldID0gdmFsdWVFeHByZXNzaW9uKGV4cE9wLmFyZ3NbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZXhwT3A7XG5cbiAgICBjYXNlICd2YXInOlxuICAgICAgcmV0dXJuIGxvb2t1cFZhcig8YXN0LkV4cFZhcmlhYmxlPiBleHApO1xuXG4gICAgY2FzZSAncmVmJzpcbiAgICAgIGxldCBleHBSZWYgPSA8YXN0LkV4cFJlZmVyZW5jZT4gYXN0LmNvcHlFeHAoZXhwKTtcbiAgICAgIGV4cFJlZi5iYXNlID0gc3ViRXhwcmVzc2lvbihleHBSZWYuYmFzZSk7XG5cbiAgICAgIC8vIHZhcltyZWZdID0+IHZhcltyZWZdXG4gICAgICBpZiAoZXhwUmVmLmJhc2UudmFsdWVUeXBlICE9PSAnU25hcHNob3QnKSB7XG4gICAgICAgIGV4cFJlZi5hY2Nlc3NvciA9IHN1YkV4cHJlc3Npb24oZXhwUmVmLmFjY2Vzc29yKTtcbiAgICAgICAgcmV0dXJuIGV4cFJlZjtcbiAgICAgIH1cblxuICAgICAgbGV0IHByb3BOYW1lID0gYXN0LmdldFByb3BOYW1lKGV4cFJlZik7XG5cbiAgICAgIC8vIHNuYXBzaG90LnByb3AgKHN0YXRpYyBzdHJpbmcgcHJvcGVydHkpXG4gICAgICBpZiAocHJvcE5hbWUgIT09ICcnKSB7XG4gICAgICAgIC8vIHNuYXBzaG90LnZhbHVlTWV0aG9kID0+IHNuYXBzaG90LnZhbCgpLnZhbHVlTWV0aG9kXG4gICAgICAgIGlmICh1dGlsLmFycmF5SW5jbHVkZXModmFsdWVNZXRob2RzLCBwcm9wTmFtZSkpIHtcbiAgICAgICAgICBleHBSZWYuYmFzZSA9IHZhbHVlRXhwcmVzc2lvbihleHBSZWYuYmFzZSk7XG4gICAgICAgICAgcmV0dXJuIGV4cFJlZjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNuYXBzaG90LnNzTWV0aG9kID0+IHNuYXBzaG90LnNzTWV0aG9kXG4gICAgICAgIGlmICh1dGlsLmFycmF5SW5jbHVkZXMoc25hcHNob3RNZXRob2RzLCBwcm9wTmFtZSkpIHtcbiAgICAgICAgICByZXR1cm4gZXhwUmVmO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIHNuYXBzaG90W2V4cF0gPT4gc25hcHNob3QuY2hpbGQoZXhwKSBvclxuICAgICAgLy8gc25hcHNob3RbcmVmXSA9PiBzbmFwc2hvdC5jaGlsZChyZWYudmFsKCkpXG4gICAgICBleHBSZWYuYWNjZXNzb3IgPSB2YWx1ZUV4cHJlc3Npb24oZXhwUmVmLmFjY2Vzc29yKTtcbiAgICAgIHJldHVybiBzbmFwc2hvdENoaWxkKGV4cFJlZik7XG5cbiAgICBjYXNlICdjYWxsJzpcbiAgICAgIGxldCBleHBDYWxsID0gPGFzdC5FeHBDYWxsPiBhc3QuY29weUV4cChleHApO1xuICAgICAgZXhwQ2FsbC5yZWYgPSA8YXN0LkV4cFZhcmlhYmxlIHwgYXN0LkV4cFJlZmVyZW5jZT4gc3ViRXhwcmVzc2lvbihleHBDYWxsLnJlZik7XG4gICAgICB2YXIgY2FsbGVlID0gdGhpcy5sb29rdXBGdW5jdGlvbihleHBDYWxsLnJlZik7XG5cbiAgICAgIC8vIEV4cGFuZCB0aGUgZnVuY3Rpb24gY2FsbCBpbmxpbmVcbiAgICAgIGlmIChjYWxsZWUpIHtcbiAgICAgICAgdmFyIGZuID0gY2FsbGVlLmZuO1xuXG4gICAgICAgIGlmIChjYWxsZWUuc2VsZikge1xuICAgICAgICAgIGV4cENhbGwuYXJncy51bnNoaWZ0KGFzdC5lbnN1cmVWYWx1ZShjYWxsZWUuc2VsZikpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZuLnBhcmFtcy5sZW5ndGggIT09IGV4cENhbGwuYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICB0aGlzLmZhdGFsKGVycm9ycy5taXNtYXRjaFBhcmFtcyArIFwiICggXCIgK1xuICAgICAgICAgICAgICAgICAgICAgY2FsbGVlLm1ldGhvZE5hbWUgKyBcIiBleHBlY3RzIFwiICsgZm4ucGFyYW1zLmxlbmd0aCArXG4gICAgICAgICAgICAgICAgICAgICBcIiBidXQgYWN0dWFsbHkgcGFzc2VkIFwiICsgZXhwQ2FsbC5hcmdzLmxlbmd0aCArIFwiKVwiKTtcbiAgICAgICAgICByZXR1cm4gZXhwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZuLmJvZHkudHlwZSA9PT0gJ2J1aWx0aW4nKSB7XG4gICAgICAgICAgcmV0dXJuICg8YXN0LkV4cEJ1aWx0aW4+IGZuLmJvZHkpLmZuKGV4cENhbGwuYXJncywgcGFyYW1zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBpbm5lclBhcmFtcyA9IDxhc3QuUGFyYW1zPiB7fTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZuLnBhcmFtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlubmVyUGFyYW1zW2ZuLnBhcmFtc1tpXV0gPSBzdWJFeHByZXNzaW9uKGV4cENhbGwuYXJnc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZ1bmN0aW9uQ2FsbHNbY2FsbGVlLm1ldGhvZE5hbWVdKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9ycy5yZWN1cnNpdmUgKyBcIiAoXCIgKyBjYWxsZWUubWV0aG9kTmFtZSArIFwiKVwiKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbkNhbGxzW2NhbGxlZS5tZXRob2ROYW1lXSA9IHRydWU7XG4gICAgICAgIGxldCByZXN1bHQgPSB0aGlzLnBhcnRpYWxFdmFsKGZuLmJvZHksIGlubmVyUGFyYW1zLCBmdW5jdGlvbkNhbGxzKTtcbiAgICAgICAgZnVuY3Rpb25DYWxsc1tjYWxsZWUubWV0aG9kTmFtZV0gPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cblxuICAgICAgLy8gQ2FuJ3QgZXhwYW5kIGZ1bmN0aW9uIC0gYnV0IGp1c3QgZXhwYW5kIHRoZSBhcmd1bWVudHMuXG4gICAgICBpZiAoIXRoaXMuYWxsb3dVbmRlZmluZWRGdW5jdGlvbnMpIHtcbiAgICAgICAgdmFyIGZ1bmNOYW1lID0gYXN0LmdldE1ldGhvZE5hbWUoZXhwQ2FsbCk7XG4gICAgICAgIGlmIChmdW5jTmFtZSAhPT0gJycgJiYgIShmdW5jTmFtZSBpbiB0aGlzLnN5bWJvbHMuc2NoZW1hWydTdHJpbmcnXS5tZXRob2RzIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1dGlsLmFycmF5SW5jbHVkZXMoc25hcHNob3RNZXRob2RzLCBmdW5jTmFtZSkpKSB7XG4gICAgICAgICAgdGhpcy5mYXRhbChlcnJvcnMudW5kZWZpbmVkRnVuY3Rpb24gKyBhc3QuZGVjb2RlRXhwcmVzc2lvbihleHBDYWxsLnJlZikpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXhwQ2FsbC5hcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGV4cENhbGwuYXJnc1tpXSA9IHN1YkV4cHJlc3Npb24oZXhwQ2FsbC5hcmdzW2ldKTtcbiAgICAgIH1cblxuICAgICAgLy8gSGFjayBmb3Igc25hcHNob3QucGFyZW50KCkudmFsKClcbiAgICAgIC8vIFRvZG8gLSBidWlsZCB0YWJsZS1iYXNlZCBtZXRob2Qgc2lnbmF0dXJlcy5cbiAgICAgIGlmIChhc3QuZ2V0TWV0aG9kTmFtZShleHBDYWxsKSA9PT0gJ3BhcmVudCcpIHtcbiAgICAgICAgZXhwQ2FsbCA9IDxhc3QuRXhwQ2FsbD4gYXN0LmNhc3QoZXhwQ2FsbCwgJ1NuYXBzaG90Jyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBleHBDYWxsO1xuXG4gICAgLy8gRXhwcmVzc2lvbiB0eXBlcyAobGlrZSBsaXRlcmFscykgdGhhbiBuZWVkIG5vIGV4cGFuc2lvbi5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGV4cDtcbiAgICB9XG4gIH1cblxuICAvLyBCdWlsdGluIGZ1bmN0aW9uIC0gY29udmVydCBhbGwgJ3RoaXMnIHRvICdkYXRhJyAoZnJvbSAnbmV3RGF0YScpLlxuICAvLyBBcmdzIGFyZSBmdW5jdGlvbiBhcmd1bWVudHMsIGFuZCBwYXJhbXMgYXJlIHRoZSBsb2NhbCAoZnVuY3Rpb24pIHNjb3BlIHZhcmlhYmxlcy5cbiAgcHJpb3IoYXJnczogYXN0LkV4cFtdLCBwYXJhbXM6IGFzdC5QYXJhbXMpOiBhc3QuRXhwIHtcbiAgICB2YXIgbGFzdFRoaXNJcyA9IHRoaXMudGhpc0lzO1xuICAgIHRoaXMudGhpc0lzID0gJ2RhdGEnO1xuICAgIHZhciBleHAgPSB0aGlzLnBhcnRpYWxFdmFsKGFyZ3NbMF0sIHBhcmFtcyk7XG4gICAgdGhpcy50aGlzSXMgPSBsYXN0VGhpc0lzO1xuICAgIHJldHVybiBleHA7XG4gIH1cblxuICAvLyBCdWlsdGluIGZ1bmN0aW9uIC0gY3VycmVudCB2YWx1ZSBvZiAndGhpcydcbiAgZ2V0VGhpcyhhcmdzOiBhc3QuRXhwW10sIHBhcmFtczogYXN0LlBhcmFtcyk6IGFzdC5FeHAge1xuICAgIHJldHVybiBhc3Quc25hcHNob3RWYXJpYWJsZSh0aGlzLnRoaXNJcyk7XG4gIH1cblxuICAvLyBCdWlsdGluIGZ1bmN0aW9uIC0gZW5zdXJlIHR5cGUgb2YgYXJndW1lbnRcbiAgZW5zdXJlVHlwZSh0eXBlOiBzdHJpbmcsIGFyZ3M6IGFzdC5FeHBbXSwgcGFyYW1zOiBhc3QuUGFyYW1zKSB7XG4gICAgaWYgKGFyZ3MubGVuZ3RoICE9PSAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLmFwcGxpY2F0aW9uICsgXCJlbnN1cmVUeXBlIGFyZ3VtZW50cy5cIik7XG4gICAgfVxuICAgIHZhciBleHAgPSA8YXN0LkV4cFZhbHVlPiB0aGlzLnBhcnRpYWxFdmFsKGFyZ3NbMF0sIHBhcmFtcyk7XG4gICAgaWYgKGV4cC50eXBlICE9PSB0eXBlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLmNvZXJjaW9uICsgYXN0LmRlY29kZUV4cHJlc3Npb24oZXhwKSArIFwiID0+IFwiICsgdHlwZSk7XG4gICAgfVxuICAgIHJldHVybiBleHA7XG4gIH1cblxuICAvLyBCdWlsdGluIGZ1bmN0aW9uIC0gcmV0dXJuIHRoZSBwYXJlbnQga2V5IG9mICd0aGlzJy5cbiAgZ2V0S2V5KGtleTogc3RyaW5nLCBhcmdzOiBhc3QuRXhwW10sIHBhcmFtczogYXN0LlBhcmFtcykge1xuICAgIGlmIChhcmdzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9ycy5taXNtYXRjaFBhcmFtcyArIFwiKGZvdW5kIFwiICsgYXJncy5sZW5ndGggKyBcIiBidXQgZXhwZWN0ZWQgMSlcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGtleVswXSA9PT0gJyQnID8gYXN0LmxpdGVyYWwoa2V5KSA6IGFzdC5zdHJpbmcoa2V5KTtcbiAgfVxuXG4gIC8vIEJ1aWx0aW4gZnVuY3Rpb24gLSByZXR1cm4gdGhlIHJlZmVyZW5jZSB0byB0aGUgcm9vdFxuICAvLyBXaGVuIGluIHJlYWQgbW9kZSAtIHVzZSAncm9vdCdcbiAgLy8gV2hlbiBpbiB3cml0ZS92YWxpZGF0ZSAtIHVzZSBwYXRoIHRvIHJvb3QgdmlhIG5ld0RhdGEucGFyZW50KCkuLi5cbiAgZ2V0Um9vdFJlZmVyZW5jZShwYXRoOiBhc3QuUGF0aFRlbXBsYXRlLCBhcmdzOiBhc3QuRXhwW10sIHBhcmFtczogYXN0LlBhcmFtcykge1xuICAgIGlmIChhcmdzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9ycy5hcHBsaWNhdGlvbiArIFwiQHJvb3QgYXJndW1lbnRzLlwiKTtcbiAgICB9XG5cbiAgICAvLyAnZGF0YScgY2FzZVxuICAgIGlmICh0aGlzLnRoaXNJcyA9PT0gJ2RhdGEnKSB7XG4gICAgICByZXR1cm4gYXN0LnNuYXBzaG90VmFyaWFibGUoJ3Jvb3QnKTtcbiAgICB9XG5cbiAgICAvLyBUT0RPKGtvc3MpOiBSZW1vdmUgdGhpcyBzcGVjaWFsIGNhc2UgaWYgSlNPTiBzdXBwb3J0cyBuZXdSb290IGluc3RlYWQuXG4gICAgLy8gJ25ld0RhdGEnIGNhc2UgLSB0cmF2ZXJzZSB0byByb290IHZpYSBwYXJlbnQoKSdzLlxuICAgIGxldCByZXN1bHQ6IGFzdC5FeHAgPSBhc3Quc25hcHNob3RWYXJpYWJsZSgnbmV3RGF0YScpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0aC5sZW5ndGgoKTsgaSsrKSB7XG4gICAgICByZXN1bHQgPSBhc3Quc25hcHNob3RQYXJlbnQocmVzdWx0KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIExvb2t1cCBnbG9iYWxseSBkZWZpbmVkIGZ1bmN0aW9uLlxuICBsb29rdXBGdW5jdGlvbihyZWY6IGFzdC5FeHBWYXJpYWJsZSB8IGFzdC5FeHBSZWZlcmVuY2UpOiB7XG4gICAgc2VsZj86IGFzdC5FeHAsXG4gICAgZm46IGFzdC5NZXRob2QsXG4gICAgbWV0aG9kTmFtZTogc3RyaW5nXG4gIH0gfCB1bmRlZmluZWQge1xuICAgIC8vIEZ1bmN0aW9uIGNhbGwuXG4gICAgaWYgKHJlZi50eXBlID09PSAndmFyJykge1xuICAgICAgbGV0IHJlZlZhciA9IDxhc3QuRXhwVmFyaWFibGU+IHJlZjtcbiAgICAgIHZhciBmbiA9IHRoaXMuc3ltYm9scy5mdW5jdGlvbnNbcmVmVmFyLm5hbWVdO1xuICAgICAgaWYgKCFmbikge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgc2VsZjogdW5kZWZpbmVkLCBmbjogZm4sIG1ldGhvZE5hbWU6IHJlZlZhci5uYW1lfTtcbiAgICB9XG5cbiAgICAvLyBNZXRob2QgY2FsbC5cbiAgICBpZiAocmVmLnR5cGUgPT09ICdyZWYnKSB7XG4gICAgICBsZXQgcmVmUmVmID0gPGFzdC5FeHBSZWZlcmVuY2U+IHJlZjtcbiAgICAgIC8vIFRPRE86IFJlcXVpcmUgc3RhdGljIHR5cGUgdmFsaWRhdGlvbiBiZWZvcmUgY2FsbGluZyBTdHJpbmcgbWV0aG9kcy5cbiAgICAgIGlmICgoPGFzdC5FeHBPcD4gcmVmUmVmLmJhc2UpLm9wICE9PSAndmFsdWUnICYmXG4gICAgICAgICAgPHN0cmluZz4gKDxhc3QuRXhwVmFsdWU+IHJlZlJlZi5hY2Nlc3NvcikudmFsdWUgaW4gdGhpcy5zeW1ib2xzLnNjaGVtYVsnU3RyaW5nJ10ubWV0aG9kcykge1xuICAgICAgICBsZXQgbWV0aG9kTmFtZSA9IDxzdHJpbmc+ICg8YXN0LkV4cFZhbHVlPiByZWZSZWYuYWNjZXNzb3IpLnZhbHVlO1xuICAgICAgICByZXR1cm4geyBzZWxmOiByZWZSZWYuYmFzZSxcbiAgICAgICAgICAgICAgICAgZm46IHRoaXMuc3ltYm9scy5zY2hlbWFbJ1N0cmluZyddLm1ldGhvZHNbbWV0aG9kTmFtZV0sXG4gICAgICAgICAgICAgICAgIG1ldGhvZE5hbWU6ICdTdHJpbmcuJyArIG1ldGhvZE5hbWVcbiAgICAgICAgICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICBmYXRhbChzOiBzdHJpbmcpIHtcbiAgICBlcnJvcihzKTtcbiAgICB0aGlzLmVycm9yQ291bnQgKz0gMTtcbiAgfVxufTtcblxuLy8gTWVyZ2UgYWxsIC5YIHRlcm1zIGludG8gdGFyZ2V0LlxuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZFZhbGlkYXRvcih0YXJnZXQ6IFZhbGlkYXRvciwgc3JjOiBWYWxpZGF0b3IpOiBWYWxpZGF0b3Ige1xuICBpZiAoc3JjID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLmFwcGxpY2F0aW9uICsgXCJJbGxlZ2FsIHZhbGlkYXRpb24gc291cmNlLlwiKTtcbiAgfVxuICBmb3IgKHZhciBwcm9wIGluIHNyYykge1xuICAgIGlmICghc3JjLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHByb3BbMF0gPT09ICcuJykge1xuICAgICAgaWYgKHRhcmdldFtwcm9wXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRhcmdldFtwcm9wXSA9IFtdO1xuICAgICAgfVxuICAgICAgaWYgKHV0aWwuaXNUeXBlKHNyY1twcm9wXSwgJ2FycmF5JykpIHtcbiAgICAgICAgdXRpbC5leHRlbmRBcnJheSg8YW55W10+IHRhcmdldFtwcm9wXSwgPGFueVtdPiBzcmNbcHJvcF0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgKDxhc3QuRXhwW10+IHRhcmdldFtwcm9wXSkucHVzaCg8YXN0LkV4cD4gc3JjW3Byb3BdKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCF0YXJnZXRbcHJvcF0pIHtcbiAgICAgICAgdGFyZ2V0W3Byb3BdID0ge307XG4gICAgICB9XG4gICAgICBleHRlbmRWYWxpZGF0b3IoPFZhbGlkYXRvcj4gdGFyZ2V0W3Byb3BdLCA8VmFsaWRhdG9yPiBzcmNbcHJvcF0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbi8vIENhbGwgZm4odmFsdWUsIHByb3AsIHBhdGgpIG9uIGFsbCAnLnByb3BzJyBhbmQgYXNzaWdpbmcgdGhlIHZhbHVlIGJhY2sgaW50byB0aGVcbi8vIHZhbGlkYXRvci5cbmV4cG9ydCBmdW5jdGlvbiBtYXBWYWxpZGF0b3IodjogVmFsaWRhdG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbjogKHZhbDogVmFsaWRhdG9yVmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcDogc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlOiBhc3QuUGFyYW1zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6IGFzdC5QYXRoVGVtcGxhdGUpID0+IFZhbGlkYXRvclZhbHVlIHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29wZT86IGFzdC5QYXJhbXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg/OiBhc3QuUGF0aFRlbXBsYXRlKSB7XG4gIGlmICghc2NvcGUpIHtcbiAgICBzY29wZSA9IDxhc3QuUGFyYW1zPiB7fTtcbiAgfVxuICBpZiAoIXBhdGgpIHtcbiAgICBwYXRoID0gbmV3IGFzdC5QYXRoVGVtcGxhdGUoKTtcbiAgfVxuICBpZiAoJy5zY29wZScgaW4gdikge1xuICAgIHNjb3BlID0gPGFzdC5QYXJhbXM+IHZbJy5zY29wZSddO1xuICB9XG4gIGZvciAodmFyIHByb3AgaW4gdikge1xuICAgIGlmICghdi5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChwcm9wWzBdID09PSAnLicpIHtcbiAgICAgIGxldCB2YWx1ZSA9IGZuKHZbcHJvcF0sIHByb3AsIHNjb3BlLCBwYXRoKTtcbiAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZbcHJvcF0gPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZSB2W3Byb3BdO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIXV0aWwuaXNUeXBlKHZbcHJvcF0sICdvYmplY3QnKSkge1xuICAgICAgY29udGludWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBjaGlsZCA9IG5ldyBhc3QuUGF0aFRlbXBsYXRlKFtwcm9wXSk7XG4gICAgICBwYXRoLnB1c2goY2hpbGQpO1xuICAgICAgbWFwVmFsaWRhdG9yKDxWYWxpZGF0b3I+IHZbcHJvcF0sIGZuLCBzY29wZSwgcGF0aCk7XG4gICAgICBwYXRoLnBvcChjaGlsZCk7XG4gICAgfVxuICB9XG59XG5cbi8vIENvbGxhcHNlIGFsbCBoYXNDaGlsZHJlbiBjYWxscyBpbnRvIG9uZSAoY29tYmluaW5nIHRoZWlyIGFyZ3VtZW50cykuXG4vLyBFLmcuIFtuZXdEYXRhLmhhc0NoaWxkcmVuKCksIG5ld0RhdGEuaGFzQ2hpbGRyZW4oWyd4J10pLCBuZXdEYXRhLmhhc0NoaWxkcmVuKFsneSddKV0gPT5cbi8vICAgICAgbmV3RGF0YS5oYXNDaGlsZHJlbihbJ3gnLCAneSddKVxuZnVuY3Rpb24gY29sbGFwc2VIYXNDaGlsZHJlbihleHBzOiBhc3QuRXhwW10pOiBhc3QuRXhwW10ge1xuICB2YXIgaGFzSGFzQ2hpbGRyZW46IGJvb2xlYW4gPSBmYWxzZTtcbiAgdmFyIGNvbWJpbmVkID0gPHN0cmluZ1tdPiBbXTtcbiAgdmFyIHJlc3VsdCA9IDxhc3QuRXhwW10+IFtdO1xuICBleHBzLmZvckVhY2goZnVuY3Rpb24oZXhwKSB7XG4gICAgaWYgKGV4cC50eXBlICE9PSAnY2FsbCcpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGV4cCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IGV4cENhbGwgPSA8YXN0LkV4cENhbGw+IGV4cDtcbiAgICBpZiAoYXN0LmdldE1ldGhvZE5hbWUoZXhwQ2FsbCkgIT09ICdoYXNDaGlsZHJlbicpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGV4cCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGV4cENhbGwuYXJncy5sZW5ndGggPT09IDApIHtcbiAgICAgIGhhc0hhc0NoaWxkcmVuID0gdHJ1ZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBFeHBlY3Qgb25lIGFyZ3VtZW50IG9mIEFycmF5IHR5cGUuXG4gICAgaWYgKGV4cENhbGwuYXJncy5sZW5ndGggIT09IDEgfHwgZXhwQ2FsbC5hcmdzWzBdLnR5cGUgIT09ICdBcnJheScpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMuYXBwbGljYXRpb24gKyBcIkludmFsaWQgYXJndW1lbnQgdG8gaGFzQ2hpbGRyZW4oKTogXCIgK1xuICAgICAgICAgICAgICAgICAgICAgIGV4cENhbGwuYXJnc1swXS50eXBlKTtcbiAgICB9XG4gICAgbGV0IGFyZ3MgPSAoPGFzdC5FeHBWYWx1ZT4gZXhwQ2FsbC5hcmdzWzBdKS52YWx1ZTtcblxuICAgIGFyZ3MuZm9yRWFjaChmdW5jdGlvbihhcmc6IGFzdC5FeHBWYWx1ZSkge1xuICAgICAgaGFzSGFzQ2hpbGRyZW4gPSB0cnVlO1xuICAgICAgaWYgKGFyZy50eXBlICE9PSAnU3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLmFwcGxpY2F0aW9uICsgXCJFeHBlY3Qgc3RyaW5nIGFyZ3VtZW50IHRvIGhhc0NoaWxkcmVuKCksIG5vdDogXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJnLnR5cGUpO1xuICAgICAgfVxuICAgICAgY29tYmluZWQucHVzaChhcmcudmFsdWUpO1xuICAgIH0pO1xuICB9KTtcblxuICBpZiAoaGFzSGFzQ2hpbGRyZW4pIHtcbiAgICByZXN1bHQudW5zaGlmdChoYXNDaGlsZHJlbkV4cChjb21iaW5lZCkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8vIEdlbmVyYXRlIHRoaXMuaGFzQ2hpbGRyZW4oW3Byb3BzLCAuLi5dKSBvciB0aGlzLmhhc0NoaWxkcmVuKClcbmZ1bmN0aW9uIGhhc0NoaWxkcmVuRXhwKHByb3BzOiBzdHJpbmdbXSk6IGFzdC5FeHAge1xuICB2YXIgYXJncyA9IHByb3BzLmxlbmd0aCA9PT0gMCA/IFtdIDogW2FzdC5hcnJheShwcm9wcy5tYXAoYXN0LnN0cmluZykpXTtcbiAgcmV0dXJuIGFzdC5jYWxsKGFzdC5yZWZlcmVuY2UoYXN0LmNhc3QoYXN0LnZhcmlhYmxlKCd0aGlzJyksICdBbnknKSwgYXN0LnN0cmluZygnaGFzQ2hpbGRyZW4nKSksXG4gICAgICAgICAgICAgICAgICBhcmdzKTtcbn1cbiJdfQ==
