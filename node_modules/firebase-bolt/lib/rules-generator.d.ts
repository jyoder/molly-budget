import * as ast from './ast';
export declare type ValidatorValue = ast.Exp | ast.Exp[] | string | string[] | Validator;
export interface Validator {
    [name: string]: ValidatorValue;
}
export declare function generate(symbols: string | ast.Symbols): Validator;
export declare class Generator {
    symbols: ast.Symbols;
    validators: {
        [schemaName: string]: Validator;
    };
    rules: Validator;
    errorCount: number;
    runSilently: boolean;
    allowUndefinedFunctions: boolean;
    globals: ast.Params;
    thisIs: string;
    keyIndex: number;
    constructor(symbols: ast.Symbols);
    generateRules(): Validator;
    validateMethods(m: string, methods: {
        [name: string]: ast.Method;
    }, allowed: string[]): void;
    registerBuiltinSchema(): void;
    getMapValidator(params: ast.Exp[]): Validator;
    uniqueKey(): string;
    isCollectionSchema(schema: ast.Schema): boolean;
    ensureValidator(type: ast.ExpType): Validator;
    createValidator(type: ast.ExpType): Validator;
    createValidatorFromGeneric(schemaName: string, params: ast.ExpType[]): Validator;
    replaceGenericsInSchema(schema: ast.Schema, bindings: ast.TypeParams): ast.Schema;
    replaceGenericsInExp(exp: ast.Exp, bindings: ast.TypeParams): ast.Exp;
    replaceGenericsInMethod(method: ast.Method, bindings: ast.TypeParams): ast.Method;
    createValidatorFromSchemaName(schemaName: string): Validator;
    createValidatorFromSchema(schema: ast.Schema): Validator;
    isNullableType(type: ast.ExpType): boolean;
    updateRules(path: ast.Path): void;
    extendValidationMethods(validator: Validator, methods: {
        [method: string]: ast.Method;
    }): void;
    unionValidators(schema: string[]): Validator;
    convertExpressions(validator: Validator): void;
    getExpressionText(exp: ast.Exp, thisIs: string, scope: ast.Params, path: ast.PathTemplate): string;
    partialEval(exp: ast.Exp, params?: ast.Params, functionCalls?: {
        [name: string]: boolean;
    }): ast.Exp;
    partialEvalReal(exp: ast.Exp, params?: ast.Params, functionCalls?: {
        [name: string]: boolean;
    }): ast.Exp;
    prior(args: ast.Exp[], params: ast.Params): ast.Exp;
    getThis(args: ast.Exp[], params: ast.Params): ast.Exp;
    ensureType(type: string, args: ast.Exp[], params: ast.Params): ast.ExpValue;
    getKey(key: string, args: ast.Exp[], params: ast.Params): ast.ExpValue | ast.ExpLiteral;
    getRootReference(path: ast.PathTemplate, args: ast.Exp[], params: ast.Params): ast.Exp;
    lookupFunction(ref: ast.ExpVariable | ast.ExpReference): {
        self?: ast.Exp;
        fn: ast.Method;
        methodName: string;
    } | undefined;
    fatal(s: string): void;
}
export declare function extendValidator(target: Validator, src: Validator): Validator;
export declare function mapValidator(v: Validator, fn: (val: ValidatorValue, prop: string, scope: ast.Params, path: ast.PathTemplate) => ValidatorValue | undefined, scope?: ast.Params, path?: ast.PathTemplate): void;
