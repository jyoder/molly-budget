export declare type Object = {
    [prop: string]: any;
};
export interface Exp {
    type: string;
    valueType: string;
}
export interface ExpValue extends Exp {
    value: any;
}
export interface RegExpValue extends ExpValue {
    modifiers: string;
}
export interface ExpNull extends Exp {
}
export interface ExpOp extends Exp {
    op: string;
    args: Exp[];
}
export interface ExpVariable extends Exp {
    name: string;
}
export interface ExpLiteral extends Exp {
    name: string;
}
export interface ExpReference extends Exp {
    base: Exp;
    accessor: Exp;
}
export interface ExpCall extends Exp {
    ref: ExpReference | ExpVariable;
    args: Exp[];
}
export interface Params {
    [name: string]: Exp;
}
export declare type BuiltinFunction = (args: Exp[], params: Params) => Exp;
export interface ExpBuiltin extends Exp {
    fn: BuiltinFunction;
}
export declare type ExpType = ExpSimpleType | ExpUnionType | ExpGenericType;
export interface TypeParams {
    [name: string]: ExpType;
}
export interface ExpSimpleType extends Exp {
    name: string;
}
export interface ExpUnionType extends Exp {
    types: ExpType[];
}
export interface ExpGenericType extends Exp {
    name: string;
    params: ExpType[];
}
export interface Method {
    params: string[];
    body: Exp;
}
export declare class PathPart {
    label: string;
    variable: string;
    constructor(label: string, variable?: string);
}
export declare class PathTemplate {
    parts: PathPart[];
    constructor(parts?: (string | PathPart)[]);
    copy(): PathTemplate;
    getLabels(): string[];
    getScope(): Params;
    push(temp: PathTemplate): void;
    pop(temp: PathTemplate): void;
    length(): number;
    getPart(i: number): PathPart;
}
export interface Path {
    template: PathTemplate;
    isType: ExpType;
    methods: {
        [name: string]: Method;
    };
}
export declare class Schema {
    derivedFrom: ExpType;
    properties: TypeParams;
    methods: {
        [name: string]: Method;
    };
    params?: string[];
    getValidator?: (params: Exp[]) => Object;
    static isGeneric(schema: Schema): boolean;
}
export declare var string: (v: string) => ExpValue;
export declare var boolean: (v: boolean) => ExpValue;
export declare var number: (v: number) => ExpValue;
export declare var array: (v: Array<any>) => ExpValue;
export declare var neg: (...args: Exp[]) => ExpOp;
export declare var not: (...args: Exp[]) => ExpOp;
export declare var mult: (...args: Exp[]) => ExpOp;
export declare var div: (...args: Exp[]) => ExpOp;
export declare var mod: (...args: Exp[]) => ExpOp;
export declare var add: (...args: Exp[]) => ExpOp;
export declare var sub: (...args: Exp[]) => ExpOp;
export declare var eq: (...args: Exp[]) => ExpOp;
export declare var lt: (...args: Exp[]) => ExpOp;
export declare var lte: (...args: Exp[]) => ExpOp;
export declare var gt: (...args: Exp[]) => ExpOp;
export declare var gte: (...args: Exp[]) => ExpOp;
export declare var ne: (...args: Exp[]) => ExpOp;
export declare var and: (...args: Exp[]) => ExpOp;
export declare var or: (...args: Exp[]) => ExpOp;
export declare var ternary: (...args: Exp[]) => ExpOp;
export declare var value: (...args: Exp[]) => ExpOp;
export declare function variable(name: string): ExpVariable;
export declare function literal(name: string): ExpLiteral;
export declare function nullType(): ExpNull;
export declare function reference(base: Exp, prop: Exp): ExpReference;
export declare function isIdentifierStringExp(exp: Exp): boolean;
export declare function copyExp(exp: Exp): Exp;
export declare function cast(base: Exp, valueType: string): Exp;
export declare function call(ref: ExpReference | ExpVariable, args?: Exp[]): ExpCall;
export declare function getFunctionName(exp: ExpCall): string;
export declare function getMethodName(exp: ExpCall): string;
export declare function getPropName(ref: ExpReference): string;
export declare function builtin(fn: BuiltinFunction): ExpBuiltin;
export declare function snapshotVariable(name: string): ExpVariable;
export declare function snapshotParent(base: Exp): Exp;
export declare function ensureValue(exp: Exp): Exp;
export declare function snapshotValue(exp: Exp): ExpCall;
export declare function ensureBoolean(exp: Exp): Exp;
export declare function isCall(exp: Exp, methodName: string): boolean;
export declare function regexp(pattern: string, modifiers?: string): RegExpValue;
export declare var andArray: (a: Exp[]) => Exp;
export declare var orArray: (a: Exp[]) => Exp;
export declare function flatten(opType: string, exp: Exp, flat?: Exp[]): Exp[];
export declare function op(opType: string, args: Exp[]): ExpOp;
export declare function method(params: string[], body: Exp): Method;
export declare function typeType(typeName: string): ExpSimpleType;
export declare function unionType(types: ExpType[]): ExpUnionType;
export declare function genericType(typeName: string, params: ExpType[]): ExpGenericType;
export declare class Symbols {
    functions: {
        [name: string]: Method;
    };
    paths: Path[];
    schema: {
        [name: string]: Schema;
    };
    constructor();
    register<T>(map: {
        [name: string]: T;
    }, typeName: string, name: string, object: T): T;
    registerFunction(name: string, params: string[], body: Exp): Method;
    registerPath(template: PathTemplate, isType: ExpType | void, methods?: {
        [name: string]: Method;
    }): Path;
    registerSchema(name: string, derivedFrom?: ExpType, properties?: TypeParams, methods?: {
        [name: string]: Method;
    }, params?: string[]): Schema;
    isDerivedFrom(type: ExpType, ancestor: string): boolean;
}
export declare function decodeExpression(exp: Exp, outerPrecedence?: number): string;
