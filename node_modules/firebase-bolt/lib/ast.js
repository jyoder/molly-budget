"use strict";
exports.__esModule = true;
/*
 * AST builders for Firebase Rules Language.
 *
 * Copyright 2015 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var util = require("./util");
var logger = require("./logger");
var errors = {
    typeMismatch: "Unexpected type: ",
    duplicatePathPart: "A path component name is duplicated: "
};
;
;
var PathPart = /** @class */ (function () {
    // "label", undefined - static path part
    // "$label", X - variable path part
    // X, !undefined - variable path part
    function PathPart(label, variable) {
        if (label[0] === '$' && variable === undefined) {
            variable = label;
        }
        if (variable && label[0] !== '$') {
            label = '$' + label;
        }
        this.label = label;
        this.variable = variable;
    }
    return PathPart;
}());
exports.PathPart = PathPart;
var PathTemplate = /** @class */ (function () {
    function PathTemplate(parts) {
        if (parts === void 0) { parts = []; }
        this.parts = parts.map(function (part) {
            if (util.isType(part, 'string')) {
                return new PathPart(part);
            }
            else {
                return part;
            }
        });
    }
    PathTemplate.prototype.copy = function () {
        var result = new PathTemplate();
        result.push(this);
        return result;
    };
    PathTemplate.prototype.getLabels = function () {
        return this.parts.map(function (part) { return part.label; });
    };
    // Mapping from variables to JSON labels
    PathTemplate.prototype.getScope = function () {
        var result = {};
        this.parts.forEach(function (part) {
            if (part.variable) {
                if (result[part.variable]) {
                    throw new Error(errors.duplicatePathPart + part.variable);
                }
                result[part.variable] = literal(part.label);
            }
        });
        return result;
    };
    PathTemplate.prototype.push = function (temp) {
        util.extendArray(this.parts, temp.parts);
    };
    PathTemplate.prototype.pop = function (temp) {
        var _this = this;
        temp.parts.forEach(function (part) {
            _this.parts.pop();
        });
    };
    PathTemplate.prototype.length = function () {
        return this.parts.length;
    };
    PathTemplate.prototype.getPart = function (i) {
        if (i > this.parts.length || i < -this.parts.length) {
            var l = this.parts.length;
            throw new Error("Path reference out of bounds: " + i +
                " [" + -l + " .. " + l + "]");
        }
        if (i < 0) {
            return this.parts[this.parts.length + i];
        }
        return this.parts[i];
    };
    return PathTemplate;
}());
exports.PathTemplate = PathTemplate;
;
var Schema = /** @class */ (function () {
    function Schema() {
    }
    Schema.isGeneric = function (schema) {
        return schema.params !== undefined && schema.params.length > 0;
    };
    return Schema;
}());
exports.Schema = Schema;
;
exports.string = valueGen('String');
exports.boolean = valueGen('Boolean');
exports.number = valueGen('Number');
exports.array = valueGen('Array');
exports.neg = opGen('neg', 1);
exports.not = opGen('!', 1);
exports.mult = opGen('*');
exports.div = opGen('/');
exports.mod = opGen('%');
exports.add = opGen('+');
exports.sub = opGen('-');
exports.eq = opGen('==');
exports.lt = opGen('<');
exports.lte = opGen('<=');
exports.gt = opGen('>');
exports.gte = opGen('>=');
exports.ne = opGen('!=');
exports.and = opGen('&&');
exports.or = opGen('||');
exports.ternary = opGen('?:', 3);
exports.value = opGen('value', 1);
function variable(name) {
    return { type: 'var', valueType: 'Any', name: name };
}
exports.variable = variable;
function literal(name) {
    return { type: 'literal', valueType: 'Any', name: name };
}
exports.literal = literal;
function nullType() {
    return { type: 'Null', valueType: 'Null' };
}
exports.nullType = nullType;
function reference(base, prop) {
    return {
        type: 'ref',
        valueType: 'Any',
        base: base,
        accessor: prop
    };
}
exports.reference = reference;
var reIdentifier = /^[a-zA-Z_$][a-zA-Z0-9_]*$/;
function isIdentifierStringExp(exp) {
    return exp.type === 'String' && reIdentifier.test(exp.value);
}
exports.isIdentifierStringExp = isIdentifierStringExp;
// Shallow copy of an expression (so it can be modified and preserve
// immutability of the original expression).
function copyExp(exp) {
    exp = util.extend({}, exp);
    switch (exp.type) {
        case 'op':
        case 'call':
            var opExp = exp;
            opExp.args = util.copyArray(opExp.args);
            return opExp;
        case 'union':
            var unionExp = exp;
            unionExp.types = util.copyArray(unionExp.types);
            return unionExp;
        case 'generic':
            var genericExp = exp;
            genericExp.params = util.copyArray(genericExp.params);
            return genericExp;
        default:
            return exp;
    }
}
exports.copyExp = copyExp;
// Make a (shallow) copy of the base expression, setting (or removing) it's
// valueType.
//
// valueType is a string indicating the type of evaluating an expression (e.g.
// 'Snapshot') - used to know when type coercion is needed in the context
// of parent expressions.
function cast(base, valueType) {
    var result = copyExp(base);
    result.valueType = valueType;
    return result;
}
exports.cast = cast;
function call(ref, args) {
    if (args === void 0) { args = []; }
    return { type: 'call', valueType: 'Any', ref: ref, args: args };
}
exports.call = call;
// Return empty string if not a function.
function getFunctionName(exp) {
    if (exp.ref.type === 'ref') {
        return '';
    }
    return exp.ref.name;
}
exports.getFunctionName = getFunctionName;
// Return empty string if not a (simple) method call -- ref.fn()
function getMethodName(exp) {
    if (exp.ref.type === 'var') {
        return exp.ref.name;
    }
    if (exp.ref.type !== 'ref') {
        return '';
    }
    return getPropName(exp.ref);
}
exports.getMethodName = getMethodName;
function getPropName(ref) {
    if (ref.accessor.type !== 'String') {
        return '';
    }
    return ref.accessor.value;
}
exports.getPropName = getPropName;
// TODO: Type of function signature does not fail this declaration?
function builtin(fn) {
    return { type: 'builtin', valueType: 'Any', fn: fn };
}
exports.builtin = builtin;
function snapshotVariable(name) {
    return cast(variable(name), 'Snapshot');
}
exports.snapshotVariable = snapshotVariable;
function snapshotParent(base) {
    if (base.valueType !== 'Snapshot') {
        throw new Error(errors.typeMismatch + "expected Snapshot");
    }
    return cast(call(reference(cast(base, 'Any'), exports.string('parent'))), 'Snapshot');
}
exports.snapshotParent = snapshotParent;
function ensureValue(exp) {
    if (exp.valueType === 'Snapshot') {
        return snapshotValue(exp);
    }
    return exp;
}
exports.ensureValue = ensureValue;
// ref.val()
function snapshotValue(exp) {
    return call(reference(cast(exp, 'Any'), exports.string('val')));
}
exports.snapshotValue = snapshotValue;
// Ensure expression is a boolean (when used in a boolean context).
function ensureBoolean(exp) {
    exp = ensureValue(exp);
    if (isCall(exp, 'val')) {
        exp = exports.eq(exp, exports.boolean(true));
    }
    return exp;
}
exports.ensureBoolean = ensureBoolean;
function isCall(exp, methodName) {
    return exp.type === 'call' && exp.ref.type === 'ref' &&
        exp.ref.accessor.type === 'String' &&
        exp.ref.accessor.value === methodName;
}
exports.isCall = isCall;
// Return value generating function for a given Type.
function valueGen(typeName) {
    return function (val) {
        return {
            type: typeName,
            valueType: typeName,
            value: val // The (constant) value itself.
        };
    };
}
function regexp(pattern, modifiers) {
    if (modifiers === void 0) { modifiers = ""; }
    switch (modifiers) {
        case "":
        case "i":
            break;
        default:
            throw new Error("Unsupported RegExp modifier: " + modifiers);
    }
    return {
        type: 'RegExp',
        valueType: 'RegExp',
        value: pattern,
        modifiers: modifiers
    };
}
exports.regexp = regexp;
function cmpValues(v1, v2) {
    if (v1.type !== v2.type) {
        return false;
    }
    return v1.value === v2.value;
}
function isOp(opType, exp) {
    return exp.type === 'op' && exp.op === opType;
}
// Return a generating function to make an operator exp node.
function opGen(opType, arity) {
    if (arity === void 0) { arity = 2; }
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (args.length !== arity) {
            throw new Error("Operator has " + args.length +
                " arguments (expecting " + arity + ").");
        }
        return op(opType, args);
    };
}
exports.andArray = leftAssociateGen('&&', exports.boolean(true), exports.boolean(false));
exports.orArray = leftAssociateGen('||', exports.boolean(false), exports.boolean(true));
// Create an expression builder function which operates on arrays of values.
// Returns new expression like v1 op v2 op v3 ...
//
// - Any identityValue's in array input are ignored.
// - If zeroValue is found - just return zeroValue.
//
// Our function re-orders top-level op in array elements to the resulting
// expression is left-associating.  E.g.:
//
//    [a && b, c && d] => (((a && b) && c) && d)
//    (NOT (a && b) && (c && d))
function leftAssociateGen(opType, identityValue, zeroValue) {
    return function (a) {
        var i;
        function reducer(result, current) {
            if (result === undefined) {
                return current;
            }
            return op(opType, [result, current]);
        }
        // First flatten all top-level op values to one flat array.
        var flat = [];
        for (i = 0; i < a.length; i++) {
            flatten(opType, a[i], flat);
        }
        var result = [];
        for (i = 0; i < flat.length; i++) {
            // Remove identifyValues from array.
            if (cmpValues(flat[i], identityValue)) {
                continue;
            }
            // Just return zeroValue if found
            if (cmpValues(flat[i], zeroValue)) {
                return zeroValue;
            }
            result.push(flat[i]);
        }
        if (result.length === 0) {
            return identityValue;
        }
        // Return left-associative expression of opType.
        return result.reduce(reducer);
    };
}
// Flatten the top level tree of op into a single flat array of expressions.
function flatten(opType, exp, flat) {
    var i;
    if (flat === undefined) {
        flat = [];
    }
    if (!isOp(opType, exp)) {
        flat.push(exp);
        return flat;
    }
    for (i = 0; i < exp.args.length; i++) {
        flatten(opType, exp.args[i], flat);
    }
    return flat;
}
exports.flatten = flatten;
function op(opType, args) {
    return {
        type: 'op',
        valueType: 'Any',
        op: opType,
        args: args // Arguments to the operator Array<exp>
    };
}
exports.op = op;
// Warning: NOT an expression type!
function method(params, body) {
    return {
        params: params,
        body: body
    };
}
exports.method = method;
function typeType(typeName) {
    return { type: "type", valueType: "type", name: typeName };
}
exports.typeType = typeType;
function unionType(types) {
    return { type: "union", valueType: "type", types: types };
}
exports.unionType = unionType;
function genericType(typeName, params) {
    return { type: "generic", valueType: "type", name: typeName, params: params };
}
exports.genericType = genericType;
var Symbols = /** @class */ (function () {
    function Symbols() {
        this.functions = {};
        this.paths = [];
        this.schema = {};
    }
    Symbols.prototype.register = function (map, typeName, name, object) {
        if (map[name]) {
            logger.error("Duplicated " + typeName + " definition: " + name + ".");
        }
        else {
            map[name] = object;
        }
        return map[name];
    };
    Symbols.prototype.registerFunction = function (name, params, body) {
        return this.register(this.functions, 'functions', name, method(params, body));
    };
    Symbols.prototype.registerPath = function (template, isType, methods) {
        if (methods === void 0) { methods = {}; }
        isType = isType || typeType('Any');
        var p = {
            template: template.copy(),
            isType: isType,
            methods: methods
        };
        this.paths.push(p);
        return p;
    };
    Symbols.prototype.registerSchema = function (name, derivedFrom, properties, methods, params) {
        if (properties === void 0) { properties = {}; }
        if (methods === void 0) { methods = {}; }
        if (params === void 0) { params = []; }
        derivedFrom = derivedFrom || typeType(Object.keys(properties).length > 0 ? 'Object' : 'Any');
        var s = {
            derivedFrom: derivedFrom,
            properties: properties,
            methods: methods,
            params: params
        };
        return this.register(this.schema, 'schema', name, s);
    };
    Symbols.prototype.isDerivedFrom = function (type, ancestor) {
        var _this = this;
        if (ancestor === 'Any') {
            return true;
        }
        switch (type.type) {
            case 'type':
            case 'generic':
                var simpleType = type;
                if (simpleType.name === ancestor) {
                    return true;
                }
                if (simpleType.name === 'Any') {
                    return false;
                }
                var schema = this.schema[simpleType.name];
                if (!schema) {
                    return false;
                }
                return this.isDerivedFrom(schema.derivedFrom, ancestor);
            case 'union':
                return type.types
                    .map(function (subType) { return _this.isDerivedFrom(subType, ancestor); })
                    .reduce(util.or);
            default:
                throw new Error("Unknown type: " + type.type);
        }
    };
    return Symbols;
}());
exports.Symbols = Symbols;
var JS_OPS = {
    'value': { rep: "", p: 18 },
    'neg': { rep: "-", p: 15 },
    '!': { p: 15 },
    '*': { p: 14 },
    '/': { p: 14 },
    '%': { p: 14 },
    '+': { p: 13 },
    '-': { p: 13 },
    '<': { p: 11 },
    '<=': { p: 11 },
    '>': { p: 11 },
    '>=': { p: 11 },
    'in': { p: 11 },
    '==': { p: 10 },
    "!=": { p: 10 },
    '&&': { p: 6 },
    '||': { p: 5 },
    '?:': { p: 4 },
    ',': { p: 0 }
};
// From an AST, decode as an expression (string).
function decodeExpression(exp, outerPrecedence) {
    if (outerPrecedence === undefined) {
        outerPrecedence = 0;
    }
    var innerPrecedence = precedenceOf(exp);
    var result = '';
    switch (exp.type) {
        case 'Boolean':
        case 'Number':
            result = JSON.stringify(exp.value);
            break;
        case 'String':
            result = util.quoteString(exp.value);
            break;
        // RegExp assumed to be in pre-quoted format.
        case 'RegExp':
            var regexp_1 = exp;
            result = '/' + regexp_1.value + '/';
            if (regexp_1.modifiers !== '') {
                result += regexp_1.modifiers;
            }
            break;
        case 'Array':
            result = '[' + decodeArray(exp.value) + ']';
            break;
        case 'Null':
            result = 'null';
            break;
        case 'var':
        case 'literal':
            result = exp.name;
            break;
        case 'ref':
            var expRef = exp;
            if (isIdentifierStringExp(expRef.accessor)) {
                result = decodeExpression(expRef.base, innerPrecedence) + '.' + expRef.accessor.value;
            }
            else {
                result = decodeExpression(expRef.base, innerPrecedence) +
                    '[' + decodeExpression(expRef.accessor) + ']';
            }
            break;
        case 'call':
            var expCall = exp;
            result = decodeExpression(expCall.ref) + '(' + decodeArray(expCall.args) + ')';
            break;
        case 'builtin':
            result = decodeExpression(exp);
            break;
        case 'op':
            var expOp = exp;
            var rep = JS_OPS[expOp.op].rep === undefined ? expOp.op : JS_OPS[expOp.op].rep;
            if (expOp.args.length === 1) {
                result = rep + decodeExpression(expOp.args[0], innerPrecedence);
            }
            else if (expOp.args.length === 2) {
                result =
                    decodeExpression(expOp.args[0], innerPrecedence) +
                        ' ' + rep + ' ' +
                        // All ops are left associative - so nudge the innerPrecendence
                        // down on the right hand side to force () for right-associating
                        // operations.
                        decodeExpression(expOp.args[1], innerPrecedence + 1);
            }
            else if (expOp.args.length === 3) {
                result =
                    decodeExpression(expOp.args[0], innerPrecedence) + ' ? ' +
                        decodeExpression(expOp.args[1], innerPrecedence) + ' : ' +
                        decodeExpression(expOp.args[2], innerPrecedence);
            }
            break;
        case 'type':
            result = exp.name;
            break;
        case 'union':
            result = exp.types.map(decodeExpression).join(' | ');
            break;
        case 'generic':
            var genericType_1 = exp;
            return genericType_1.name + '<' + decodeArray(genericType_1.params) + '>';
        default:
            result = "***UNKNOWN TYPE*** (" + exp.type + ")";
            break;
    }
    if (innerPrecedence < outerPrecedence) {
        result = '(' + result + ')';
    }
    return result;
}
exports.decodeExpression = decodeExpression;
function decodeArray(args) {
    return args.map(decodeExpression).join(', ');
}
function precedenceOf(exp) {
    var result;
    switch (exp.type) {
        case 'op':
            result = JS_OPS[exp.op].p;
            break;
        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence
        // lists call as 17 and ref as 18 - but how could they be anything other than left to right?
        // http://www.scriptingmaster.com/javascript/operator-precedence.asp - agrees.
        case 'call':
            result = 18;
            break;
        case 'ref':
            result = 18;
            break;
        default:
            result = 19;
            break;
    }
    return result;
}

//# sourceMappingURL=data:application/json;charset=utf8;base64,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WUFDWixJQUFJLGFBQVcsR0FBb0IsR0FBRyxDQUFDO1lBQ3ZDLE9BQU8sYUFBVyxDQUFDLElBQUksR0FBRyxHQUFHLEdBQUcsV0FBVyxDQUFDLGFBQVcsQ0FBQyxNQUFNLENBQUMsR0FBRyxHQUFHLENBQUM7UUFFeEU7WUFDRSxNQUFNLEdBQUcsc0JBQXNCLEdBQUcsR0FBRyxDQUFDLElBQUksR0FBRyxHQUFHLENBQUM7WUFDakQsTUFBTTtLQUNQO0lBRUQsSUFBSSxlQUFlLEdBQUcsZUFBZSxFQUFFO1FBQ3JDLE1BQU0sR0FBRyxHQUFHLEdBQUcsTUFBTSxHQUFHLEdBQUcsQ0FBQztLQUM3QjtJQUVELE9BQU8sTUFBTSxDQUFDO0FBQ2hCLENBQUM7QUFyR0QsNENBcUdDO0FBRUQscUJBQXFCLElBQVc7SUFDOUIsT0FBTyxJQUFJLENBQUMsR0FBRyxDQUFDLGdCQUFnQixDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQy9DLENBQUM7QUFFRCxzQkFBc0IsR0FBUTtJQUM1QixJQUFJLE1BQWMsQ0FBQztJQUVuQixRQUFRLEdBQUcsQ0FBQyxJQUFJLEVBQUU7UUFDbEIsS0FBSyxJQUFJO1lBQ1AsTUFBTSxHQUFHLE1BQU0sQ0FBVSxHQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ3BDLE1BQU07UUFFUixrR0FBa0c7UUFDbEcsNEZBQTRGO1FBQzVGLDhFQUE4RTtRQUM5RSxLQUFLLE1BQU07WUFDVCxNQUFNLEdBQUcsRUFBRSxDQUFDO1lBQ1osTUFBTTtRQUNSLEtBQUssS0FBSztZQUNSLE1BQU0sR0FBRyxFQUFFLENBQUM7WUFDWixNQUFNO1FBQ1I7WUFDRSxNQUFNLEdBQUcsRUFBRSxDQUFDO1lBQ1osTUFBTTtLQUNQO0lBRUQsT0FBTyxNQUFNLENBQUM7QUFDaEIsQ0FBQyIsImZpbGUiOiJhc3QuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogQVNUIGJ1aWxkZXJzIGZvciBGaXJlYmFzZSBSdWxlcyBMYW5ndWFnZS5cbiAqXG4gKiBDb3B5cmlnaHQgMjAxNSBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuaW1wb3J0ICogYXMgdXRpbCBmcm9tICcuL3V0aWwnO1xuaW1wb3J0ICogYXMgbG9nZ2VyIGZyb20gJy4vbG9nZ2VyJztcblxudmFyIGVycm9ycyA9IHtcbiAgdHlwZU1pc21hdGNoOiBcIlVuZXhwZWN0ZWQgdHlwZTogXCIsXG4gIGR1cGxpY2F0ZVBhdGhQYXJ0OiBcIkEgcGF0aCBjb21wb25lbnQgbmFtZSBpcyBkdXBsaWNhdGVkOiBcIixcbn07XG5cbmV4cG9ydCB0eXBlIE9iamVjdCA9IHsgW3Byb3A6IHN0cmluZ106IGFueSB9O1xuXG5leHBvcnQgaW50ZXJmYWNlIEV4cCB7XG4gIHR5cGU6IHN0cmluZztcbiAgdmFsdWVUeXBlOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRXhwVmFsdWUgZXh0ZW5kcyBFeHAge1xuICB2YWx1ZTogYW55O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJlZ0V4cFZhbHVlIGV4dGVuZHMgRXhwVmFsdWUge1xuICBtb2RpZmllcnM6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBFeHBOdWxsIGV4dGVuZHMgRXhwIHtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBFeHBPcCBleHRlbmRzIEV4cCB7XG4gIG9wOiBzdHJpbmc7XG4gIGFyZ3M6IEV4cFtdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEV4cFZhcmlhYmxlIGV4dGVuZHMgRXhwIHtcbiAgbmFtZTogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEV4cExpdGVyYWwgZXh0ZW5kcyBFeHAge1xuICBuYW1lOiBzdHJpbmc7XG59XG5cbi8vIGJhc2VbYWNjZXNzb3JdXG5leHBvcnQgaW50ZXJmYWNlIEV4cFJlZmVyZW5jZSBleHRlbmRzIEV4cCB7XG4gIGJhc2U6IEV4cDtcbiAgYWNjZXNzb3I6IEV4cDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBFeHBDYWxsIGV4dGVuZHMgRXhwIHtcbiAgcmVmOiBFeHBSZWZlcmVuY2UgfCBFeHBWYXJpYWJsZTtcbiAgYXJnczogRXhwW107XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUGFyYW1zIHsgW25hbWU6IHN0cmluZ106IEV4cDsgfTtcblxuZXhwb3J0IHR5cGUgQnVpbHRpbkZ1bmN0aW9uID0gKGFyZ3M6IEV4cFtdLCBwYXJhbXM6IFBhcmFtcykgPT4gRXhwO1xuXG5leHBvcnQgaW50ZXJmYWNlIEV4cEJ1aWx0aW4gZXh0ZW5kcyBFeHAge1xuICBmbjogQnVpbHRpbkZ1bmN0aW9uO1xufVxuXG5leHBvcnQgdHlwZSBFeHBUeXBlID0gRXhwU2ltcGxlVHlwZSB8IEV4cFVuaW9uVHlwZSB8IEV4cEdlbmVyaWNUeXBlO1xuZXhwb3J0IGludGVyZmFjZSBUeXBlUGFyYW1zIHsgW25hbWU6IHN0cmluZ106IEV4cFR5cGU7IH07XG5cbi8vIFNpbXBsZSBUeXBlIChyZWZlcmVuY2UpXG5leHBvcnQgaW50ZXJmYWNlIEV4cFNpbXBsZVR5cGUgZXh0ZW5kcyBFeHAge1xuICBuYW1lOiBzdHJpbmc7XG59XG5cbi8vIFVuaW9uIFR5cGU6IFR5cGUxIHwgVHlwZTIgfCAuLi5cbmV4cG9ydCBpbnRlcmZhY2UgRXhwVW5pb25UeXBlIGV4dGVuZHMgRXhwIHtcbiAgdHlwZXM6IEV4cFR5cGVbXTtcbn1cblxuLy8gR2VuZXJpYyBUeXBlIChyZWZlcmVuY2UpOiBUeXBlPFR5cGUxLCBUeXBlMiwgLi4uPlxuZXhwb3J0IGludGVyZmFjZSBFeHBHZW5lcmljVHlwZSBleHRlbmRzIEV4cCB7XG4gIG5hbWU6IHN0cmluZztcbiAgcGFyYW1zOiBFeHBUeXBlW107XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTWV0aG9kIHtcbiAgcGFyYW1zOiBzdHJpbmdbXTtcbiAgYm9keTogRXhwO1xufVxuXG5leHBvcnQgY2xhc3MgUGF0aFBhcnQge1xuICBsYWJlbDogc3RyaW5nO1xuICB2YXJpYWJsZTogc3RyaW5nO1xuXG4gIC8vIFwibGFiZWxcIiwgdW5kZWZpbmVkIC0gc3RhdGljIHBhdGggcGFydFxuICAvLyBcIiRsYWJlbFwiLCBYIC0gdmFyaWFibGUgcGF0aCBwYXJ0XG4gIC8vIFgsICF1bmRlZmluZWQgLSB2YXJpYWJsZSBwYXRoIHBhcnRcbiAgY29uc3RydWN0b3IobGFiZWw6IHN0cmluZywgdmFyaWFibGU/OiBzdHJpbmcpIHtcbiAgICBpZiAobGFiZWxbMF0gPT09ICckJyAmJiB2YXJpYWJsZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXJpYWJsZSA9IGxhYmVsO1xuICAgIH1cbiAgICBpZiAodmFyaWFibGUgJiYgbGFiZWxbMF0gIT09ICckJykge1xuICAgICAgbGFiZWwgPSAnJCcgKyBsYWJlbDtcbiAgICB9XG4gICAgdGhpcy5sYWJlbCA9IGxhYmVsO1xuICAgIHRoaXMudmFyaWFibGUgPSA8c3RyaW5nPiB2YXJpYWJsZTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgUGF0aFRlbXBsYXRlIHtcbiAgcGFydHM6IFBhdGhQYXJ0W107XG5cbiAgY29uc3RydWN0b3IocGFydHMgPSA8KHN0cmluZyB8IFBhdGhQYXJ0KVtdPiBbXSkge1xuICAgIHRoaXMucGFydHMgPSA8UGF0aFBhcnRbXT4gcGFydHMubWFwKChwYXJ0KSA9PiB7XG4gICAgICBpZiAodXRpbC5pc1R5cGUocGFydCwgJ3N0cmluZycpKSB7XG4gICAgICAgIHJldHVybiBuZXcgUGF0aFBhcnQoPHN0cmluZz4gcGFydCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gPFBhdGhQYXJ0PiBwYXJ0O1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgY29weSgpIHtcbiAgICBsZXQgcmVzdWx0ID0gbmV3IFBhdGhUZW1wbGF0ZSgpO1xuICAgIHJlc3VsdC5wdXNoKHRoaXMpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBnZXRMYWJlbHMoKTogc3RyaW5nW10ge1xuICAgIHJldHVybiB0aGlzLnBhcnRzLm1hcCgocGFydCkgPT4gcGFydC5sYWJlbCk7XG4gIH1cblxuICAvLyBNYXBwaW5nIGZyb20gdmFyaWFibGVzIHRvIEpTT04gbGFiZWxzXG4gIGdldFNjb3BlKCk6IFBhcmFtcyB7XG4gICAgbGV0IHJlc3VsdCA9IDxQYXJhbXM+IHt9O1xuICAgIHRoaXMucGFydHMuZm9yRWFjaCgocGFydCkgPT4ge1xuICAgICAgaWYgKHBhcnQudmFyaWFibGUpIHtcbiAgICAgICAgaWYgKHJlc3VsdFtwYXJ0LnZhcmlhYmxlXSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMuZHVwbGljYXRlUGF0aFBhcnQgKyBwYXJ0LnZhcmlhYmxlKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHRbcGFydC52YXJpYWJsZV0gPSBsaXRlcmFsKHBhcnQubGFiZWwpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBwdXNoKHRlbXA6IFBhdGhUZW1wbGF0ZSkge1xuICAgIHV0aWwuZXh0ZW5kQXJyYXkodGhpcy5wYXJ0cywgdGVtcC5wYXJ0cyk7XG4gIH1cblxuICBwb3AodGVtcDogUGF0aFRlbXBsYXRlKSB7XG4gICAgdGVtcC5wYXJ0cy5mb3JFYWNoKChwYXJ0KSA9PiB7XG4gICAgICB0aGlzLnBhcnRzLnBvcCgpO1xuICAgIH0pO1xuICB9XG5cbiAgbGVuZ3RoKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMucGFydHMubGVuZ3RoO1xuICB9XG5cbiAgZ2V0UGFydChpOiBudW1iZXIpOiBQYXRoUGFydCB7XG4gICAgaWYgKGkgPiB0aGlzLnBhcnRzLmxlbmd0aCB8fCBpIDwgLXRoaXMucGFydHMubGVuZ3RoKSB7XG4gICAgICBsZXQgbCA9IHRoaXMucGFydHMubGVuZ3RoO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGF0aCByZWZlcmVuY2Ugb3V0IG9mIGJvdW5kczogXCIgKyBpICtcbiAgICAgICAgICAgICAgICAgICAgICBcIiBbXCIgKyAtbCArIFwiIC4uIFwiICsgbCArIFwiXVwiKTtcbiAgICB9XG4gICAgaWYgKGkgPCAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJ0c1t0aGlzLnBhcnRzLmxlbmd0aCArIGldO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wYXJ0c1tpXTtcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFBhdGgge1xuICB0ZW1wbGF0ZTogUGF0aFRlbXBsYXRlO1xuICBpc1R5cGU6IEV4cFR5cGU7XG4gIG1ldGhvZHM6IHsgW25hbWU6IHN0cmluZ106IE1ldGhvZCB9O1xufTtcblxuZXhwb3J0IGNsYXNzIFNjaGVtYSB7XG4gIGRlcml2ZWRGcm9tOiBFeHBUeXBlO1xuICBwcm9wZXJ0aWVzOiBUeXBlUGFyYW1zO1xuICBtZXRob2RzOiB7IFtuYW1lOiBzdHJpbmddOiBNZXRob2QgfTtcblxuICAvLyBHZW5lcmljIHBhcmFtZXRlcnMgLSBpZiBhIEdlbmVyaWMgc2NoZW1hXG4gIHBhcmFtcz86IHN0cmluZ1tdO1xuICBnZXRWYWxpZGF0b3I/OiAocGFyYW1zOiBFeHBbXSkgPT4gT2JqZWN0O1xuXG4gIHN0YXRpYyBpc0dlbmVyaWMoc2NoZW1hOiBTY2hlbWEpOiBib29sZWFuIHtcbiAgICByZXR1cm4gc2NoZW1hLnBhcmFtcyAhPT0gdW5kZWZpbmVkICYmIHNjaGVtYS5wYXJhbXMubGVuZ3RoID4gMDtcbiAgfVxufTtcblxuZXhwb3J0IHZhciBzdHJpbmc6ICh2OiBzdHJpbmcpID0+IEV4cFZhbHVlID0gdmFsdWVHZW4oJ1N0cmluZycpO1xuZXhwb3J0IHZhciBib29sZWFuOiAodjogYm9vbGVhbikgPT4gRXhwVmFsdWUgPSB2YWx1ZUdlbignQm9vbGVhbicpO1xuZXhwb3J0IHZhciBudW1iZXI6ICh2OiBudW1iZXIpID0+IEV4cFZhbHVlID0gdmFsdWVHZW4oJ051bWJlcicpO1xuZXhwb3J0IHZhciBhcnJheTogKHY6IEFycmF5PGFueT4pID0+IEV4cFZhbHVlID0gdmFsdWVHZW4oJ0FycmF5Jyk7XG5cbmV4cG9ydCB2YXIgbmVnID0gb3BHZW4oJ25lZycsIDEpO1xuZXhwb3J0IHZhciBub3QgPSBvcEdlbignIScsIDEpO1xuZXhwb3J0IHZhciBtdWx0ID0gb3BHZW4oJyonKTtcbmV4cG9ydCB2YXIgZGl2ID0gb3BHZW4oJy8nKTtcbmV4cG9ydCB2YXIgbW9kID0gb3BHZW4oJyUnKTtcbmV4cG9ydCB2YXIgYWRkID0gb3BHZW4oJysnKTtcbmV4cG9ydCB2YXIgc3ViID0gb3BHZW4oJy0nKTtcbmV4cG9ydCB2YXIgZXEgPSBvcEdlbignPT0nKTtcbmV4cG9ydCB2YXIgbHQgPSBvcEdlbignPCcpO1xuZXhwb3J0IHZhciBsdGUgPSBvcEdlbignPD0nKTtcbmV4cG9ydCB2YXIgZ3QgPSBvcEdlbignPicpO1xuZXhwb3J0IHZhciBndGUgPSBvcEdlbignPj0nKTtcbmV4cG9ydCB2YXIgbmUgPSBvcEdlbignIT0nKTtcbmV4cG9ydCB2YXIgYW5kID0gb3BHZW4oJyYmJyk7XG5leHBvcnQgdmFyIG9yID0gb3BHZW4oJ3x8Jyk7XG5leHBvcnQgdmFyIHRlcm5hcnkgPSBvcEdlbignPzonLCAzKTtcbmV4cG9ydCB2YXIgdmFsdWUgPSBvcEdlbigndmFsdWUnLCAxKTtcblxuZXhwb3J0IGZ1bmN0aW9uIHZhcmlhYmxlKG5hbWU6IHN0cmluZyk6IEV4cFZhcmlhYmxlIHtcbiAgcmV0dXJuIHsgdHlwZTogJ3ZhcicsIHZhbHVlVHlwZTogJ0FueScsIG5hbWU6IG5hbWUgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxpdGVyYWwobmFtZTogc3RyaW5nKTogRXhwTGl0ZXJhbCB7XG4gIHJldHVybiB7IHR5cGU6ICdsaXRlcmFsJywgdmFsdWVUeXBlOiAnQW55JywgbmFtZTogbmFtZSB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbnVsbFR5cGUoKTogRXhwTnVsbCB7XG4gIHJldHVybiB7IHR5cGU6ICdOdWxsJywgdmFsdWVUeXBlOiAnTnVsbCcgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlZmVyZW5jZShiYXNlOiBFeHAsIHByb3A6IEV4cCk6IEV4cFJlZmVyZW5jZSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ3JlZicsXG4gICAgdmFsdWVUeXBlOiAnQW55JyxcbiAgICBiYXNlOiBiYXNlLFxuICAgIGFjY2Vzc29yOiBwcm9wXG4gIH07XG59XG5cbmxldCByZUlkZW50aWZpZXIgPSAvXlthLXpBLVpfJF1bYS16QS1aMC05X10qJC87XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0lkZW50aWZpZXJTdHJpbmdFeHAoZXhwOiBFeHApIHtcbiAgcmV0dXJuIGV4cC50eXBlID09PSAnU3RyaW5nJyAmJiByZUlkZW50aWZpZXIudGVzdCgoPEV4cFZhbHVlPiBleHApLnZhbHVlKTtcbn1cblxuLy8gU2hhbGxvdyBjb3B5IG9mIGFuIGV4cHJlc3Npb24gKHNvIGl0IGNhbiBiZSBtb2RpZmllZCBhbmQgcHJlc2VydmVcbi8vIGltbXV0YWJpbGl0eSBvZiB0aGUgb3JpZ2luYWwgZXhwcmVzc2lvbikuXG5leHBvcnQgZnVuY3Rpb24gY29weUV4cChleHA6IEV4cCk6IEV4cCB7XG4gIGV4cCA9IDxFeHA+IHV0aWwuZXh0ZW5kKHt9LCBleHApO1xuICBzd2l0Y2ggKGV4cC50eXBlKSB7XG4gIGNhc2UgJ29wJzpcbiAgY2FzZSAnY2FsbCc6XG4gICAgbGV0IG9wRXhwID0gPEV4cE9wPiBleHA7XG4gICAgb3BFeHAuYXJncyA9IHV0aWwuY29weUFycmF5KG9wRXhwLmFyZ3MpO1xuICAgIHJldHVybiBvcEV4cDtcblxuICBjYXNlICd1bmlvbic6XG4gICAgbGV0IHVuaW9uRXhwID0gPEV4cFVuaW9uVHlwZT4gZXhwO1xuICAgIHVuaW9uRXhwLnR5cGVzID0gdXRpbC5jb3B5QXJyYXkodW5pb25FeHAudHlwZXMpO1xuICAgIHJldHVybiB1bmlvbkV4cDtcblxuICBjYXNlICdnZW5lcmljJzpcbiAgICBsZXQgZ2VuZXJpY0V4cCA9IDxFeHBHZW5lcmljVHlwZT4gZXhwO1xuICAgIGdlbmVyaWNFeHAucGFyYW1zID0gdXRpbC5jb3B5QXJyYXkoZ2VuZXJpY0V4cC5wYXJhbXMpO1xuICAgIHJldHVybiBnZW5lcmljRXhwO1xuXG4gIGRlZmF1bHQ6XG4gICAgIHJldHVybiBleHA7XG4gIH1cbn1cblxuLy8gTWFrZSBhIChzaGFsbG93KSBjb3B5IG9mIHRoZSBiYXNlIGV4cHJlc3Npb24sIHNldHRpbmcgKG9yIHJlbW92aW5nKSBpdCdzXG4vLyB2YWx1ZVR5cGUuXG4vL1xuLy8gdmFsdWVUeXBlIGlzIGEgc3RyaW5nIGluZGljYXRpbmcgdGhlIHR5cGUgb2YgZXZhbHVhdGluZyBhbiBleHByZXNzaW9uIChlLmcuXG4vLyAnU25hcHNob3QnKSAtIHVzZWQgdG8ga25vdyB3aGVuIHR5cGUgY29lcmNpb24gaXMgbmVlZGVkIGluIHRoZSBjb250ZXh0XG4vLyBvZiBwYXJlbnQgZXhwcmVzc2lvbnMuXG5leHBvcnQgZnVuY3Rpb24gY2FzdChiYXNlOiBFeHAsIHZhbHVlVHlwZTogc3RyaW5nKTogRXhwIHtcbiAgdmFyIHJlc3VsdCA9IGNvcHlFeHAoYmFzZSk7XG4gIHJlc3VsdC52YWx1ZVR5cGUgPSB2YWx1ZVR5cGU7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjYWxsKHJlZjogRXhwUmVmZXJlbmNlIHwgRXhwVmFyaWFibGUsIGFyZ3M6IEV4cFtdPSBbXSk6IEV4cENhbGwge1xuICByZXR1cm4geyB0eXBlOiAnY2FsbCcsIHZhbHVlVHlwZTogJ0FueScsIHJlZjogcmVmLCBhcmdzOiBhcmdzIH07XG59XG5cbi8vIFJldHVybiBlbXB0eSBzdHJpbmcgaWYgbm90IGEgZnVuY3Rpb24uXG5leHBvcnQgZnVuY3Rpb24gZ2V0RnVuY3Rpb25OYW1lKGV4cDogRXhwQ2FsbCk6IHN0cmluZyB7XG4gIGlmIChleHAucmVmLnR5cGUgPT09ICdyZWYnKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIHJldHVybiAoPEV4cFZhcmlhYmxlPiBleHAucmVmKS5uYW1lO1xufVxuXG4vLyBSZXR1cm4gZW1wdHkgc3RyaW5nIGlmIG5vdCBhIChzaW1wbGUpIG1ldGhvZCBjYWxsIC0tIHJlZi5mbigpXG5leHBvcnQgZnVuY3Rpb24gZ2V0TWV0aG9kTmFtZShleHA6IEV4cENhbGwpOiBzdHJpbmcge1xuICBpZiAoZXhwLnJlZi50eXBlID09PSAndmFyJykge1xuICAgIHJldHVybiAoPEV4cFZhcmlhYmxlPiBleHAucmVmKS5uYW1lO1xuICB9XG4gIGlmIChleHAucmVmLnR5cGUgIT09ICdyZWYnKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIHJldHVybiBnZXRQcm9wTmFtZSg8RXhwUmVmZXJlbmNlPiBleHAucmVmKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFByb3BOYW1lKHJlZjogRXhwUmVmZXJlbmNlKTogc3RyaW5nIHtcbiAgaWYgKHJlZi5hY2Nlc3Nvci50eXBlICE9PSAnU3RyaW5nJykge1xuICAgIHJldHVybiAnJztcbiAgfVxuICByZXR1cm4gKDxFeHBWYWx1ZT4gcmVmLmFjY2Vzc29yKS52YWx1ZTtcbn1cblxuLy8gVE9ETzogVHlwZSBvZiBmdW5jdGlvbiBzaWduYXR1cmUgZG9lcyBub3QgZmFpbCB0aGlzIGRlY2xhcmF0aW9uP1xuZXhwb3J0IGZ1bmN0aW9uIGJ1aWx0aW4oZm46IEJ1aWx0aW5GdW5jdGlvbik6IEV4cEJ1aWx0aW4ge1xuICByZXR1cm4geyB0eXBlOiAnYnVpbHRpbicsIHZhbHVlVHlwZTogJ0FueScsIGZuOiBmbiB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc25hcHNob3RWYXJpYWJsZShuYW1lOiBzdHJpbmcpOiBFeHBWYXJpYWJsZSB7XG4gIHJldHVybiA8RXhwVmFyaWFibGU+IGNhc3QodmFyaWFibGUobmFtZSksICdTbmFwc2hvdCcpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc25hcHNob3RQYXJlbnQoYmFzZTogRXhwKTogRXhwIHtcbiAgaWYgKGJhc2UudmFsdWVUeXBlICE9PSAnU25hcHNob3QnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGVycm9ycy50eXBlTWlzbWF0Y2ggKyBcImV4cGVjdGVkIFNuYXBzaG90XCIpO1xuICB9XG4gIHJldHVybiBjYXN0KGNhbGwocmVmZXJlbmNlKGNhc3QoYmFzZSwgJ0FueScpLCBzdHJpbmcoJ3BhcmVudCcpKSksXG4gICAgICAgICAgICAgICdTbmFwc2hvdCcpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZW5zdXJlVmFsdWUoZXhwOiBFeHApOiBFeHAge1xuICBpZiAoZXhwLnZhbHVlVHlwZSA9PT0gJ1NuYXBzaG90Jykge1xuICAgIHJldHVybiBzbmFwc2hvdFZhbHVlKGV4cCk7XG4gIH1cbiAgcmV0dXJuIGV4cDtcbn1cblxuLy8gcmVmLnZhbCgpXG5leHBvcnQgZnVuY3Rpb24gc25hcHNob3RWYWx1ZShleHA6IEV4cCk6IEV4cENhbGwge1xuICByZXR1cm4gY2FsbChyZWZlcmVuY2UoY2FzdChleHAsICdBbnknKSwgc3RyaW5nKCd2YWwnKSkpO1xufVxuXG4vLyBFbnN1cmUgZXhwcmVzc2lvbiBpcyBhIGJvb2xlYW4gKHdoZW4gdXNlZCBpbiBhIGJvb2xlYW4gY29udGV4dCkuXG5leHBvcnQgZnVuY3Rpb24gZW5zdXJlQm9vbGVhbihleHA6IEV4cCk6IEV4cCB7XG4gIGV4cCA9IGVuc3VyZVZhbHVlKGV4cCk7XG4gIGlmIChpc0NhbGwoZXhwLCAndmFsJykpIHtcbiAgICBleHAgPSBlcShleHAsIGJvb2xlYW4odHJ1ZSkpO1xuICB9XG4gIHJldHVybiBleHA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0NhbGwoZXhwOiBFeHAsIG1ldGhvZE5hbWU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICByZXR1cm4gZXhwLnR5cGUgPT09ICdjYWxsJyAmJiAoPEV4cENhbGw+IGV4cCkucmVmLnR5cGUgPT09ICdyZWYnICYmXG4gICAgKDxFeHBSZWZlcmVuY2U+ICg8RXhwQ2FsbD4gZXhwKS5yZWYpLmFjY2Vzc29yLnR5cGUgPT09ICdTdHJpbmcnICYmXG4gICAgKDxFeHBWYWx1ZT4gKDxFeHBSZWZlcmVuY2U+ICg8RXhwQ2FsbD4gZXhwKS5yZWYpLmFjY2Vzc29yKS52YWx1ZSA9PT0gbWV0aG9kTmFtZTtcbn1cblxuLy8gUmV0dXJuIHZhbHVlIGdlbmVyYXRpbmcgZnVuY3Rpb24gZm9yIGEgZ2l2ZW4gVHlwZS5cbmZ1bmN0aW9uIHZhbHVlR2VuKHR5cGVOYW1lOiBzdHJpbmcpOiAoKHZhbDogYW55KSA9PiBFeHBWYWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24odmFsKTogRXhwVmFsdWUge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiB0eXBlTmFtZSwgICAgICAvLyBFeHAgdHlwZSBpZGVudGlmeWluZyBhIGNvbnN0YW50IHZhbHVlIG9mIHRoaXMgVHlwZS5cbiAgICAgIHZhbHVlVHlwZTogdHlwZU5hbWUsIC8vIFRoZSB0eXBlIG9mIHRoZSByZXN1bHQgb2YgZXZhbHVhdGluZyB0aGlzIGV4cHJlc3Npb24uXG4gICAgICB2YWx1ZTogdmFsICAgICAgICAgICAvLyBUaGUgKGNvbnN0YW50KSB2YWx1ZSBpdHNlbGYuXG4gICAgfTtcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlZ2V4cChwYXR0ZXJuOiBzdHJpbmcsIG1vZGlmaWVycyA9IFwiXCIpOiBSZWdFeHBWYWx1ZSB7XG4gIHN3aXRjaCAobW9kaWZpZXJzKSB7XG4gIGNhc2UgXCJcIjpcbiAgY2FzZSBcImlcIjpcbiAgICBicmVhaztcbiAgZGVmYXVsdDpcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBSZWdFeHAgbW9kaWZpZXI6IFwiICsgbW9kaWZpZXJzKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHR5cGU6ICdSZWdFeHAnLFxuICAgIHZhbHVlVHlwZTogJ1JlZ0V4cCcsXG4gICAgdmFsdWU6IHBhdHRlcm4sXG4gICAgbW9kaWZpZXJzOiBtb2RpZmllcnNcbiAgfTtcbn1cblxuZnVuY3Rpb24gY21wVmFsdWVzKHYxOiBFeHAsIHYyOiBFeHBWYWx1ZSk6IGJvb2xlYW4ge1xuICBpZiAodjEudHlwZSAhPT0gdjIudHlwZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gKDxFeHBWYWx1ZT4gdjEpLnZhbHVlID09PSB2Mi52YWx1ZTtcbn1cblxuZnVuY3Rpb24gaXNPcChvcFR5cGU6IHN0cmluZywgZXhwOiBFeHApOiBib29sZWFuIHtcbiAgcmV0dXJuIGV4cC50eXBlID09PSAnb3AnICYmICg8RXhwT3A+IGV4cCkub3AgPT09IG9wVHlwZTtcbn1cblxuLy8gUmV0dXJuIGEgZ2VuZXJhdGluZyBmdW5jdGlvbiB0byBtYWtlIGFuIG9wZXJhdG9yIGV4cCBub2RlLlxuZnVuY3Rpb24gb3BHZW4ob3BUeXBlOiBzdHJpbmcsIGFyaXR5OiBudW1iZXIgPSAyKTogKCguLi5hcmdzOiBFeHBbXSkgPT4gRXhwT3ApIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKC4uLmFyZ3MpOiBFeHBPcCB7XG4gICAgaWYgKGFyZ3MubGVuZ3RoICE9PSBhcml0eSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT3BlcmF0b3IgaGFzIFwiICsgYXJncy5sZW5ndGggK1xuICAgICAgICAgICAgICAgICAgICAgIFwiIGFyZ3VtZW50cyAoZXhwZWN0aW5nIFwiICsgYXJpdHkgKyBcIikuXCIpO1xuICAgIH1cbiAgICByZXR1cm4gb3Aob3BUeXBlLCBhcmdzKTtcbiAgfTtcbn1cblxuZXhwb3J0IHZhciBhbmRBcnJheSA9IGxlZnRBc3NvY2lhdGVHZW4oJyYmJywgYm9vbGVhbih0cnVlKSwgYm9vbGVhbihmYWxzZSkpO1xuZXhwb3J0IHZhciBvckFycmF5ID0gbGVmdEFzc29jaWF0ZUdlbignfHwnLCBib29sZWFuKGZhbHNlKSwgYm9vbGVhbih0cnVlKSk7XG5cbi8vIENyZWF0ZSBhbiBleHByZXNzaW9uIGJ1aWxkZXIgZnVuY3Rpb24gd2hpY2ggb3BlcmF0ZXMgb24gYXJyYXlzIG9mIHZhbHVlcy5cbi8vIFJldHVybnMgbmV3IGV4cHJlc3Npb24gbGlrZSB2MSBvcCB2MiBvcCB2MyAuLi5cbi8vXG4vLyAtIEFueSBpZGVudGl0eVZhbHVlJ3MgaW4gYXJyYXkgaW5wdXQgYXJlIGlnbm9yZWQuXG4vLyAtIElmIHplcm9WYWx1ZSBpcyBmb3VuZCAtIGp1c3QgcmV0dXJuIHplcm9WYWx1ZS5cbi8vXG4vLyBPdXIgZnVuY3Rpb24gcmUtb3JkZXJzIHRvcC1sZXZlbCBvcCBpbiBhcnJheSBlbGVtZW50cyB0byB0aGUgcmVzdWx0aW5nXG4vLyBleHByZXNzaW9uIGlzIGxlZnQtYXNzb2NpYXRpbmcuICBFLmcuOlxuLy9cbi8vICAgIFthICYmIGIsIGMgJiYgZF0gPT4gKCgoYSAmJiBiKSAmJiBjKSAmJiBkKVxuLy8gICAgKE5PVCAoYSAmJiBiKSAmJiAoYyAmJiBkKSlcbmZ1bmN0aW9uIGxlZnRBc3NvY2lhdGVHZW4ob3BUeXBlOiBzdHJpbmcsIGlkZW50aXR5VmFsdWU6IEV4cFZhbHVlLCB6ZXJvVmFsdWU6IEV4cFZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbihhOiBFeHBbXSk6IEV4cCB7XG4gICAgdmFyIGk6IG51bWJlcjtcblxuICAgIGZ1bmN0aW9uIHJlZHVjZXIocmVzdWx0OiBFeHAsIGN1cnJlbnQ6IEV4cCkge1xuICAgICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBjdXJyZW50O1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9wKG9wVHlwZSwgW3Jlc3VsdCwgY3VycmVudF0pO1xuICAgIH1cblxuICAgIC8vIEZpcnN0IGZsYXR0ZW4gYWxsIHRvcC1sZXZlbCBvcCB2YWx1ZXMgdG8gb25lIGZsYXQgYXJyYXkuXG4gICAgdmFyIGZsYXQgPSA8RXhwW10+W107XG4gICAgZm9yIChpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGZsYXR0ZW4ob3BUeXBlLCBhW2ldLCBmbGF0KTtcbiAgICB9XG5cbiAgICB2YXIgcmVzdWx0ID0gPEV4cFtdPltdO1xuICAgIGZvciAoaSA9IDA7IGkgPCBmbGF0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyBSZW1vdmUgaWRlbnRpZnlWYWx1ZXMgZnJvbSBhcnJheS5cbiAgICAgIGlmIChjbXBWYWx1ZXMoZmxhdFtpXSwgaWRlbnRpdHlWYWx1ZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICAvLyBKdXN0IHJldHVybiB6ZXJvVmFsdWUgaWYgZm91bmRcbiAgICAgIGlmIChjbXBWYWx1ZXMoZmxhdFtpXSwgemVyb1ZhbHVlKSkge1xuICAgICAgICByZXR1cm4gemVyb1ZhbHVlO1xuICAgICAgfVxuICAgICAgcmVzdWx0LnB1c2goZmxhdFtpXSk7XG4gICAgfVxuXG4gICAgaWYgKHJlc3VsdC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBpZGVudGl0eVZhbHVlO1xuICAgIH1cblxuICAgIC8vIFJldHVybiBsZWZ0LWFzc29jaWF0aXZlIGV4cHJlc3Npb24gb2Ygb3BUeXBlLlxuICAgIHJldHVybiByZXN1bHQucmVkdWNlKHJlZHVjZXIpO1xuICB9O1xufVxuXG4vLyBGbGF0dGVuIHRoZSB0b3AgbGV2ZWwgdHJlZSBvZiBvcCBpbnRvIGEgc2luZ2xlIGZsYXQgYXJyYXkgb2YgZXhwcmVzc2lvbnMuXG5leHBvcnQgZnVuY3Rpb24gZmxhdHRlbihvcFR5cGU6IHN0cmluZywgZXhwOiBFeHAsIGZsYXQ/OiBFeHBbXSk6IEV4cFtdIHtcbiAgdmFyIGk6IG51bWJlcjtcblxuICBpZiAoZmxhdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZmxhdCA9IFtdO1xuICB9XG5cbiAgaWYgKCFpc09wKG9wVHlwZSwgZXhwKSkge1xuICAgIGZsYXQucHVzaChleHApO1xuICAgIHJldHVybiBmbGF0O1xuICB9XG5cbiAgZm9yIChpID0gMDsgaSA8ICg8RXhwT3A+IGV4cCkuYXJncy5sZW5ndGg7IGkrKykge1xuICAgIGZsYXR0ZW4ob3BUeXBlLCAoPEV4cE9wPiBleHApLmFyZ3NbaV0sIGZsYXQpO1xuICB9XG5cbiAgcmV0dXJuIGZsYXQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBvcChvcFR5cGU6IHN0cmluZywgYXJnczogRXhwW10pOiBFeHBPcCB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ29wJywgICAgIC8vIFRoaXMgaXMgKG11bHRpLWFyZ3VtZW50KSBvcGVyYXRvci5cbiAgICB2YWx1ZVR5cGU6ICdBbnknLFxuICAgIG9wOiBvcFR5cGUsICAgICAvLyBUaGUgb3BlcmF0b3IgKHN0cmluZywgZS5nLiAnKycpLlxuICAgIGFyZ3M6IGFyZ3MgICAgICAvLyBBcmd1bWVudHMgdG8gdGhlIG9wZXJhdG9yIEFycmF5PGV4cD5cbiAgfTtcbn1cblxuLy8gV2FybmluZzogTk9UIGFuIGV4cHJlc3Npb24gdHlwZSFcbmV4cG9ydCBmdW5jdGlvbiBtZXRob2QocGFyYW1zOiBzdHJpbmdbXSwgYm9keTogRXhwKTogTWV0aG9kIHtcbiAgcmV0dXJuIHtcbiAgICBwYXJhbXM6IHBhcmFtcyxcbiAgICBib2R5OiBib2R5XG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0eXBlVHlwZSh0eXBlTmFtZTogc3RyaW5nKTogRXhwU2ltcGxlVHlwZSB7XG4gIHJldHVybiB7IHR5cGU6IFwidHlwZVwiLCB2YWx1ZVR5cGU6IFwidHlwZVwiLCBuYW1lOiB0eXBlTmFtZSB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdW5pb25UeXBlKHR5cGVzOiBFeHBUeXBlW10pOiBFeHBVbmlvblR5cGUge1xuICByZXR1cm4geyB0eXBlOiBcInVuaW9uXCIsIHZhbHVlVHlwZTogXCJ0eXBlXCIsIHR5cGVzOiB0eXBlcyB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJpY1R5cGUodHlwZU5hbWU6IHN0cmluZywgcGFyYW1zOiBFeHBUeXBlW10pOiBFeHBHZW5lcmljVHlwZSB7XG4gIHJldHVybiB7IHR5cGU6IFwiZ2VuZXJpY1wiLCB2YWx1ZVR5cGU6IFwidHlwZVwiLCBuYW1lOiB0eXBlTmFtZSwgcGFyYW1zOiBwYXJhbXMgfTtcbn1cblxuZXhwb3J0IGNsYXNzIFN5bWJvbHMge1xuICBmdW5jdGlvbnM6IHsgW25hbWU6IHN0cmluZ106IE1ldGhvZCB9O1xuICBwYXRoczogUGF0aFtdO1xuICBzY2hlbWE6IHsgW25hbWU6IHN0cmluZ106IFNjaGVtYSB9O1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuZnVuY3Rpb25zID0ge307XG4gICAgdGhpcy5wYXRocyA9IFtdO1xuICAgIHRoaXMuc2NoZW1hID0ge307XG4gIH1cblxuICByZWdpc3RlcjxUPihtYXA6IHtbbmFtZTogc3RyaW5nXTogVH0sIHR5cGVOYW1lOiBzdHJpbmcsIG5hbWU6IHN0cmluZywgb2JqZWN0OiBUKTogVCB7XG4gICAgaWYgKG1hcFtuYW1lXSkge1xuICAgICAgbG9nZ2VyLmVycm9yKFwiRHVwbGljYXRlZCBcIiArIHR5cGVOYW1lICsgXCIgZGVmaW5pdGlvbjogXCIgKyBuYW1lICsgXCIuXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBtYXBbbmFtZV0gPSBvYmplY3Q7XG4gICAgfVxuICAgIHJldHVybiBtYXBbbmFtZV07XG4gIH1cblxuICByZWdpc3RlckZ1bmN0aW9uKG5hbWU6IHN0cmluZywgcGFyYW1zOiBzdHJpbmdbXSwgYm9keTogRXhwKTogTWV0aG9kIHtcbiAgICByZXR1cm4gdGhpcy5yZWdpc3RlcjxNZXRob2Q+KHRoaXMuZnVuY3Rpb25zLCAnZnVuY3Rpb25zJywgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZChwYXJhbXMsIGJvZHkpKTtcbiAgfVxuXG4gIHJlZ2lzdGVyUGF0aCh0ZW1wbGF0ZTogUGF0aFRlbXBsYXRlLCBpc1R5cGU6IEV4cFR5cGUgfCB2b2lkLCBtZXRob2RzOiB7IFtuYW1lOiBzdHJpbmddOiBNZXRob2Q7IH0gPSB7fSk6IFBhdGgge1xuICAgIGlzVHlwZSA9IGlzVHlwZSB8fCB0eXBlVHlwZSgnQW55Jyk7XG4gICAgdmFyIHA6IFBhdGggPSB7XG4gICAgICB0ZW1wbGF0ZTogdGVtcGxhdGUuY29weSgpLFxuICAgICAgaXNUeXBlOiA8RXhwVHlwZT4gaXNUeXBlLFxuICAgICAgbWV0aG9kczogbWV0aG9kc1xuICAgIH07XG4gICAgdGhpcy5wYXRocy5wdXNoKHApO1xuICAgIHJldHVybiBwO1xuICB9XG5cbiAgcmVnaXN0ZXJTY2hlbWEobmFtZTogc3RyaW5nLFxuICAgICAgICAgICAgICAgICBkZXJpdmVkRnJvbT86IEV4cFR5cGUsXG4gICAgICAgICAgICAgICAgIHByb3BlcnRpZXMgPSA8VHlwZVBhcmFtcz4ge30sXG4gICAgICAgICAgICAgICAgIG1ldGhvZHMgPSA8eyBbbmFtZTogc3RyaW5nXTogTWV0aG9kIH0+IHt9LFxuICAgICAgICAgICAgICAgICBwYXJhbXMgPSA8c3RyaW5nW10+IFtdKVxuICA6IFNjaGVtYSB7XG4gICAgZGVyaXZlZEZyb20gPSBkZXJpdmVkRnJvbSB8fCB0eXBlVHlwZShPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKS5sZW5ndGggPiAwID8gJ09iamVjdCcgOiAnQW55Jyk7XG5cbiAgICB2YXIgczogU2NoZW1hID0ge1xuICAgICAgZGVyaXZlZEZyb206IDxFeHBUeXBlPiBkZXJpdmVkRnJvbSxcbiAgICAgIHByb3BlcnRpZXM6IHByb3BlcnRpZXMsXG4gICAgICBtZXRob2RzOiBtZXRob2RzLFxuICAgICAgcGFyYW1zOiBwYXJhbXMsXG4gICAgfTtcbiAgICByZXR1cm4gdGhpcy5yZWdpc3RlcjxTY2hlbWE+KHRoaXMuc2NoZW1hLCAnc2NoZW1hJywgbmFtZSwgcyk7XG4gIH1cblxuICBpc0Rlcml2ZWRGcm9tKHR5cGU6IEV4cFR5cGUsIGFuY2VzdG9yOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICBpZiAoYW5jZXN0b3IgPT09ICdBbnknKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHR5cGUudHlwZSkge1xuICAgIGNhc2UgJ3R5cGUnOlxuICAgIGNhc2UgJ2dlbmVyaWMnOlxuICAgICAgbGV0IHNpbXBsZVR5cGUgPSA8RXhwU2ltcGxlVHlwZT4gdHlwZTtcbiAgICAgIGlmIChzaW1wbGVUeXBlLm5hbWUgPT09IGFuY2VzdG9yKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHNpbXBsZVR5cGUubmFtZSA9PT0gJ0FueScpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgbGV0IHNjaGVtYSA9IHRoaXMuc2NoZW1hW3NpbXBsZVR5cGUubmFtZV07XG4gICAgICBpZiAoIXNjaGVtYSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5pc0Rlcml2ZWRGcm9tKHNjaGVtYS5kZXJpdmVkRnJvbSwgYW5jZXN0b3IpO1xuXG4gICAgY2FzZSAndW5pb24nOlxuICAgICAgcmV0dXJuICg8RXhwVW5pb25UeXBlPiB0eXBlKS50eXBlc1xuICAgICAgICAubWFwKChzdWJUeXBlKSA9PiB0aGlzLmlzRGVyaXZlZEZyb20oc3ViVHlwZSwgYW5jZXN0b3IpKVxuICAgICAgICAucmVkdWNlKHV0aWwub3IpO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gdHlwZTogXCIgKyB0eXBlLnR5cGUpO1xuICAgICAgfVxuICB9XG59XG5cbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL09wZXJhdG9ycy9PcGVyYXRvcl9QcmVjZWRlbmNlXG5pbnRlcmZhY2UgT3BQcmlvcml0eSB7XG4gIHJlcD86IHN0cmluZztcbiAgcDogbnVtYmVyO1xufVxuXG52YXIgSlNfT1BTOiB7IFtvcDogc3RyaW5nXTogT3BQcmlvcml0eTsgfSA9IHtcbiAgJ3ZhbHVlJzogeyByZXA6IFwiXCIsIHA6IDE4IH0sXG5cbiAgJ25lZyc6IHsgcmVwOiBcIi1cIiwgcDogMTV9LFxuICAnISc6IHsgcDogMTV9LFxuICAnKic6IHsgcDogMTR9LFxuICAnLyc6IHsgcDogMTR9LFxuICAnJSc6IHsgcDogMTR9LFxuICAnKyc6IHsgcDogMTMgfSxcbiAgJy0nOiB7IHA6IDEzIH0sXG4gICc8JzogeyBwOiAxMSB9LFxuICAnPD0nOiB7IHA6IDExIH0sXG4gICc+JzogeyBwOiAxMSB9LFxuICAnPj0nOiB7IHA6IDExIH0sXG4gICdpbic6IHsgcDogMTEgfSxcbiAgJz09JzogeyBwOiAxMCB9LFxuICBcIiE9XCI6IHsgcDogMTAgfSxcbiAgJyYmJzogeyBwOiA2IH0sXG4gICd8fCc6IHsgcDogNSB9LFxuICAnPzonOiB7IHA6IDQgfSxcbiAgJywnOiB7IHA6IDB9LFxufTtcblxuLy8gRnJvbSBhbiBBU1QsIGRlY29kZSBhcyBhbiBleHByZXNzaW9uIChzdHJpbmcpLlxuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZUV4cHJlc3Npb24oZXhwOiBFeHAsIG91dGVyUHJlY2VkZW5jZT86IG51bWJlcik6IHN0cmluZyB7XG4gIGlmIChvdXRlclByZWNlZGVuY2UgPT09IHVuZGVmaW5lZCkge1xuICAgIG91dGVyUHJlY2VkZW5jZSA9IDA7XG4gIH1cbiAgdmFyIGlubmVyUHJlY2VkZW5jZSA9IHByZWNlZGVuY2VPZihleHApO1xuICB2YXIgcmVzdWx0ID0gJyc7XG5cbiAgc3dpdGNoIChleHAudHlwZSkge1xuICBjYXNlICdCb29sZWFuJzpcbiAgY2FzZSAnTnVtYmVyJzpcbiAgICByZXN1bHQgPSBKU09OLnN0cmluZ2lmeSgoPEV4cFZhbHVlPiBleHApLnZhbHVlKTtcbiAgICBicmVhaztcblxuICBjYXNlICdTdHJpbmcnOlxuICAgIHJlc3VsdCA9IHV0aWwucXVvdGVTdHJpbmcoKDxFeHBWYWx1ZT4gZXhwKS52YWx1ZSk7XG4gICAgYnJlYWs7XG5cbiAgLy8gUmVnRXhwIGFzc3VtZWQgdG8gYmUgaW4gcHJlLXF1b3RlZCBmb3JtYXQuXG4gIGNhc2UgJ1JlZ0V4cCc6XG4gICAgbGV0IHJlZ2V4cCA9IDxSZWdFeHBWYWx1ZT4gZXhwO1xuICAgIHJlc3VsdCA9ICcvJyArIHJlZ2V4cC52YWx1ZSArICcvJztcbiAgICBpZiAocmVnZXhwLm1vZGlmaWVycyAhPT0gJycpIHtcbiAgICAgIHJlc3VsdCArPSByZWdleHAubW9kaWZpZXJzO1xuICAgIH1cbiAgICBicmVhaztcblxuICBjYXNlICdBcnJheSc6XG4gICAgcmVzdWx0ID0gJ1snICsgZGVjb2RlQXJyYXkoKDxFeHBWYWx1ZT4gZXhwKS52YWx1ZSkgKyAnXSc7XG4gICAgYnJlYWs7XG5cbiAgY2FzZSAnTnVsbCc6XG4gICAgcmVzdWx0ID0gJ251bGwnO1xuICAgIGJyZWFrO1xuXG4gIGNhc2UgJ3Zhcic6XG4gIGNhc2UgJ2xpdGVyYWwnOlxuICAgIHJlc3VsdCA9ICg8RXhwVmFyaWFibGU+IGV4cCkubmFtZTtcbiAgICBicmVhaztcblxuICBjYXNlICdyZWYnOlxuICAgIGxldCBleHBSZWYgPSA8RXhwUmVmZXJlbmNlPiBleHA7XG4gICAgaWYgKGlzSWRlbnRpZmllclN0cmluZ0V4cChleHBSZWYuYWNjZXNzb3IpKSB7XG4gICAgICByZXN1bHQgPSBkZWNvZGVFeHByZXNzaW9uKGV4cFJlZi5iYXNlLCBpbm5lclByZWNlZGVuY2UpICsgJy4nICsgKDxFeHBWYWx1ZT4gZXhwUmVmLmFjY2Vzc29yKS52YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gZGVjb2RlRXhwcmVzc2lvbihleHBSZWYuYmFzZSwgaW5uZXJQcmVjZWRlbmNlKSArXG4gICAgICAgICdbJyArIGRlY29kZUV4cHJlc3Npb24oZXhwUmVmLmFjY2Vzc29yKSArICddJztcbiAgICB9XG4gICAgYnJlYWs7XG5cbiAgY2FzZSAnY2FsbCc6XG4gICAgbGV0IGV4cENhbGwgPSA8RXhwQ2FsbD4gZXhwO1xuICAgIHJlc3VsdCA9IGRlY29kZUV4cHJlc3Npb24oZXhwQ2FsbC5yZWYpICsgJygnICsgZGVjb2RlQXJyYXkoZXhwQ2FsbC5hcmdzKSArICcpJztcbiAgICBicmVhaztcblxuICBjYXNlICdidWlsdGluJzpcbiAgICByZXN1bHQgPSBkZWNvZGVFeHByZXNzaW9uKGV4cCk7XG4gICAgYnJlYWs7XG5cbiAgY2FzZSAnb3AnOlxuICAgIGxldCBleHBPcCA9IDxFeHBPcD4gZXhwO1xuICAgIHZhciByZXAgPSBKU19PUFNbZXhwT3Aub3BdLnJlcCA9PT0gdW5kZWZpbmVkID8gZXhwT3Aub3AgOiBKU19PUFNbZXhwT3Aub3BdLnJlcDtcbiAgICBpZiAoZXhwT3AuYXJncy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHJlc3VsdCA9IHJlcCArIGRlY29kZUV4cHJlc3Npb24oZXhwT3AuYXJnc1swXSwgaW5uZXJQcmVjZWRlbmNlKTtcbiAgICB9IGVsc2UgaWYgKGV4cE9wLmFyZ3MubGVuZ3RoID09PSAyKSB7XG4gICAgICByZXN1bHQgPVxuICAgICAgICBkZWNvZGVFeHByZXNzaW9uKGV4cE9wLmFyZ3NbMF0sIGlubmVyUHJlY2VkZW5jZSkgK1xuICAgICAgICAnICcgKyByZXAgKyAnICcgK1xuICAgICAgICAvLyBBbGwgb3BzIGFyZSBsZWZ0IGFzc29jaWF0aXZlIC0gc28gbnVkZ2UgdGhlIGlubmVyUHJlY2VuZGVuY2VcbiAgICAgICAgLy8gZG93biBvbiB0aGUgcmlnaHQgaGFuZCBzaWRlIHRvIGZvcmNlICgpIGZvciByaWdodC1hc3NvY2lhdGluZ1xuICAgICAgICAvLyBvcGVyYXRpb25zLlxuICAgICAgICBkZWNvZGVFeHByZXNzaW9uKGV4cE9wLmFyZ3NbMV0sIGlubmVyUHJlY2VkZW5jZSArIDEpO1xuICAgIH0gZWxzZSBpZiAoZXhwT3AuYXJncy5sZW5ndGggPT09IDMpIHtcbiAgICAgIHJlc3VsdCA9XG4gICAgICAgIGRlY29kZUV4cHJlc3Npb24oZXhwT3AuYXJnc1swXSwgaW5uZXJQcmVjZWRlbmNlKSArICcgPyAnICtcbiAgICAgICAgZGVjb2RlRXhwcmVzc2lvbihleHBPcC5hcmdzWzFdLCBpbm5lclByZWNlZGVuY2UpICsgJyA6ICcgK1xuICAgICAgICBkZWNvZGVFeHByZXNzaW9uKGV4cE9wLmFyZ3NbMl0sIGlubmVyUHJlY2VkZW5jZSk7XG4gICAgfVxuICAgIGJyZWFrO1xuXG4gIGNhc2UgJ3R5cGUnOlxuICAgIHJlc3VsdCA9ICg8RXhwU2ltcGxlVHlwZT4gZXhwKS5uYW1lO1xuICAgIGJyZWFrO1xuXG4gIGNhc2UgJ3VuaW9uJzpcbiAgICByZXN1bHQgPSAoPEV4cFVuaW9uVHlwZT4gZXhwKS50eXBlcy5tYXAoZGVjb2RlRXhwcmVzc2lvbikuam9pbignIHwgJyk7XG4gICAgYnJlYWs7XG5cbiAgY2FzZSAnZ2VuZXJpYyc6XG4gICAgbGV0IGdlbmVyaWNUeXBlID0gPEV4cEdlbmVyaWNUeXBlPiBleHA7XG4gICAgcmV0dXJuIGdlbmVyaWNUeXBlLm5hbWUgKyAnPCcgKyBkZWNvZGVBcnJheShnZW5lcmljVHlwZS5wYXJhbXMpICsgJz4nO1xuXG4gIGRlZmF1bHQ6XG4gICAgcmVzdWx0ID0gXCIqKipVTktOT1dOIFRZUEUqKiogKFwiICsgZXhwLnR5cGUgKyBcIilcIjtcbiAgICBicmVhaztcbiAgfVxuXG4gIGlmIChpbm5lclByZWNlZGVuY2UgPCBvdXRlclByZWNlZGVuY2UpIHtcbiAgICByZXN1bHQgPSAnKCcgKyByZXN1bHQgKyAnKSc7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBkZWNvZGVBcnJheShhcmdzOiBFeHBbXSk6IHN0cmluZyB7XG4gIHJldHVybiBhcmdzLm1hcChkZWNvZGVFeHByZXNzaW9uKS5qb2luKCcsICcpO1xufVxuXG5mdW5jdGlvbiBwcmVjZWRlbmNlT2YoZXhwOiBFeHApOiBudW1iZXIge1xuICBsZXQgcmVzdWx0OiBudW1iZXI7XG5cbiAgc3dpdGNoIChleHAudHlwZSkge1xuICBjYXNlICdvcCc6XG4gICAgcmVzdWx0ID0gSlNfT1BTWyg8RXhwT3A+IGV4cCkub3BdLnA7XG4gICAgYnJlYWs7XG5cbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvT3BlcmF0b3JzL09wZXJhdG9yX1ByZWNlZGVuY2VcbiAgLy8gbGlzdHMgY2FsbCBhcyAxNyBhbmQgcmVmIGFzIDE4IC0gYnV0IGhvdyBjb3VsZCB0aGV5IGJlIGFueXRoaW5nIG90aGVyIHRoYW4gbGVmdCB0byByaWdodD9cbiAgLy8gaHR0cDovL3d3dy5zY3JpcHRpbmdtYXN0ZXIuY29tL2phdmFzY3JpcHQvb3BlcmF0b3ItcHJlY2VkZW5jZS5hc3AgLSBhZ3JlZXMuXG4gIGNhc2UgJ2NhbGwnOlxuICAgIHJlc3VsdCA9IDE4O1xuICAgIGJyZWFrO1xuICBjYXNlICdyZWYnOlxuICAgIHJlc3VsdCA9IDE4O1xuICAgIGJyZWFrO1xuICBkZWZhdWx0OlxuICAgIHJlc3VsdCA9IDE5O1xuICAgIGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbiJdfQ==
