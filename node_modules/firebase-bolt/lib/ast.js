"use strict";
/*
 * AST builders for Firebase Rules Language.
 *
 * Copyright 2015 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var util = require('./util');
var logger = require('./logger');
var errors = {
    typeMismatch: "Unexpected type: ",
    duplicatePathPart: "A path component name is duplicated: "
};
;
;
var PathPart = (function () {
    // "label", undefined - static path part
    // "$label", X - variable path part
    // X, !undefined - variable path part
    function PathPart(label, variable) {
        if (label[0] === '$' && variable === undefined) {
            variable = label;
        }
        if (variable && label[0] !== '$') {
            label = '$' + label;
        }
        this.label = label;
        this.variable = variable;
    }
    return PathPart;
}());
exports.PathPart = PathPart;
var PathTemplate = (function () {
    function PathTemplate(parts) {
        if (parts === void 0) { parts = []; }
        this.parts = parts.map(function (part) {
            if (util.isType(part, 'string')) {
                return new PathPart(part);
            }
            else {
                return part;
            }
        });
    }
    PathTemplate.prototype.copy = function () {
        var result = new PathTemplate();
        result.push(this);
        return result;
    };
    PathTemplate.prototype.getLabels = function () {
        return this.parts.map(function (part) { return part.label; });
    };
    // Mapping from variables to JSON labels
    PathTemplate.prototype.getScope = function () {
        var result = {};
        this.parts.forEach(function (part) {
            if (part.variable) {
                if (result[part.variable]) {
                    throw new Error(errors.duplicatePathPart + part.variable);
                }
                result[part.variable] = literal(part.label);
            }
        });
        return result;
    };
    PathTemplate.prototype.push = function (temp) {
        util.extendArray(this.parts, temp.parts);
    };
    PathTemplate.prototype.pop = function (temp) {
        var _this = this;
        temp.parts.forEach(function (part) {
            _this.parts.pop();
        });
    };
    PathTemplate.prototype.length = function () {
        return this.parts.length;
    };
    PathTemplate.prototype.getPart = function (i) {
        if (i > this.parts.length || i < -this.parts.length) {
            var l = this.parts.length;
            throw new Error("Path reference out of bounds: " + i +
                " [" + -l + " .. " + l + "]");
        }
        if (i < 0) {
            return this.parts[this.parts.length + i];
        }
        return this.parts[i];
    };
    return PathTemplate;
}());
exports.PathTemplate = PathTemplate;
;
var Schema = (function () {
    function Schema() {
    }
    Schema.isGeneric = function (schema) {
        return schema.params !== undefined && schema.params.length > 0;
    };
    return Schema;
}());
exports.Schema = Schema;
;
exports.string = valueGen('String');
exports.boolean = valueGen('Boolean');
exports.number = valueGen('Number');
exports.array = valueGen('Array');
exports.neg = opGen('neg', 1);
exports.not = opGen('!', 1);
exports.mult = opGen('*');
exports.div = opGen('/');
exports.mod = opGen('%');
exports.add = opGen('+');
exports.sub = opGen('-');
exports.eq = opGen('==');
exports.lt = opGen('<');
exports.lte = opGen('<=');
exports.gt = opGen('>');
exports.gte = opGen('>=');
exports.ne = opGen('!=');
exports.and = opGen('&&');
exports.or = opGen('||');
exports.ternary = opGen('?:', 3);
exports.value = opGen('value', 1);
function variable(name) {
    return { type: 'var', valueType: 'Any', name: name };
}
exports.variable = variable;
function literal(name) {
    return { type: 'literal', valueType: 'Any', name: name };
}
exports.literal = literal;
function nullType() {
    return { type: 'Null', valueType: 'Null' };
}
exports.nullType = nullType;
function reference(base, prop) {
    return {
        type: 'ref',
        valueType: 'Any',
        base: base,
        accessor: prop
    };
}
exports.reference = reference;
var reIdentifier = /^[a-zA-Z_$][a-zA-Z0-9_]*$/;
function isIdentifierStringExp(exp) {
    return exp.type === 'String' && reIdentifier.test(exp.value);
}
exports.isIdentifierStringExp = isIdentifierStringExp;
// Shallow copy of an expression (so it can be modified and preserve
// immutability of the original expression).
function copyExp(exp) {
    exp = util.extend({}, exp);
    switch (exp.type) {
        case 'op':
        case 'call':
            var opExp = exp;
            opExp.args = util.copyArray(opExp.args);
            return opExp;
        case 'union':
            var unionExp = exp;
            unionExp.types = util.copyArray(unionExp.types);
            return unionExp;
        case 'generic':
            var genericExp = exp;
            genericExp.params = util.copyArray(genericExp.params);
            return genericExp;
        default:
            return exp;
    }
}
exports.copyExp = copyExp;
// Make a (shallow) copy of the base expression, setting (or removing) it's
// valueType.
//
// valueType is a string indicating the type of evaluating an expression (e.g.
// 'Snapshot') - used to know when type coercion is needed in the context
// of parent expressions.
function cast(base, valueType) {
    var result = copyExp(base);
    result.valueType = valueType;
    return result;
}
exports.cast = cast;
function call(ref, args) {
    if (args === void 0) { args = []; }
    return { type: 'call', valueType: 'Any', ref: ref, args: args };
}
exports.call = call;
// Return empty string if not a function.
function getFunctionName(exp) {
    if (exp.ref.type === 'ref') {
        return '';
    }
    return exp.ref.name;
}
exports.getFunctionName = getFunctionName;
// Return empty string if not a (simple) method call -- ref.fn()
function getMethodName(exp) {
    if (exp.ref.type === 'var') {
        return exp.ref.name;
    }
    if (exp.ref.type !== 'ref') {
        return '';
    }
    return getPropName(exp.ref);
}
exports.getMethodName = getMethodName;
function getPropName(ref) {
    if (ref.accessor.type !== 'String') {
        return '';
    }
    return ref.accessor.value;
}
exports.getPropName = getPropName;
// TODO: Type of function signature does not fail this declaration?
function builtin(fn) {
    return { type: 'builtin', valueType: 'Any', fn: fn };
}
exports.builtin = builtin;
function snapshotVariable(name) {
    return cast(variable(name), 'Snapshot');
}
exports.snapshotVariable = snapshotVariable;
function snapshotParent(base) {
    if (base.valueType !== 'Snapshot') {
        throw new Error(errors.typeMismatch + "expected Snapshot");
    }
    return cast(call(reference(cast(base, 'Any'), exports.string('parent'))), 'Snapshot');
}
exports.snapshotParent = snapshotParent;
function ensureValue(exp) {
    if (exp.valueType === 'Snapshot') {
        return snapshotValue(exp);
    }
    return exp;
}
exports.ensureValue = ensureValue;
// ref.val()
function snapshotValue(exp) {
    return call(reference(cast(exp, 'Any'), exports.string('val')));
}
exports.snapshotValue = snapshotValue;
// Ensure expression is a boolean (when used in a boolean context).
function ensureBoolean(exp) {
    exp = ensureValue(exp);
    if (isCall(exp, 'val')) {
        exp = exports.eq(exp, exports.boolean(true));
    }
    return exp;
}
exports.ensureBoolean = ensureBoolean;
function isCall(exp, methodName) {
    return exp.type === 'call' && exp.ref.type === 'ref' &&
        exp.ref.accessor.type === 'String' &&
        exp.ref.accessor.value === methodName;
}
exports.isCall = isCall;
// Return value generating function for a given Type.
function valueGen(typeName) {
    return function (val) {
        return {
            type: typeName,
            valueType: typeName,
            value: val // The (constant) value itself.
        };
    };
}
function regexp(pattern, modifiers) {
    if (modifiers === void 0) { modifiers = ""; }
    switch (modifiers) {
        case "":
        case "i":
            break;
        default:
            throw new Error("Unsupported RegExp modifier: " + modifiers);
    }
    return {
        type: 'RegExp',
        valueType: 'RegExp',
        value: pattern,
        modifiers: modifiers
    };
}
exports.regexp = regexp;
function cmpValues(v1, v2) {
    if (v1.type !== v2.type) {
        return false;
    }
    return v1.value === v2.value;
}
function isOp(opType, exp) {
    return exp.type === 'op' && exp.op === opType;
}
// Return a generating function to make an operator exp node.
function opGen(opType, arity) {
    if (arity === void 0) { arity = 2; }
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i - 0] = arguments[_i];
        }
        if (args.length !== arity) {
            throw new Error("Operator has " + args.length +
                " arguments (expecting " + arity + ").");
        }
        return op(opType, args);
    };
}
exports.andArray = leftAssociateGen('&&', exports.boolean(true), exports.boolean(false));
exports.orArray = leftAssociateGen('||', exports.boolean(false), exports.boolean(true));
// Create an expression builder function which operates on arrays of values.
// Returns new expression like v1 op v2 op v3 ...
//
// - Any identityValue's in array input are ignored.
// - If zeroValue is found - just return zeroValue.
//
// Our function re-orders top-level op in array elements to the resulting
// expression is left-associating.  E.g.:
//
//    [a && b, c && d] => (((a && b) && c) && d)
//    (NOT (a && b) && (c && d))
function leftAssociateGen(opType, identityValue, zeroValue) {
    return function (a) {
        var i;
        function reducer(result, current) {
            if (result === undefined) {
                return current;
            }
            return op(opType, [result, current]);
        }
        // First flatten all top-level op values to one flat array.
        var flat = [];
        for (i = 0; i < a.length; i++) {
            flatten(opType, a[i], flat);
        }
        var result = [];
        for (i = 0; i < flat.length; i++) {
            // Remove identifyValues from array.
            if (cmpValues(flat[i], identityValue)) {
                continue;
            }
            // Just return zeroValue if found
            if (cmpValues(flat[i], zeroValue)) {
                return zeroValue;
            }
            result.push(flat[i]);
        }
        if (result.length === 0) {
            return identityValue;
        }
        // Return left-associative expression of opType.
        return result.reduce(reducer);
    };
}
// Flatten the top level tree of op into a single flat array of expressions.
function flatten(opType, exp, flat) {
    var i;
    if (flat === undefined) {
        flat = [];
    }
    if (!isOp(opType, exp)) {
        flat.push(exp);
        return flat;
    }
    for (i = 0; i < exp.args.length; i++) {
        flatten(opType, exp.args[i], flat);
    }
    return flat;
}
exports.flatten = flatten;
function op(opType, args) {
    return {
        type: 'op',
        valueType: 'Any',
        op: opType,
        args: args // Arguments to the operator Array<exp>
    };
}
exports.op = op;
// Warning: NOT an expression type!
function method(params, body) {
    return {
        params: params,
        body: body
    };
}
exports.method = method;
function typeType(typeName) {
    return { type: "type", valueType: "type", name: typeName };
}
exports.typeType = typeType;
function unionType(types) {
    return { type: "union", valueType: "type", types: types };
}
exports.unionType = unionType;
function genericType(typeName, params) {
    return { type: "generic", valueType: "type", name: typeName, params: params };
}
exports.genericType = genericType;
var Symbols = (function () {
    function Symbols() {
        this.functions = {};
        this.paths = [];
        this.schema = {};
    }
    Symbols.prototype.register = function (map, typeName, name, object) {
        if (map[name]) {
            logger.error("Duplicated " + typeName + " definition: " + name + ".");
        }
        else {
            map[name] = object;
        }
        return map[name];
    };
    Symbols.prototype.registerFunction = function (name, params, body) {
        return this.register(this.functions, 'functions', name, method(params, body));
    };
    Symbols.prototype.registerPath = function (template, isType, methods) {
        if (methods === void 0) { methods = {}; }
        isType = isType || typeType('Any');
        var p = {
            template: template.copy(),
            isType: isType,
            methods: methods
        };
        this.paths.push(p);
        return p;
    };
    Symbols.prototype.registerSchema = function (name, derivedFrom, properties, methods, params) {
        if (properties === void 0) { properties = {}; }
        if (methods === void 0) { methods = {}; }
        if (params === void 0) { params = []; }
        derivedFrom = derivedFrom || typeType(Object.keys(properties).length > 0 ? 'Object' : 'Any');
        var s = {
            derivedFrom: derivedFrom,
            properties: properties,
            methods: methods,
            params: params
        };
        return this.register(this.schema, 'schema', name, s);
    };
    Symbols.prototype.isDerivedFrom = function (type, ancestor) {
        var _this = this;
        if (ancestor === 'Any') {
            return true;
        }
        switch (type.type) {
            case 'type':
            case 'generic':
                var simpleType = type;
                if (simpleType.name === ancestor) {
                    return true;
                }
                if (simpleType.name === 'Any') {
                    return false;
                }
                var schema = this.schema[simpleType.name];
                if (!schema) {
                    return false;
                }
                return this.isDerivedFrom(schema.derivedFrom, ancestor);
            case 'union':
                return type.types
                    .map(function (subType) { return _this.isDerivedFrom(subType, ancestor); })
                    .reduce(util.or);
            default:
                throw new Error("Unknown type: " + type.type);
        }
    };
    return Symbols;
}());
exports.Symbols = Symbols;
var JS_OPS = {
    'value': { rep: "", p: 18 },
    'neg': { rep: "-", p: 15 },
    '!': { p: 15 },
    '*': { p: 14 },
    '/': { p: 14 },
    '%': { p: 14 },
    '+': { p: 13 },
    '-': { p: 13 },
    '<': { p: 11 },
    '<=': { p: 11 },
    '>': { p: 11 },
    '>=': { p: 11 },
    'in': { p: 11 },
    '==': { p: 10 },
    "!=": { p: 10 },
    '&&': { p: 6 },
    '||': { p: 5 },
    '?:': { p: 4 },
    ',': { p: 0 }
};
// From an AST, decode as an expression (string).
function decodeExpression(exp, outerPrecedence) {
    if (outerPrecedence === undefined) {
        outerPrecedence = 0;
    }
    var innerPrecedence = precedenceOf(exp);
    var result = '';
    switch (exp.type) {
        case 'Boolean':
        case 'Number':
            result = JSON.stringify(exp.value);
            break;
        case 'String':
            result = util.quoteString(exp.value);
            break;
        // RegExp assumed to be in pre-quoted format.
        case 'RegExp':
            var regexp_1 = exp;
            result = '/' + regexp_1.value + '/';
            if (regexp_1.modifiers !== '') {
                result += regexp_1.modifiers;
            }
            break;
        case 'Array':
            result = '[' + decodeArray(exp.value) + ']';
            break;
        case 'Null':
            result = 'null';
            break;
        case 'var':
        case 'literal':
            result = exp.name;
            break;
        case 'ref':
            var expRef = exp;
            if (isIdentifierStringExp(expRef.accessor)) {
                result = decodeExpression(expRef.base, innerPrecedence) + '.' + expRef.accessor.value;
            }
            else {
                result = decodeExpression(expRef.base, innerPrecedence) +
                    '[' + decodeExpression(expRef.accessor) + ']';
            }
            break;
        case 'call':
            var expCall = exp;
            result = decodeExpression(expCall.ref) + '(' + decodeArray(expCall.args) + ')';
            break;
        case 'builtin':
            result = decodeExpression(exp);
            break;
        case 'op':
            var expOp = exp;
            var rep = JS_OPS[expOp.op].rep === undefined ? expOp.op : JS_OPS[expOp.op].rep;
            if (expOp.args.length === 1) {
                result = rep + decodeExpression(expOp.args[0], innerPrecedence);
            }
            else if (expOp.args.length === 2) {
                result =
                    decodeExpression(expOp.args[0], innerPrecedence) +
                        ' ' + rep + ' ' +
                        // All ops are left associative - so nudge the innerPrecendence
                        // down on the right hand side to force () for right-associating
                        // operations.
                        decodeExpression(expOp.args[1], innerPrecedence + 1);
            }
            else if (expOp.args.length === 3) {
                result =
                    decodeExpression(expOp.args[0], innerPrecedence) + ' ? ' +
                        decodeExpression(expOp.args[1], innerPrecedence) + ' : ' +
                        decodeExpression(expOp.args[2], innerPrecedence);
            }
            break;
        case 'type':
            result = exp.name;
            break;
        case 'union':
            result = exp.types.map(decodeExpression).join(' | ');
            break;
        case 'generic':
            var genericType_1 = exp;
            return genericType_1.name + '<' + decodeArray(genericType_1.params) + '>';
        default:
            result = "***UNKNOWN TYPE*** (" + exp.type + ")";
            break;
    }
    if (innerPrecedence < outerPrecedence) {
        result = '(' + result + ')';
    }
    return result;
}
exports.decodeExpression = decodeExpression;
function decodeArray(args) {
    return args.map(decodeExpression).join(', ');
}
function precedenceOf(exp) {
    var result;
    switch (exp.type) {
        case 'op':
            result = JS_OPS[exp.op].p;
            break;
        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence
        // lists call as 17 and ref as 18 - but how could they be anything other than left to right?
        // http://www.scriptingmaster.com/javascript/operator-precedence.asp - agrees.
        case 'call':
            result = 18;
            break;
        case 'ref':
            result = 18;
            break;
        default:
            result = 19;
            break;
    }
    return result;
}

//# sourceMappingURL=data:application/json;charset=utf8;base64,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TUFBTSxHQUFHLHNCQUFzQixHQUFHLEdBQUcsQ0FBQyxJQUFJLEdBQUcsR0FBRyxDQUFDO1lBQ2pELEtBQUssQ0FBQztJQUNSLENBQUM7SUFFRCxFQUFFLENBQUMsQ0FBQyxlQUFlLEdBQUcsZUFBZSxDQUFDLENBQUMsQ0FBQztRQUN0QyxNQUFNLEdBQUcsR0FBRyxHQUFHLE1BQU0sR0FBRyxHQUFHLENBQUM7SUFDOUIsQ0FBQztJQUVELE1BQU0sQ0FBQyxNQUFNLENBQUM7QUFDaEIsQ0FBQztBQXJHZSx3QkFBZ0IsbUJBcUcvQixDQUFBO0FBRUQscUJBQXFCLElBQVc7SUFDOUIsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsZ0JBQWdCLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDL0MsQ0FBQztBQUVELHNCQUFzQixHQUFRO0lBQzVCLElBQUksTUFBYyxDQUFDO0lBRW5CLE1BQU0sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO1FBQ25CLEtBQUssSUFBSTtZQUNQLE1BQU0sR0FBRyxNQUFNLENBQVUsR0FBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNwQyxLQUFLLENBQUM7UUFFUixrR0FBa0c7UUFDbEcsNEZBQTRGO1FBQzVGLDhFQUE4RTtRQUM5RSxLQUFLLE1BQU07WUFDVCxNQUFNLEdBQUcsRUFBRSxDQUFDO1lBQ1osS0FBSyxDQUFDO1FBQ1IsS0FBSyxLQUFLO1lBQ1IsTUFBTSxHQUFHLEVBQUUsQ0FBQztZQUNaLEtBQUssQ0FBQztRQUNSO1lBQ0UsTUFBTSxHQUFHLEVBQUUsQ0FBQztZQUNaLEtBQUssQ0FBQztJQUNSLENBQUM7SUFFRCxNQUFNLENBQUMsTUFBTSxDQUFDO0FBQ2hCLENBQUMiLCJmaWxlIjoiYXN0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIEFTVCBidWlsZGVycyBmb3IgRmlyZWJhc2UgUnVsZXMgTGFuZ3VhZ2UuXG4gKlxuICogQ29weXJpZ2h0IDIwMTUgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmltcG9ydCAqIGFzIHV0aWwgZnJvbSAnLi91dGlsJztcbmltcG9ydCAqIGFzIGxvZ2dlciBmcm9tICcuL2xvZ2dlcic7XG5cbnZhciBlcnJvcnMgPSB7XG4gIHR5cGVNaXNtYXRjaDogXCJVbmV4cGVjdGVkIHR5cGU6IFwiLFxuICBkdXBsaWNhdGVQYXRoUGFydDogXCJBIHBhdGggY29tcG9uZW50IG5hbWUgaXMgZHVwbGljYXRlZDogXCIsXG59O1xuXG5leHBvcnQgdHlwZSBPYmplY3QgPSB7IFtwcm9wOiBzdHJpbmddOiBhbnkgfTtcblxuZXhwb3J0IGludGVyZmFjZSBFeHAge1xuICB0eXBlOiBzdHJpbmc7XG4gIHZhbHVlVHlwZTogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEV4cFZhbHVlIGV4dGVuZHMgRXhwIHtcbiAgdmFsdWU6IGFueTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSZWdFeHBWYWx1ZSBleHRlbmRzIEV4cFZhbHVlIHtcbiAgbW9kaWZpZXJzOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRXhwTnVsbCBleHRlbmRzIEV4cCB7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRXhwT3AgZXh0ZW5kcyBFeHAge1xuICBvcDogc3RyaW5nO1xuICBhcmdzOiBFeHBbXTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBFeHBWYXJpYWJsZSBleHRlbmRzIEV4cCB7XG4gIG5hbWU6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBFeHBMaXRlcmFsIGV4dGVuZHMgRXhwIHtcbiAgbmFtZTogc3RyaW5nO1xufVxuXG4vLyBiYXNlW2FjY2Vzc29yXVxuZXhwb3J0IGludGVyZmFjZSBFeHBSZWZlcmVuY2UgZXh0ZW5kcyBFeHAge1xuICBiYXNlOiBFeHA7XG4gIGFjY2Vzc29yOiBFeHA7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRXhwQ2FsbCBleHRlbmRzIEV4cCB7XG4gIHJlZjogRXhwUmVmZXJlbmNlIHwgRXhwVmFyaWFibGU7XG4gIGFyZ3M6IEV4cFtdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFBhcmFtcyB7IFtuYW1lOiBzdHJpbmddOiBFeHA7IH07XG5cbmV4cG9ydCB0eXBlIEJ1aWx0aW5GdW5jdGlvbiA9IChhcmdzOiBFeHBbXSwgcGFyYW1zOiBQYXJhbXMpID0+IEV4cDtcblxuZXhwb3J0IGludGVyZmFjZSBFeHBCdWlsdGluIGV4dGVuZHMgRXhwIHtcbiAgZm46IEJ1aWx0aW5GdW5jdGlvbjtcbn1cblxuZXhwb3J0IHR5cGUgRXhwVHlwZSA9IEV4cFNpbXBsZVR5cGUgfCBFeHBVbmlvblR5cGUgfCBFeHBHZW5lcmljVHlwZTtcbmV4cG9ydCBpbnRlcmZhY2UgVHlwZVBhcmFtcyB7IFtuYW1lOiBzdHJpbmddOiBFeHBUeXBlOyB9O1xuXG4vLyBTaW1wbGUgVHlwZSAocmVmZXJlbmNlKVxuZXhwb3J0IGludGVyZmFjZSBFeHBTaW1wbGVUeXBlIGV4dGVuZHMgRXhwIHtcbiAgbmFtZTogc3RyaW5nO1xufVxuXG4vLyBVbmlvbiBUeXBlOiBUeXBlMSB8IFR5cGUyIHwgLi4uXG5leHBvcnQgaW50ZXJmYWNlIEV4cFVuaW9uVHlwZSBleHRlbmRzIEV4cCB7XG4gIHR5cGVzOiBFeHBUeXBlW107XG59XG5cbi8vIEdlbmVyaWMgVHlwZSAocmVmZXJlbmNlKTogVHlwZTxUeXBlMSwgVHlwZTIsIC4uLj5cbmV4cG9ydCBpbnRlcmZhY2UgRXhwR2VuZXJpY1R5cGUgZXh0ZW5kcyBFeHAge1xuICBuYW1lOiBzdHJpbmc7XG4gIHBhcmFtczogRXhwVHlwZVtdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE1ldGhvZCB7XG4gIHBhcmFtczogc3RyaW5nW107XG4gIGJvZHk6IEV4cDtcbn1cblxuZXhwb3J0IGNsYXNzIFBhdGhQYXJ0IHtcbiAgbGFiZWw6IHN0cmluZztcbiAgdmFyaWFibGU6IHN0cmluZztcblxuICAvLyBcImxhYmVsXCIsIHVuZGVmaW5lZCAtIHN0YXRpYyBwYXRoIHBhcnRcbiAgLy8gXCIkbGFiZWxcIiwgWCAtIHZhcmlhYmxlIHBhdGggcGFydFxuICAvLyBYLCAhdW5kZWZpbmVkIC0gdmFyaWFibGUgcGF0aCBwYXJ0XG4gIGNvbnN0cnVjdG9yKGxhYmVsOiBzdHJpbmcsIHZhcmlhYmxlPzogc3RyaW5nKSB7XG4gICAgaWYgKGxhYmVsWzBdID09PSAnJCcgJiYgdmFyaWFibGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyaWFibGUgPSBsYWJlbDtcbiAgICB9XG4gICAgaWYgKHZhcmlhYmxlICYmIGxhYmVsWzBdICE9PSAnJCcpIHtcbiAgICAgIGxhYmVsID0gJyQnICsgbGFiZWw7XG4gICAgfVxuICAgIHRoaXMubGFiZWwgPSBsYWJlbDtcbiAgICB0aGlzLnZhcmlhYmxlID0gPHN0cmluZz4gdmFyaWFibGU7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFBhdGhUZW1wbGF0ZSB7XG4gIHBhcnRzOiBQYXRoUGFydFtdO1xuXG4gIGNvbnN0cnVjdG9yKHBhcnRzID0gPChzdHJpbmcgfCBQYXRoUGFydClbXT4gW10pIHtcbiAgICB0aGlzLnBhcnRzID0gPFBhdGhQYXJ0W10+IHBhcnRzLm1hcCgocGFydCkgPT4ge1xuICAgICAgaWYgKHV0aWwuaXNUeXBlKHBhcnQsICdzdHJpbmcnKSkge1xuICAgICAgICByZXR1cm4gbmV3IFBhdGhQYXJ0KDxzdHJpbmc+IHBhcnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIDxQYXRoUGFydD4gcGFydDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGNvcHkoKSB7XG4gICAgbGV0IHJlc3VsdCA9IG5ldyBQYXRoVGVtcGxhdGUoKTtcbiAgICByZXN1bHQucHVzaCh0aGlzKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZ2V0TGFiZWxzKCk6IHN0cmluZ1tdIHtcbiAgICByZXR1cm4gdGhpcy5wYXJ0cy5tYXAoKHBhcnQpID0+IHBhcnQubGFiZWwpO1xuICB9XG5cbiAgLy8gTWFwcGluZyBmcm9tIHZhcmlhYmxlcyB0byBKU09OIGxhYmVsc1xuICBnZXRTY29wZSgpOiBQYXJhbXMge1xuICAgIGxldCByZXN1bHQgPSA8UGFyYW1zPiB7fTtcbiAgICB0aGlzLnBhcnRzLmZvckVhY2goKHBhcnQpID0+IHtcbiAgICAgIGlmIChwYXJ0LnZhcmlhYmxlKSB7XG4gICAgICAgIGlmIChyZXN1bHRbcGFydC52YXJpYWJsZV0pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLmR1cGxpY2F0ZVBhdGhQYXJ0ICsgcGFydC52YXJpYWJsZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0W3BhcnQudmFyaWFibGVdID0gbGl0ZXJhbChwYXJ0LmxhYmVsKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgcHVzaCh0ZW1wOiBQYXRoVGVtcGxhdGUpIHtcbiAgICB1dGlsLmV4dGVuZEFycmF5KHRoaXMucGFydHMsIHRlbXAucGFydHMpO1xuICB9XG5cbiAgcG9wKHRlbXA6IFBhdGhUZW1wbGF0ZSkge1xuICAgIHRlbXAucGFydHMuZm9yRWFjaCgocGFydCkgPT4ge1xuICAgICAgdGhpcy5wYXJ0cy5wb3AoKTtcbiAgICB9KTtcbiAgfVxuXG4gIGxlbmd0aCgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLnBhcnRzLmxlbmd0aDtcbiAgfVxuXG4gIGdldFBhcnQoaTogbnVtYmVyKTogUGF0aFBhcnQge1xuICAgIGlmIChpID4gdGhpcy5wYXJ0cy5sZW5ndGggfHwgaSA8IC10aGlzLnBhcnRzLmxlbmd0aCkge1xuICAgICAgbGV0IGwgPSB0aGlzLnBhcnRzLmxlbmd0aDtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlBhdGggcmVmZXJlbmNlIG91dCBvZiBib3VuZHM6IFwiICsgaSArXG4gICAgICAgICAgICAgICAgICAgICAgXCIgW1wiICsgLWwgKyBcIiAuLiBcIiArIGwgKyBcIl1cIik7XG4gICAgfVxuICAgIGlmIChpIDwgMCkge1xuICAgICAgcmV0dXJuIHRoaXMucGFydHNbdGhpcy5wYXJ0cy5sZW5ndGggKyBpXTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucGFydHNbaV07XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBQYXRoIHtcbiAgdGVtcGxhdGU6IFBhdGhUZW1wbGF0ZTtcbiAgaXNUeXBlOiBFeHBUeXBlO1xuICBtZXRob2RzOiB7IFtuYW1lOiBzdHJpbmddOiBNZXRob2QgfTtcbn07XG5cbmV4cG9ydCBjbGFzcyBTY2hlbWEge1xuICBkZXJpdmVkRnJvbTogRXhwVHlwZTtcbiAgcHJvcGVydGllczogVHlwZVBhcmFtcztcbiAgbWV0aG9kczogeyBbbmFtZTogc3RyaW5nXTogTWV0aG9kIH07XG5cbiAgLy8gR2VuZXJpYyBwYXJhbWV0ZXJzIC0gaWYgYSBHZW5lcmljIHNjaGVtYVxuICBwYXJhbXM/OiBzdHJpbmdbXTtcbiAgZ2V0VmFsaWRhdG9yPzogKHBhcmFtczogRXhwW10pID0+IE9iamVjdDtcblxuICBzdGF0aWMgaXNHZW5lcmljKHNjaGVtYTogU2NoZW1hKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHNjaGVtYS5wYXJhbXMgIT09IHVuZGVmaW5lZCAmJiBzY2hlbWEucGFyYW1zLmxlbmd0aCA+IDA7XG4gIH1cbn07XG5cbmV4cG9ydCB2YXIgc3RyaW5nOiAodjogc3RyaW5nKSA9PiBFeHBWYWx1ZSA9IHZhbHVlR2VuKCdTdHJpbmcnKTtcbmV4cG9ydCB2YXIgYm9vbGVhbjogKHY6IGJvb2xlYW4pID0+IEV4cFZhbHVlID0gdmFsdWVHZW4oJ0Jvb2xlYW4nKTtcbmV4cG9ydCB2YXIgbnVtYmVyOiAodjogbnVtYmVyKSA9PiBFeHBWYWx1ZSA9IHZhbHVlR2VuKCdOdW1iZXInKTtcbmV4cG9ydCB2YXIgYXJyYXk6ICh2OiBBcnJheTxhbnk+KSA9PiBFeHBWYWx1ZSA9IHZhbHVlR2VuKCdBcnJheScpO1xuXG5leHBvcnQgdmFyIG5lZyA9IG9wR2VuKCduZWcnLCAxKTtcbmV4cG9ydCB2YXIgbm90ID0gb3BHZW4oJyEnLCAxKTtcbmV4cG9ydCB2YXIgbXVsdCA9IG9wR2VuKCcqJyk7XG5leHBvcnQgdmFyIGRpdiA9IG9wR2VuKCcvJyk7XG5leHBvcnQgdmFyIG1vZCA9IG9wR2VuKCclJyk7XG5leHBvcnQgdmFyIGFkZCA9IG9wR2VuKCcrJyk7XG5leHBvcnQgdmFyIHN1YiA9IG9wR2VuKCctJyk7XG5leHBvcnQgdmFyIGVxID0gb3BHZW4oJz09Jyk7XG5leHBvcnQgdmFyIGx0ID0gb3BHZW4oJzwnKTtcbmV4cG9ydCB2YXIgbHRlID0gb3BHZW4oJzw9Jyk7XG5leHBvcnQgdmFyIGd0ID0gb3BHZW4oJz4nKTtcbmV4cG9ydCB2YXIgZ3RlID0gb3BHZW4oJz49Jyk7XG5leHBvcnQgdmFyIG5lID0gb3BHZW4oJyE9Jyk7XG5leHBvcnQgdmFyIGFuZCA9IG9wR2VuKCcmJicpO1xuZXhwb3J0IHZhciBvciA9IG9wR2VuKCd8fCcpO1xuZXhwb3J0IHZhciB0ZXJuYXJ5ID0gb3BHZW4oJz86JywgMyk7XG5leHBvcnQgdmFyIHZhbHVlID0gb3BHZW4oJ3ZhbHVlJywgMSk7XG5cbmV4cG9ydCBmdW5jdGlvbiB2YXJpYWJsZShuYW1lOiBzdHJpbmcpOiBFeHBWYXJpYWJsZSB7XG4gIHJldHVybiB7IHR5cGU6ICd2YXInLCB2YWx1ZVR5cGU6ICdBbnknLCBuYW1lOiBuYW1lIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsaXRlcmFsKG5hbWU6IHN0cmluZyk6IEV4cExpdGVyYWwge1xuICByZXR1cm4geyB0eXBlOiAnbGl0ZXJhbCcsIHZhbHVlVHlwZTogJ0FueScsIG5hbWU6IG5hbWUgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG51bGxUeXBlKCk6IEV4cE51bGwge1xuICByZXR1cm4geyB0eXBlOiAnTnVsbCcsIHZhbHVlVHlwZTogJ051bGwnIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZWZlcmVuY2UoYmFzZTogRXhwLCBwcm9wOiBFeHApOiBFeHBSZWZlcmVuY2Uge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdyZWYnLFxuICAgIHZhbHVlVHlwZTogJ0FueScsXG4gICAgYmFzZTogYmFzZSxcbiAgICBhY2Nlc3NvcjogcHJvcFxuICB9O1xufVxuXG5sZXQgcmVJZGVudGlmaWVyID0gL15bYS16QS1aXyRdW2EtekEtWjAtOV9dKiQvO1xuXG5leHBvcnQgZnVuY3Rpb24gaXNJZGVudGlmaWVyU3RyaW5nRXhwKGV4cDogRXhwKSB7XG4gIHJldHVybiBleHAudHlwZSA9PT0gJ1N0cmluZycgJiYgcmVJZGVudGlmaWVyLnRlc3QoKDxFeHBWYWx1ZT4gZXhwKS52YWx1ZSk7XG59XG5cbi8vIFNoYWxsb3cgY29weSBvZiBhbiBleHByZXNzaW9uIChzbyBpdCBjYW4gYmUgbW9kaWZpZWQgYW5kIHByZXNlcnZlXG4vLyBpbW11dGFiaWxpdHkgb2YgdGhlIG9yaWdpbmFsIGV4cHJlc3Npb24pLlxuZXhwb3J0IGZ1bmN0aW9uIGNvcHlFeHAoZXhwOiBFeHApOiBFeHAge1xuICBleHAgPSA8RXhwPiB1dGlsLmV4dGVuZCh7fSwgZXhwKTtcbiAgc3dpdGNoIChleHAudHlwZSkge1xuICBjYXNlICdvcCc6XG4gIGNhc2UgJ2NhbGwnOlxuICAgIGxldCBvcEV4cCA9IDxFeHBPcD4gZXhwO1xuICAgIG9wRXhwLmFyZ3MgPSB1dGlsLmNvcHlBcnJheShvcEV4cC5hcmdzKTtcbiAgICByZXR1cm4gb3BFeHA7XG5cbiAgY2FzZSAndW5pb24nOlxuICAgIGxldCB1bmlvbkV4cCA9IDxFeHBVbmlvblR5cGU+IGV4cDtcbiAgICB1bmlvbkV4cC50eXBlcyA9IHV0aWwuY29weUFycmF5KHVuaW9uRXhwLnR5cGVzKTtcbiAgICByZXR1cm4gdW5pb25FeHA7XG5cbiAgY2FzZSAnZ2VuZXJpYyc6XG4gICAgbGV0IGdlbmVyaWNFeHAgPSA8RXhwR2VuZXJpY1R5cGU+IGV4cDtcbiAgICBnZW5lcmljRXhwLnBhcmFtcyA9IHV0aWwuY29weUFycmF5KGdlbmVyaWNFeHAucGFyYW1zKTtcbiAgICByZXR1cm4gZ2VuZXJpY0V4cDtcblxuICBkZWZhdWx0OlxuICAgICByZXR1cm4gZXhwO1xuICB9XG59XG5cbi8vIE1ha2UgYSAoc2hhbGxvdykgY29weSBvZiB0aGUgYmFzZSBleHByZXNzaW9uLCBzZXR0aW5nIChvciByZW1vdmluZykgaXQnc1xuLy8gdmFsdWVUeXBlLlxuLy9cbi8vIHZhbHVlVHlwZSBpcyBhIHN0cmluZyBpbmRpY2F0aW5nIHRoZSB0eXBlIG9mIGV2YWx1YXRpbmcgYW4gZXhwcmVzc2lvbiAoZS5nLlxuLy8gJ1NuYXBzaG90JykgLSB1c2VkIHRvIGtub3cgd2hlbiB0eXBlIGNvZXJjaW9uIGlzIG5lZWRlZCBpbiB0aGUgY29udGV4dFxuLy8gb2YgcGFyZW50IGV4cHJlc3Npb25zLlxuZXhwb3J0IGZ1bmN0aW9uIGNhc3QoYmFzZTogRXhwLCB2YWx1ZVR5cGU6IHN0cmluZyk6IEV4cCB7XG4gIHZhciByZXN1bHQgPSBjb3B5RXhwKGJhc2UpO1xuICByZXN1bHQudmFsdWVUeXBlID0gdmFsdWVUeXBlO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2FsbChyZWY6IEV4cFJlZmVyZW5jZSB8IEV4cFZhcmlhYmxlLCBhcmdzOiBFeHBbXT0gW10pOiBFeHBDYWxsIHtcbiAgcmV0dXJuIHsgdHlwZTogJ2NhbGwnLCB2YWx1ZVR5cGU6ICdBbnknLCByZWY6IHJlZiwgYXJnczogYXJncyB9O1xufVxuXG4vLyBSZXR1cm4gZW1wdHkgc3RyaW5nIGlmIG5vdCBhIGZ1bmN0aW9uLlxuZXhwb3J0IGZ1bmN0aW9uIGdldEZ1bmN0aW9uTmFtZShleHA6IEV4cENhbGwpOiBzdHJpbmcge1xuICBpZiAoZXhwLnJlZi50eXBlID09PSAncmVmJykge1xuICAgIHJldHVybiAnJztcbiAgfVxuICByZXR1cm4gKDxFeHBWYXJpYWJsZT4gZXhwLnJlZikubmFtZTtcbn1cblxuLy8gUmV0dXJuIGVtcHR5IHN0cmluZyBpZiBub3QgYSAoc2ltcGxlKSBtZXRob2QgY2FsbCAtLSByZWYuZm4oKVxuZXhwb3J0IGZ1bmN0aW9uIGdldE1ldGhvZE5hbWUoZXhwOiBFeHBDYWxsKTogc3RyaW5nIHtcbiAgaWYgKGV4cC5yZWYudHlwZSA9PT0gJ3ZhcicpIHtcbiAgICByZXR1cm4gKDxFeHBWYXJpYWJsZT4gZXhwLnJlZikubmFtZTtcbiAgfVxuICBpZiAoZXhwLnJlZi50eXBlICE9PSAncmVmJykge1xuICAgIHJldHVybiAnJztcbiAgfVxuICByZXR1cm4gZ2V0UHJvcE5hbWUoPEV4cFJlZmVyZW5jZT4gZXhwLnJlZik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRQcm9wTmFtZShyZWY6IEV4cFJlZmVyZW5jZSk6IHN0cmluZyB7XG4gIGlmIChyZWYuYWNjZXNzb3IudHlwZSAhPT0gJ1N0cmluZycpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbiAgcmV0dXJuICg8RXhwVmFsdWU+IHJlZi5hY2Nlc3NvcikudmFsdWU7XG59XG5cbi8vIFRPRE86IFR5cGUgb2YgZnVuY3Rpb24gc2lnbmF0dXJlIGRvZXMgbm90IGZhaWwgdGhpcyBkZWNsYXJhdGlvbj9cbmV4cG9ydCBmdW5jdGlvbiBidWlsdGluKGZuOiBCdWlsdGluRnVuY3Rpb24pOiBFeHBCdWlsdGluIHtcbiAgcmV0dXJuIHsgdHlwZTogJ2J1aWx0aW4nLCB2YWx1ZVR5cGU6ICdBbnknLCBmbjogZm4gfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNuYXBzaG90VmFyaWFibGUobmFtZTogc3RyaW5nKTogRXhwVmFyaWFibGUge1xuICByZXR1cm4gPEV4cFZhcmlhYmxlPiBjYXN0KHZhcmlhYmxlKG5hbWUpLCAnU25hcHNob3QnKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNuYXBzaG90UGFyZW50KGJhc2U6IEV4cCk6IEV4cCB7XG4gIGlmIChiYXNlLnZhbHVlVHlwZSAhPT0gJ1NuYXBzaG90Jykge1xuICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMudHlwZU1pc21hdGNoICsgXCJleHBlY3RlZCBTbmFwc2hvdFwiKTtcbiAgfVxuICByZXR1cm4gY2FzdChjYWxsKHJlZmVyZW5jZShjYXN0KGJhc2UsICdBbnknKSwgc3RyaW5nKCdwYXJlbnQnKSkpLFxuICAgICAgICAgICAgICAnU25hcHNob3QnKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVuc3VyZVZhbHVlKGV4cDogRXhwKTogRXhwIHtcbiAgaWYgKGV4cC52YWx1ZVR5cGUgPT09ICdTbmFwc2hvdCcpIHtcbiAgICByZXR1cm4gc25hcHNob3RWYWx1ZShleHApO1xuICB9XG4gIHJldHVybiBleHA7XG59XG5cbi8vIHJlZi52YWwoKVxuZXhwb3J0IGZ1bmN0aW9uIHNuYXBzaG90VmFsdWUoZXhwOiBFeHApOiBFeHBDYWxsIHtcbiAgcmV0dXJuIGNhbGwocmVmZXJlbmNlKGNhc3QoZXhwLCAnQW55JyksIHN0cmluZygndmFsJykpKTtcbn1cblxuLy8gRW5zdXJlIGV4cHJlc3Npb24gaXMgYSBib29sZWFuICh3aGVuIHVzZWQgaW4gYSBib29sZWFuIGNvbnRleHQpLlxuZXhwb3J0IGZ1bmN0aW9uIGVuc3VyZUJvb2xlYW4oZXhwOiBFeHApOiBFeHAge1xuICBleHAgPSBlbnN1cmVWYWx1ZShleHApO1xuICBpZiAoaXNDYWxsKGV4cCwgJ3ZhbCcpKSB7XG4gICAgZXhwID0gZXEoZXhwLCBib29sZWFuKHRydWUpKTtcbiAgfVxuICByZXR1cm4gZXhwO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNDYWxsKGV4cDogRXhwLCBtZXRob2ROYW1lOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgcmV0dXJuIGV4cC50eXBlID09PSAnY2FsbCcgJiYgKDxFeHBDYWxsPiBleHApLnJlZi50eXBlID09PSAncmVmJyAmJlxuICAgICg8RXhwUmVmZXJlbmNlPiAoPEV4cENhbGw+IGV4cCkucmVmKS5hY2Nlc3Nvci50eXBlID09PSAnU3RyaW5nJyAmJlxuICAgICg8RXhwVmFsdWU+ICg8RXhwUmVmZXJlbmNlPiAoPEV4cENhbGw+IGV4cCkucmVmKS5hY2Nlc3NvcikudmFsdWUgPT09IG1ldGhvZE5hbWU7XG59XG5cbi8vIFJldHVybiB2YWx1ZSBnZW5lcmF0aW5nIGZ1bmN0aW9uIGZvciBhIGdpdmVuIFR5cGUuXG5mdW5jdGlvbiB2YWx1ZUdlbih0eXBlTmFtZTogc3RyaW5nKTogKCh2YWw6IGFueSkgPT4gRXhwVmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHZhbCk6IEV4cFZhbHVlIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogdHlwZU5hbWUsICAgICAgLy8gRXhwIHR5cGUgaWRlbnRpZnlpbmcgYSBjb25zdGFudCB2YWx1ZSBvZiB0aGlzIFR5cGUuXG4gICAgICB2YWx1ZVR5cGU6IHR5cGVOYW1lLCAvLyBUaGUgdHlwZSBvZiB0aGUgcmVzdWx0IG9mIGV2YWx1YXRpbmcgdGhpcyBleHByZXNzaW9uLlxuICAgICAgdmFsdWU6IHZhbCAgICAgICAgICAgLy8gVGhlIChjb25zdGFudCkgdmFsdWUgaXRzZWxmLlxuICAgIH07XG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZWdleHAocGF0dGVybjogc3RyaW5nLCBtb2RpZmllcnMgPSBcIlwiKTogUmVnRXhwVmFsdWUge1xuICBzd2l0Y2ggKG1vZGlmaWVycykge1xuICBjYXNlIFwiXCI6XG4gIGNhc2UgXCJpXCI6XG4gICAgYnJlYWs7XG4gIGRlZmF1bHQ6XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgUmVnRXhwIG1vZGlmaWVyOiBcIiArIG1vZGlmaWVycyk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnUmVnRXhwJyxcbiAgICB2YWx1ZVR5cGU6ICdSZWdFeHAnLFxuICAgIHZhbHVlOiBwYXR0ZXJuLFxuICAgIG1vZGlmaWVyczogbW9kaWZpZXJzXG4gIH07XG59XG5cbmZ1bmN0aW9uIGNtcFZhbHVlcyh2MTogRXhwLCB2MjogRXhwVmFsdWUpOiBib29sZWFuIHtcbiAgaWYgKHYxLnR5cGUgIT09IHYyLnR5cGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuICg8RXhwVmFsdWU+IHYxKS52YWx1ZSA9PT0gdjIudmFsdWU7XG59XG5cbmZ1bmN0aW9uIGlzT3Aob3BUeXBlOiBzdHJpbmcsIGV4cDogRXhwKTogYm9vbGVhbiB7XG4gIHJldHVybiBleHAudHlwZSA9PT0gJ29wJyAmJiAoPEV4cE9wPiBleHApLm9wID09PSBvcFR5cGU7XG59XG5cbi8vIFJldHVybiBhIGdlbmVyYXRpbmcgZnVuY3Rpb24gdG8gbWFrZSBhbiBvcGVyYXRvciBleHAgbm9kZS5cbmZ1bmN0aW9uIG9wR2VuKG9wVHlwZTogc3RyaW5nLCBhcml0eTogbnVtYmVyID0gMik6ICgoLi4uYXJnczogRXhwW10pID0+IEV4cE9wKSB7XG4gIHJldHVybiBmdW5jdGlvbiguLi5hcmdzKTogRXhwT3Age1xuICAgIGlmIChhcmdzLmxlbmd0aCAhPT0gYXJpdHkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk9wZXJhdG9yIGhhcyBcIiArIGFyZ3MubGVuZ3RoICtcbiAgICAgICAgICAgICAgICAgICAgICBcIiBhcmd1bWVudHMgKGV4cGVjdGluZyBcIiArIGFyaXR5ICsgXCIpLlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIG9wKG9wVHlwZSwgYXJncyk7XG4gIH07XG59XG5cbmV4cG9ydCB2YXIgYW5kQXJyYXkgPSBsZWZ0QXNzb2NpYXRlR2VuKCcmJicsIGJvb2xlYW4odHJ1ZSksIGJvb2xlYW4oZmFsc2UpKTtcbmV4cG9ydCB2YXIgb3JBcnJheSA9IGxlZnRBc3NvY2lhdGVHZW4oJ3x8JywgYm9vbGVhbihmYWxzZSksIGJvb2xlYW4odHJ1ZSkpO1xuXG4vLyBDcmVhdGUgYW4gZXhwcmVzc2lvbiBidWlsZGVyIGZ1bmN0aW9uIHdoaWNoIG9wZXJhdGVzIG9uIGFycmF5cyBvZiB2YWx1ZXMuXG4vLyBSZXR1cm5zIG5ldyBleHByZXNzaW9uIGxpa2UgdjEgb3AgdjIgb3AgdjMgLi4uXG4vL1xuLy8gLSBBbnkgaWRlbnRpdHlWYWx1ZSdzIGluIGFycmF5IGlucHV0IGFyZSBpZ25vcmVkLlxuLy8gLSBJZiB6ZXJvVmFsdWUgaXMgZm91bmQgLSBqdXN0IHJldHVybiB6ZXJvVmFsdWUuXG4vL1xuLy8gT3VyIGZ1bmN0aW9uIHJlLW9yZGVycyB0b3AtbGV2ZWwgb3AgaW4gYXJyYXkgZWxlbWVudHMgdG8gdGhlIHJlc3VsdGluZ1xuLy8gZXhwcmVzc2lvbiBpcyBsZWZ0LWFzc29jaWF0aW5nLiAgRS5nLjpcbi8vXG4vLyAgICBbYSAmJiBiLCBjICYmIGRdID0+ICgoKGEgJiYgYikgJiYgYykgJiYgZClcbi8vICAgIChOT1QgKGEgJiYgYikgJiYgKGMgJiYgZCkpXG5mdW5jdGlvbiBsZWZ0QXNzb2NpYXRlR2VuKG9wVHlwZTogc3RyaW5nLCBpZGVudGl0eVZhbHVlOiBFeHBWYWx1ZSwgemVyb1ZhbHVlOiBFeHBWYWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oYTogRXhwW10pOiBFeHAge1xuICAgIHZhciBpOiBudW1iZXI7XG5cbiAgICBmdW5jdGlvbiByZWR1Y2VyKHJlc3VsdDogRXhwLCBjdXJyZW50OiBFeHApIHtcbiAgICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gY3VycmVudDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvcChvcFR5cGUsIFtyZXN1bHQsIGN1cnJlbnRdKTtcbiAgICB9XG5cbiAgICAvLyBGaXJzdCBmbGF0dGVuIGFsbCB0b3AtbGV2ZWwgb3AgdmFsdWVzIHRvIG9uZSBmbGF0IGFycmF5LlxuICAgIHZhciBmbGF0ID0gPEV4cFtdPltdO1xuICAgIGZvciAoaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBmbGF0dGVuKG9wVHlwZSwgYVtpXSwgZmxhdCk7XG4gICAgfVxuXG4gICAgdmFyIHJlc3VsdCA9IDxFeHBbXT5bXTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZmxhdC5sZW5ndGg7IGkrKykge1xuICAgICAgLy8gUmVtb3ZlIGlkZW50aWZ5VmFsdWVzIGZyb20gYXJyYXkuXG4gICAgICBpZiAoY21wVmFsdWVzKGZsYXRbaV0sIGlkZW50aXR5VmFsdWUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgLy8gSnVzdCByZXR1cm4gemVyb1ZhbHVlIGlmIGZvdW5kXG4gICAgICBpZiAoY21wVmFsdWVzKGZsYXRbaV0sIHplcm9WYWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHplcm9WYWx1ZTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5wdXNoKGZsYXRbaV0pO1xuICAgIH1cblxuICAgIGlmIChyZXN1bHQubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gaWRlbnRpdHlWYWx1ZTtcbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gbGVmdC1hc3NvY2lhdGl2ZSBleHByZXNzaW9uIG9mIG9wVHlwZS5cbiAgICByZXR1cm4gcmVzdWx0LnJlZHVjZShyZWR1Y2VyKTtcbiAgfTtcbn1cblxuLy8gRmxhdHRlbiB0aGUgdG9wIGxldmVsIHRyZWUgb2Ygb3AgaW50byBhIHNpbmdsZSBmbGF0IGFycmF5IG9mIGV4cHJlc3Npb25zLlxuZXhwb3J0IGZ1bmN0aW9uIGZsYXR0ZW4ob3BUeXBlOiBzdHJpbmcsIGV4cDogRXhwLCBmbGF0PzogRXhwW10pOiBFeHBbXSB7XG4gIHZhciBpOiBudW1iZXI7XG5cbiAgaWYgKGZsYXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGZsYXQgPSBbXTtcbiAgfVxuXG4gIGlmICghaXNPcChvcFR5cGUsIGV4cCkpIHtcbiAgICBmbGF0LnB1c2goZXhwKTtcbiAgICByZXR1cm4gZmxhdDtcbiAgfVxuXG4gIGZvciAoaSA9IDA7IGkgPCAoPEV4cE9wPiBleHApLmFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICBmbGF0dGVuKG9wVHlwZSwgKDxFeHBPcD4gZXhwKS5hcmdzW2ldLCBmbGF0KTtcbiAgfVxuXG4gIHJldHVybiBmbGF0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gb3Aob3BUeXBlOiBzdHJpbmcsIGFyZ3M6IEV4cFtdKTogRXhwT3Age1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdvcCcsICAgICAvLyBUaGlzIGlzIChtdWx0aS1hcmd1bWVudCkgb3BlcmF0b3IuXG4gICAgdmFsdWVUeXBlOiAnQW55JyxcbiAgICBvcDogb3BUeXBlLCAgICAgLy8gVGhlIG9wZXJhdG9yIChzdHJpbmcsIGUuZy4gJysnKS5cbiAgICBhcmdzOiBhcmdzICAgICAgLy8gQXJndW1lbnRzIHRvIHRoZSBvcGVyYXRvciBBcnJheTxleHA+XG4gIH07XG59XG5cbi8vIFdhcm5pbmc6IE5PVCBhbiBleHByZXNzaW9uIHR5cGUhXG5leHBvcnQgZnVuY3Rpb24gbWV0aG9kKHBhcmFtczogc3RyaW5nW10sIGJvZHk6IEV4cCk6IE1ldGhvZCB7XG4gIHJldHVybiB7XG4gICAgcGFyYW1zOiBwYXJhbXMsXG4gICAgYm9keTogYm9keVxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdHlwZVR5cGUodHlwZU5hbWU6IHN0cmluZyk6IEV4cFNpbXBsZVR5cGUge1xuICByZXR1cm4geyB0eXBlOiBcInR5cGVcIiwgdmFsdWVUeXBlOiBcInR5cGVcIiwgbmFtZTogdHlwZU5hbWUgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVuaW9uVHlwZSh0eXBlczogRXhwVHlwZVtdKTogRXhwVW5pb25UeXBlIHtcbiAgcmV0dXJuIHsgdHlwZTogXCJ1bmlvblwiLCB2YWx1ZVR5cGU6IFwidHlwZVwiLCB0eXBlczogdHlwZXMgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyaWNUeXBlKHR5cGVOYW1lOiBzdHJpbmcsIHBhcmFtczogRXhwVHlwZVtdKTogRXhwR2VuZXJpY1R5cGUge1xuICByZXR1cm4geyB0eXBlOiBcImdlbmVyaWNcIiwgdmFsdWVUeXBlOiBcInR5cGVcIiwgbmFtZTogdHlwZU5hbWUsIHBhcmFtczogcGFyYW1zIH07XG59XG5cbmV4cG9ydCBjbGFzcyBTeW1ib2xzIHtcbiAgZnVuY3Rpb25zOiB7IFtuYW1lOiBzdHJpbmddOiBNZXRob2QgfTtcbiAgcGF0aHM6IFBhdGhbXTtcbiAgc2NoZW1hOiB7IFtuYW1lOiBzdHJpbmddOiBTY2hlbWEgfTtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmZ1bmN0aW9ucyA9IHt9O1xuICAgIHRoaXMucGF0aHMgPSBbXTtcbiAgICB0aGlzLnNjaGVtYSA9IHt9O1xuICB9XG5cbiAgcmVnaXN0ZXI8VD4obWFwOiB7W25hbWU6IHN0cmluZ106IFR9LCB0eXBlTmFtZTogc3RyaW5nLCBuYW1lOiBzdHJpbmcsIG9iamVjdDogVCk6IFQge1xuICAgIGlmIChtYXBbbmFtZV0pIHtcbiAgICAgIGxvZ2dlci5lcnJvcihcIkR1cGxpY2F0ZWQgXCIgKyB0eXBlTmFtZSArIFwiIGRlZmluaXRpb246IFwiICsgbmFtZSArIFwiLlwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWFwW25hbWVdID0gb2JqZWN0O1xuICAgIH1cbiAgICByZXR1cm4gbWFwW25hbWVdO1xuICB9XG5cbiAgcmVnaXN0ZXJGdW5jdGlvbihuYW1lOiBzdHJpbmcsIHBhcmFtczogc3RyaW5nW10sIGJvZHk6IEV4cCk6IE1ldGhvZCB7XG4gICAgcmV0dXJuIHRoaXMucmVnaXN0ZXI8TWV0aG9kPih0aGlzLmZ1bmN0aW9ucywgJ2Z1bmN0aW9ucycsIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRob2QocGFyYW1zLCBib2R5KSk7XG4gIH1cblxuICByZWdpc3RlclBhdGgodGVtcGxhdGU6IFBhdGhUZW1wbGF0ZSwgaXNUeXBlOiBFeHBUeXBlIHwgdm9pZCwgbWV0aG9kczogeyBbbmFtZTogc3RyaW5nXTogTWV0aG9kOyB9ID0ge30pOiBQYXRoIHtcbiAgICBpc1R5cGUgPSBpc1R5cGUgfHwgdHlwZVR5cGUoJ0FueScpO1xuICAgIHZhciBwOiBQYXRoID0ge1xuICAgICAgdGVtcGxhdGU6IHRlbXBsYXRlLmNvcHkoKSxcbiAgICAgIGlzVHlwZTogPEV4cFR5cGU+IGlzVHlwZSxcbiAgICAgIG1ldGhvZHM6IG1ldGhvZHNcbiAgICB9O1xuICAgIHRoaXMucGF0aHMucHVzaChwKTtcbiAgICByZXR1cm4gcDtcbiAgfVxuXG4gIHJlZ2lzdGVyU2NoZW1hKG5hbWU6IHN0cmluZyxcbiAgICAgICAgICAgICAgICAgZGVyaXZlZEZyb20/OiBFeHBUeXBlLFxuICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzID0gPFR5cGVQYXJhbXM+IHt9LFxuICAgICAgICAgICAgICAgICBtZXRob2RzID0gPHsgW25hbWU6IHN0cmluZ106IE1ldGhvZCB9PiB7fSxcbiAgICAgICAgICAgICAgICAgcGFyYW1zID0gPHN0cmluZ1tdPiBbXSlcbiAgOiBTY2hlbWEge1xuICAgIGRlcml2ZWRGcm9tID0gZGVyaXZlZEZyb20gfHwgdHlwZVR5cGUoT2JqZWN0LmtleXMocHJvcGVydGllcykubGVuZ3RoID4gMCA/ICdPYmplY3QnIDogJ0FueScpO1xuXG4gICAgdmFyIHM6IFNjaGVtYSA9IHtcbiAgICAgIGRlcml2ZWRGcm9tOiA8RXhwVHlwZT4gZGVyaXZlZEZyb20sXG4gICAgICBwcm9wZXJ0aWVzOiBwcm9wZXJ0aWVzLFxuICAgICAgbWV0aG9kczogbWV0aG9kcyxcbiAgICAgIHBhcmFtczogcGFyYW1zLFxuICAgIH07XG4gICAgcmV0dXJuIHRoaXMucmVnaXN0ZXI8U2NoZW1hPih0aGlzLnNjaGVtYSwgJ3NjaGVtYScsIG5hbWUsIHMpO1xuICB9XG5cbiAgaXNEZXJpdmVkRnJvbSh0eXBlOiBFeHBUeXBlLCBhbmNlc3Rvcjogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgaWYgKGFuY2VzdG9yID09PSAnQW55Jykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgc3dpdGNoICh0eXBlLnR5cGUpIHtcbiAgICBjYXNlICd0eXBlJzpcbiAgICBjYXNlICdnZW5lcmljJzpcbiAgICAgIGxldCBzaW1wbGVUeXBlID0gPEV4cFNpbXBsZVR5cGU+IHR5cGU7XG4gICAgICBpZiAoc2ltcGxlVHlwZS5uYW1lID09PSBhbmNlc3Rvcikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChzaW1wbGVUeXBlLm5hbWUgPT09ICdBbnknKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGxldCBzY2hlbWEgPSB0aGlzLnNjaGVtYVtzaW1wbGVUeXBlLm5hbWVdO1xuICAgICAgaWYgKCFzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuaXNEZXJpdmVkRnJvbShzY2hlbWEuZGVyaXZlZEZyb20sIGFuY2VzdG9yKTtcblxuICAgIGNhc2UgJ3VuaW9uJzpcbiAgICAgIHJldHVybiAoPEV4cFVuaW9uVHlwZT4gdHlwZSkudHlwZXNcbiAgICAgICAgLm1hcCgoc3ViVHlwZSkgPT4gdGhpcy5pc0Rlcml2ZWRGcm9tKHN1YlR5cGUsIGFuY2VzdG9yKSlcbiAgICAgICAgLnJlZHVjZSh1dGlsLm9yKTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIHR5cGU6IFwiICsgdHlwZS50eXBlKTtcbiAgICAgIH1cbiAgfVxufVxuXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9PcGVyYXRvcnMvT3BlcmF0b3JfUHJlY2VkZW5jZVxuaW50ZXJmYWNlIE9wUHJpb3JpdHkge1xuICByZXA/OiBzdHJpbmc7XG4gIHA6IG51bWJlcjtcbn1cblxudmFyIEpTX09QUzogeyBbb3A6IHN0cmluZ106IE9wUHJpb3JpdHk7IH0gPSB7XG4gICd2YWx1ZSc6IHsgcmVwOiBcIlwiLCBwOiAxOCB9LFxuXG4gICduZWcnOiB7IHJlcDogXCItXCIsIHA6IDE1fSxcbiAgJyEnOiB7IHA6IDE1fSxcbiAgJyonOiB7IHA6IDE0fSxcbiAgJy8nOiB7IHA6IDE0fSxcbiAgJyUnOiB7IHA6IDE0fSxcbiAgJysnOiB7IHA6IDEzIH0sXG4gICctJzogeyBwOiAxMyB9LFxuICAnPCc6IHsgcDogMTEgfSxcbiAgJzw9JzogeyBwOiAxMSB9LFxuICAnPic6IHsgcDogMTEgfSxcbiAgJz49JzogeyBwOiAxMSB9LFxuICAnaW4nOiB7IHA6IDExIH0sXG4gICc9PSc6IHsgcDogMTAgfSxcbiAgXCIhPVwiOiB7IHA6IDEwIH0sXG4gICcmJic6IHsgcDogNiB9LFxuICAnfHwnOiB7IHA6IDUgfSxcbiAgJz86JzogeyBwOiA0IH0sXG4gICcsJzogeyBwOiAwfSxcbn07XG5cbi8vIEZyb20gYW4gQVNULCBkZWNvZGUgYXMgYW4gZXhwcmVzc2lvbiAoc3RyaW5nKS5cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVFeHByZXNzaW9uKGV4cDogRXhwLCBvdXRlclByZWNlZGVuY2U/OiBudW1iZXIpOiBzdHJpbmcge1xuICBpZiAob3V0ZXJQcmVjZWRlbmNlID09PSB1bmRlZmluZWQpIHtcbiAgICBvdXRlclByZWNlZGVuY2UgPSAwO1xuICB9XG4gIHZhciBpbm5lclByZWNlZGVuY2UgPSBwcmVjZWRlbmNlT2YoZXhwKTtcbiAgdmFyIHJlc3VsdCA9ICcnO1xuXG4gIHN3aXRjaCAoZXhwLnR5cGUpIHtcbiAgY2FzZSAnQm9vbGVhbic6XG4gIGNhc2UgJ051bWJlcic6XG4gICAgcmVzdWx0ID0gSlNPTi5zdHJpbmdpZnkoKDxFeHBWYWx1ZT4gZXhwKS52YWx1ZSk7XG4gICAgYnJlYWs7XG5cbiAgY2FzZSAnU3RyaW5nJzpcbiAgICByZXN1bHQgPSB1dGlsLnF1b3RlU3RyaW5nKCg8RXhwVmFsdWU+IGV4cCkudmFsdWUpO1xuICAgIGJyZWFrO1xuXG4gIC8vIFJlZ0V4cCBhc3N1bWVkIHRvIGJlIGluIHByZS1xdW90ZWQgZm9ybWF0LlxuICBjYXNlICdSZWdFeHAnOlxuICAgIGxldCByZWdleHAgPSA8UmVnRXhwVmFsdWU+IGV4cDtcbiAgICByZXN1bHQgPSAnLycgKyByZWdleHAudmFsdWUgKyAnLyc7XG4gICAgaWYgKHJlZ2V4cC5tb2RpZmllcnMgIT09ICcnKSB7XG4gICAgICByZXN1bHQgKz0gcmVnZXhwLm1vZGlmaWVycztcbiAgICB9XG4gICAgYnJlYWs7XG5cbiAgY2FzZSAnQXJyYXknOlxuICAgIHJlc3VsdCA9ICdbJyArIGRlY29kZUFycmF5KCg8RXhwVmFsdWU+IGV4cCkudmFsdWUpICsgJ10nO1xuICAgIGJyZWFrO1xuXG4gIGNhc2UgJ051bGwnOlxuICAgIHJlc3VsdCA9ICdudWxsJztcbiAgICBicmVhaztcblxuICBjYXNlICd2YXInOlxuICBjYXNlICdsaXRlcmFsJzpcbiAgICByZXN1bHQgPSAoPEV4cFZhcmlhYmxlPiBleHApLm5hbWU7XG4gICAgYnJlYWs7XG5cbiAgY2FzZSAncmVmJzpcbiAgICBsZXQgZXhwUmVmID0gPEV4cFJlZmVyZW5jZT4gZXhwO1xuICAgIGlmIChpc0lkZW50aWZpZXJTdHJpbmdFeHAoZXhwUmVmLmFjY2Vzc29yKSkge1xuICAgICAgcmVzdWx0ID0gZGVjb2RlRXhwcmVzc2lvbihleHBSZWYuYmFzZSwgaW5uZXJQcmVjZWRlbmNlKSArICcuJyArICg8RXhwVmFsdWU+IGV4cFJlZi5hY2Nlc3NvcikudmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IGRlY29kZUV4cHJlc3Npb24oZXhwUmVmLmJhc2UsIGlubmVyUHJlY2VkZW5jZSkgK1xuICAgICAgICAnWycgKyBkZWNvZGVFeHByZXNzaW9uKGV4cFJlZi5hY2Nlc3NvcikgKyAnXSc7XG4gICAgfVxuICAgIGJyZWFrO1xuXG4gIGNhc2UgJ2NhbGwnOlxuICAgIGxldCBleHBDYWxsID0gPEV4cENhbGw+IGV4cDtcbiAgICByZXN1bHQgPSBkZWNvZGVFeHByZXNzaW9uKGV4cENhbGwucmVmKSArICcoJyArIGRlY29kZUFycmF5KGV4cENhbGwuYXJncykgKyAnKSc7XG4gICAgYnJlYWs7XG5cbiAgY2FzZSAnYnVpbHRpbic6XG4gICAgcmVzdWx0ID0gZGVjb2RlRXhwcmVzc2lvbihleHApO1xuICAgIGJyZWFrO1xuXG4gIGNhc2UgJ29wJzpcbiAgICBsZXQgZXhwT3AgPSA8RXhwT3A+IGV4cDtcbiAgICB2YXIgcmVwID0gSlNfT1BTW2V4cE9wLm9wXS5yZXAgPT09IHVuZGVmaW5lZCA/IGV4cE9wLm9wIDogSlNfT1BTW2V4cE9wLm9wXS5yZXA7XG4gICAgaWYgKGV4cE9wLmFyZ3MubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXN1bHQgPSByZXAgKyBkZWNvZGVFeHByZXNzaW9uKGV4cE9wLmFyZ3NbMF0sIGlubmVyUHJlY2VkZW5jZSk7XG4gICAgfSBlbHNlIGlmIChleHBPcC5hcmdzLmxlbmd0aCA9PT0gMikge1xuICAgICAgcmVzdWx0ID1cbiAgICAgICAgZGVjb2RlRXhwcmVzc2lvbihleHBPcC5hcmdzWzBdLCBpbm5lclByZWNlZGVuY2UpICtcbiAgICAgICAgJyAnICsgcmVwICsgJyAnICtcbiAgICAgICAgLy8gQWxsIG9wcyBhcmUgbGVmdCBhc3NvY2lhdGl2ZSAtIHNvIG51ZGdlIHRoZSBpbm5lclByZWNlbmRlbmNlXG4gICAgICAgIC8vIGRvd24gb24gdGhlIHJpZ2h0IGhhbmQgc2lkZSB0byBmb3JjZSAoKSBmb3IgcmlnaHQtYXNzb2NpYXRpbmdcbiAgICAgICAgLy8gb3BlcmF0aW9ucy5cbiAgICAgICAgZGVjb2RlRXhwcmVzc2lvbihleHBPcC5hcmdzWzFdLCBpbm5lclByZWNlZGVuY2UgKyAxKTtcbiAgICB9IGVsc2UgaWYgKGV4cE9wLmFyZ3MubGVuZ3RoID09PSAzKSB7XG4gICAgICByZXN1bHQgPVxuICAgICAgICBkZWNvZGVFeHByZXNzaW9uKGV4cE9wLmFyZ3NbMF0sIGlubmVyUHJlY2VkZW5jZSkgKyAnID8gJyArXG4gICAgICAgIGRlY29kZUV4cHJlc3Npb24oZXhwT3AuYXJnc1sxXSwgaW5uZXJQcmVjZWRlbmNlKSArICcgOiAnICtcbiAgICAgICAgZGVjb2RlRXhwcmVzc2lvbihleHBPcC5hcmdzWzJdLCBpbm5lclByZWNlZGVuY2UpO1xuICAgIH1cbiAgICBicmVhaztcblxuICBjYXNlICd0eXBlJzpcbiAgICByZXN1bHQgPSAoPEV4cFNpbXBsZVR5cGU+IGV4cCkubmFtZTtcbiAgICBicmVhaztcblxuICBjYXNlICd1bmlvbic6XG4gICAgcmVzdWx0ID0gKDxFeHBVbmlvblR5cGU+IGV4cCkudHlwZXMubWFwKGRlY29kZUV4cHJlc3Npb24pLmpvaW4oJyB8ICcpO1xuICAgIGJyZWFrO1xuXG4gIGNhc2UgJ2dlbmVyaWMnOlxuICAgIGxldCBnZW5lcmljVHlwZSA9IDxFeHBHZW5lcmljVHlwZT4gZXhwO1xuICAgIHJldHVybiBnZW5lcmljVHlwZS5uYW1lICsgJzwnICsgZGVjb2RlQXJyYXkoZ2VuZXJpY1R5cGUucGFyYW1zKSArICc+JztcblxuICBkZWZhdWx0OlxuICAgIHJlc3VsdCA9IFwiKioqVU5LTk9XTiBUWVBFKioqIChcIiArIGV4cC50eXBlICsgXCIpXCI7XG4gICAgYnJlYWs7XG4gIH1cblxuICBpZiAoaW5uZXJQcmVjZWRlbmNlIDwgb3V0ZXJQcmVjZWRlbmNlKSB7XG4gICAgcmVzdWx0ID0gJygnICsgcmVzdWx0ICsgJyknO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gZGVjb2RlQXJyYXkoYXJnczogRXhwW10pOiBzdHJpbmcge1xuICByZXR1cm4gYXJncy5tYXAoZGVjb2RlRXhwcmVzc2lvbikuam9pbignLCAnKTtcbn1cblxuZnVuY3Rpb24gcHJlY2VkZW5jZU9mKGV4cDogRXhwKTogbnVtYmVyIHtcbiAgbGV0IHJlc3VsdDogbnVtYmVyO1xuXG4gIHN3aXRjaCAoZXhwLnR5cGUpIHtcbiAgY2FzZSAnb3AnOlxuICAgIHJlc3VsdCA9IEpTX09QU1soPEV4cE9wPiBleHApLm9wXS5wO1xuICAgIGJyZWFrO1xuXG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL09wZXJhdG9ycy9PcGVyYXRvcl9QcmVjZWRlbmNlXG4gIC8vIGxpc3RzIGNhbGwgYXMgMTcgYW5kIHJlZiBhcyAxOCAtIGJ1dCBob3cgY291bGQgdGhleSBiZSBhbnl0aGluZyBvdGhlciB0aGFuIGxlZnQgdG8gcmlnaHQ/XG4gIC8vIGh0dHA6Ly93d3cuc2NyaXB0aW5nbWFzdGVyLmNvbS9qYXZhc2NyaXB0L29wZXJhdG9yLXByZWNlZGVuY2UuYXNwIC0gYWdyZWVzLlxuICBjYXNlICdjYWxsJzpcbiAgICByZXN1bHQgPSAxODtcbiAgICBicmVhaztcbiAgY2FzZSAncmVmJzpcbiAgICByZXN1bHQgPSAxODtcbiAgICBicmVhaztcbiAgZGVmYXVsdDpcbiAgICByZXN1bHQgPSAxOTtcbiAgICBicmVhaztcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG4iXX0=
