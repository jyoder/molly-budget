"use strict";
exports.__esModule = true;
/*
 * Copyright 2015 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var bolt = require("../bolt");
var parse = bolt.parse;
var generator = require("../rules-generator");
var ast = require("../ast");
var fileio = require("../file-io");
var logger = require("../logger");
var helper = require("./test-helper");
var sample_files_1 = require("./sample-files");
var chai = require("chai");
chai.config.truncateThreshold = 1000;
var assert = chai.assert;
// TODO: Test duplicated function, and schema definitions.
// TODO: Test other parser errors - appropriate messages (exceptions).
suite("Rules Generator Tests", function () {
    suite("Basic Samples", function () {
        var tests = [
            { data: "path / {read() { true } write() { true }}",
                expect: { rules: { ".read": "true", ".write": "true" } }
            },
            { data: "path / { write() { true }}",
                expect: { rules: { ".write": "true" } }
            },
            { data: "path / { create() { true }}",
                expect: { rules: { ".write": "data.val() == null" } }
            },
            { data: "path / { update() { true }}",
                expect: { rules: { ".write": "data.val() != null && newData.val() != null" } }
            },
            { data: "path / { delete() { true }}",
                expect: { rules: { ".write": "data.val() != null && newData.val() == null" } }
            },
            { data: "path / {read() { true }}",
                expect: { rules: { ".read": "true" } }
            },
            { data: "path / { read() { false }}",
                expect: { rules: {} }
            },
            { data: "path / {index() { return ['a', 'b']; }}",
                expect: { rules: { ".indexOn": ["a", "b"] } }
            },
            { data: "path / { validate() { return this > 0; }}",
                expect: { rules: { ".validate": "newData.val() > 0" } }
            },
        ];
        helper.dataDrivenTest(tests, function (data, expect) {
            var result = parse(data);
            assert.ok(result);
            var gen = new bolt.Generator(result);
            var json = gen.generateRules();
            assert.deepEqual(json, expect);
        });
    });
    suite("Sample files", function () {
        helper.dataDrivenTest(sample_files_1.samples, function (filename) {
            filename = 'samples/' + filename + '.' + bolt.FILE_EXTENSION;
            return fileio.readFile(filename)
                .then(function (response) {
                var result = parse(response.content);
                assert.ok(result, response.url);
                var gen = new bolt.Generator(result);
                var json = gen.generateRules();
                assert.ok('rules' in json, response.url + " has rules");
                return fileio.readJSONFile(response.url.replace('.' + bolt.FILE_EXTENSION, '.json'))
                    .then(function (response2) {
                    assert.deepEqual(json, response2);
                });
            })["catch"](function (error) {
                assert.ok(false, error.message);
            });
        });
    });
    suite("Partial evaluation", function () {
        var tests = [
            { f: "function f(a) { return true == a; }", x: "f(a == b)", expect: "true == (a == b)" },
            { f: "function f(a) { return a == true; }", x: "f(a == b)", expect: "a == b == true" },
            { f: "function f(a) { return a + 3; }", x: "f(1 + 2)", expect: "1 + 2 + 3" },
            { f: "function f(a) { return a + 3; }", x: "f(1 * 2)", expect: "1 * 2 + 3" },
            { f: "function f(a) { return a * 3; }", x: "f(1 + 2)", expect: "(1 + 2) * 3" },
            { f: "function f(a) { return a + 1; }", x: "f(a + a)", expect: "a + a + 1" },
            { f: "function f(a) { return g(a); } function g(a) { return a == true; }",
                x: "f(123)", expect: "123 == true" },
            { f: "function f(a, b) { return g(a) == g(b); } function g(a) { return a == true; }",
                x: "f(1, 2)", expect: "1 == true == (2 == true)" },
            // Highler level function works as long as returns a constant function
            { f: "function f() { return g; } function g(a) { return a == true; }",
                x: "f()(123)", expect: "123 == true" },
            { f: "function f(a) { return a + 1; }", x: "a[f(123)]", expect: "a[123 + 1]" },
            { f: "", x: "this", expect: "newData.val() == true" },
            { f: "", x: "!this", expect: "!(newData.val() == true)" },
            { f: "", x: "this.prop", expect: "newData.child('prop').val() == true" },
            { f: "", x: "!this.prop", expect: "!(newData.child('prop').val() == true)" },
            { f: "", x: "this.foo.parent()", expect: "newData.child('foo').parent().val() == true" },
            { f: "",
                x: "this.foo || this.bar",
                expect: "newData.child('foo').val() == true || newData.child('bar').val() == true" },
            // TODO: Don't support snapshot functions beyond parent.
            // TODO: Should warn user not to use Firebase builtins!
            // { f: "", x: "this.isString()", expect: "newData.child('isString').val() == true" },
            { f: "function f(a) { return a == '123'; }", x: "f(this)", expect: "newData.val() == '123'" },
            { f: "function f(a) { return a == '123'; }",
                x: "f(this.foo)", expect: "newData.child('foo').val() == '123'" },
        ];
        helper.dataDrivenTest(tests, function (data, expect) {
            var symbols = parse(data.f + " path /x { write() { return " + data.x + "; }}");
            var gen = new bolt.Generator(symbols);
            // Make sure local Schema initialized.
            var json = gen.generateRules();
            assert.equal(json['rules']['x']['.write'], expect);
        });
    });
    suite("String methods", function () {
        var tests = [
            { data: "this.length",
                expect: "newData.val().length" },
            { data: "this.length < 100",
                expect: "newData.val().length < 100" },
            { data: "'abc'.length",
                expect: "'abc'.length" },
            { data: "'abc'.includes('b')",
                expect: "'abc'.contains('b')" },
            { data: "this.includes('b')",
                expect: "newData.val().contains('b')" },
            { data: "'abc'.includes(this)",
                expect: "'abc'.contains(newData.val())" },
            { data: "'abc'.startsWith(this)",
                expect: "'abc'.beginsWith(newData.val())" },
            { data: "'abc'.endsWith(this)",
                expect: "'abc'.endsWith(newData.val())" },
            { data: "'abc'.replace(this.a, this.b)",
                expect: "'abc'.replace(newData.child('a').val(), newData.child('b').val())" },
            { data: "'ABC'.toLowerCase()",
                expect: "'ABC'.toLowerCase()" },
            { data: "'abc'.toUpperCase()",
                expect: "'abc'.toUpperCase()" },
            { data: "this.toUpperCase()",
                expect: "newData.val().toUpperCase()" },
            { data: "'ababa'.test(/bab/)",
                expect: "'ababa'.matches(/bab/)" },
        ];
        helper.dataDrivenTest(tests, function (data, expect) {
            var symbols = parse("path /x { write() { return " + data + "; }}");
            var gen = new bolt.Generator(symbols);
            // Make sure local Schema initialized.
            var json = gen.generateRules();
            assert.equal(json['rules']['x']['.write'], expect);
        });
    });
    suite("Builtin validation functions", function () {
        var tests = [
            ['String', 'this.isString()'],
            ['Number', 'this.isNumber()'],
            ['Boolean', 'this.isBoolean()'],
            ['Object', 'this.hasChildren()'],
            ['Null', 'false'],
        ];
        helper.dataDrivenTest(tests, function (data, expect) {
            var symbols = parse("path / {}");
            var gen = new bolt.Generator(symbols);
            gen.ensureValidator(ast.typeType(data));
            var terms = gen.validators[data]['.validate'];
            var result = bolt.decodeExpression(ast.andArray(terms));
            assert.deepEqual(result, expect);
        });
    });
    suite("Schema Validation", function () {
        var tests = [
            { data: "type T {}",
                expect: undefined },
            { data: "type T extends Object {}",
                expect: { '.validate': "newData.hasChildren()" } },
            { data: "type T extends String {}",
                expect: { '.validate': "newData.isString()" } },
            { data: "type T extends String { validate() { return this.length > 0; } }",
                expect: { '.validate': "newData.isString() && newData.val().length > 0" } },
            { data: "type NonEmpty extends String { validate() { return this.length > 0; } } \
            type T { prop: NonEmpty }",
                expect: { '.validate': "newData.hasChildren(['prop'])",
                    prop: {
                        '.validate': 'newData.isString() && newData.val().length > 0'
                    },
                    '$other': { '.validate': "false" }
                } },
            { data: "type T {n: Number}",
                expect: { '.validate': "newData.hasChildren(['n'])",
                    n: { '.validate': "newData.isNumber()" },
                    '$other': { '.validate': "false" } } },
            { data: "type T {s: String}",
                expect: { '.validate': "newData.hasChildren(['s'])",
                    s: { '.validate': "newData.isString()" },
                    '$other': { '.validate': "false" } } },
            { data: "type T {b: Boolean}",
                expect: { '.validate': "newData.hasChildren(['b'])",
                    b: { '.validate': "newData.isBoolean()" },
                    '$other': { '.validate': "false" } } },
            { data: "type T {x: Object}",
                expect: { '.validate': "newData.hasChildren(['x'])",
                    x: { '.validate': "newData.hasChildren()" },
                    '$other': { '.validate': "false" } } },
            { data: "type T {x: Number|String}",
                expect: { '.validate': "newData.hasChildren(['x'])",
                    x: { '.validate': "newData.isNumber() || newData.isString()" },
                    '$other': { '.validate': "false" } } },
            { data: "type T { $key: Number }",
                expect: { '.validate': "newData.hasChildren()",
                    '$key': { '.validate': "newData.isNumber()" } } },
            { data: "type T { 'a b': Number }",
                expect: { '.validate': "newData.hasChildren(['a b'])",
                    'a b': { '.validate': "newData.isNumber()" },
                    '$other': { '.validate': 'false' } } },
            { data: "type T {a: Number, b: String}",
                expect: { '.validate': "newData.hasChildren(['a', 'b'])",
                    a: { '.validate': "newData.isNumber()" },
                    b: { '.validate': "newData.isString()" },
                    '$other': { '.validate': "false" } } },
            { data: "type T {x: Number|Null}",
                expect: { '.validate': "newData.hasChildren()",
                    x: { '.validate': "newData.isNumber()" },
                    '$other': { '.validate': "false" } } },
            { data: "type T {n: Number, validate() {return this.n < 7;}}",
                expect: { '.validate': "newData.hasChildren(['n']) && newData.child('n').val() < 7",
                    n: { '.validate': "newData.isNumber()" },
                    '$other': { '.validate': "false" } } },
            { data: "type Bigger extends Number {validate() { return this > prior(this); }}" +
                    "type T { ts: Bigger }",
                expect: { '.validate': "newData.hasChildren(['ts'])",
                    ts: { '.validate': "newData.isNumber() && newData.val() > data.val()" },
                    '$other': { '.validate': "false" } } },
            { data: "type T {a: String, b: String, c: String}",
                expect: { '.validate': "newData.hasChildren(['a', 'b', 'c'])",
                    a: { '.validate': "newData.isString()" },
                    b: { '.validate': "newData.isString()" },
                    c: { '.validate': "newData.isString()" },
                    '$other': { '.validate': "false" } } },
            { data: "type B { foo: Number } type T extends B { bar: String }",
                expect: { '.validate': "newData.hasChildren(['foo', 'bar'])",
                    foo: { '.validate': "newData.isNumber()" },
                    bar: { '.validate': "newData.isString()" },
                    '$other': { '.validate': "false" } } },
            { data: "type T {n: Number, x: Map<String, Number>}",
                expect: { '.validate': "newData.hasChildren(['n'])",
                    n: { '.validate': "newData.isNumber()" },
                    x: { '$key1': { '.validate': "newData.isNumber()" },
                        '.validate': "newData.hasChildren()" },
                    '$other': { '.validate': "false" } } },
            { data: "type T {x: Map<String, Number>}",
                expect: { '.validate': "newData.hasChildren()",
                    x: { '$key1': { '.validate': "newData.isNumber()" },
                        '.validate': "newData.hasChildren()" },
                    '$other': { '.validate': "false" } } },
            { data: "type SmallString extends String { validate() { this.length < 32 } } " +
                    "type T {x: Map<SmallString, Number>}",
                expect: { '.validate': "newData.hasChildren()",
                    x: { '$key1': { '.validate': "$key1.length < 32 && newData.isNumber()" },
                        '.validate': "newData.hasChildren()" },
                    '$other': { '.validate': "false" } } },
            { data: "type M extends Map<String, Number>; type T { x: M }",
                expect: { '.validate': "newData.hasChildren()",
                    '$other': { '.validate': "false" },
                    'x': { '$key1': { '.validate': "newData.isNumber()" },
                        '.validate': "newData.hasChildren()" } } },
            { data: "type Pair<X, Y> { first: X, second: Y } type T extends Pair<String, Number>;",
                expect: { '.validate': "newData.hasChildren(['first', 'second'])",
                    'first': { '.validate': "newData.isString()" },
                    'second': { '.validate': "newData.isNumber()" },
                    '$other': { '.validate': "false" } } },
            { data: "type X { a: Number, validate() { this.a == key() } } type T extends X[];",
                expect: { '$key1': { '.validate': "newData.hasChildren(['a']) && newData.child('a').val() == $key1",
                        'a': { '.validate': "newData.isNumber()" },
                        '$other': { '.validate': "false" } },
                    '.validate': "newData.hasChildren()"
                } },
            { data: "type X { a: Number, validate() { this.a == key() } } type T { x: X }",
                expect: { 'x': { '.validate': "newData.hasChildren(['a']) && newData.child('a').val() == 'x'",
                        'a': { '.validate': "newData.isNumber()" },
                        '$other': { '.validate': "false" } },
                    '$other': { '.validate': "false" },
                    '.validate': "newData.hasChildren(['x'])"
                } },
            { data: "type T extends String { validate() { root == 'new' && prior(root) == 'old' } }" +
                    "path /t/x is Any { read() { root == 'old' } }",
                expect: { '.validate': "newData.isString() && newData.parent().val() == 'new' && root.val() == 'old'",
                    'x': { '.read': "root.val() == 'old'" }
                } },
        ];
        helper.dataDrivenTest(tests, function (data, expect) {
            var symbols = parse(data + " path /t is T;");
            var gen = new bolt.Generator(symbols);
            var rules = gen.generateRules();
            if (expect === undefined) {
                assert.deepEqual(rules, { "rules": {} });
            }
            else {
                assert.deepEqual(rules, { "rules": { t: expect } });
            }
        });
    });
    suite("extendValidator", function () {
        var tests = [
            { data: { target: {}, src: {} },
                expect: {} },
            { data: { target: {}, src: { '.x': [1] } },
                expect: { '.x': [1] } },
            { data: { target: { '.x': [1] }, src: { '.x': [2] } },
                expect: { '.x': [1, 2] } },
            { data: { target: { '.x': [1] }, src: { '.x': [2], c: { '.x': [3] } } },
                expect: { '.x': [1, 2], c: { '.x': [3] } } },
            { data: { target: { '.x': [1], c: { '.x': [2] } }, src: { c: { '.x': [3] } } },
                expect: { '.x': [1], c: { '.x': [2, 3] } } },
            { data: { target: {}, src: { a: { b: { c: { d: { '.x': [1], e: { '.x': [2] } } } } } } },
                expect: { a: { b: { c: { d: { '.x': [1], e: { '.x': [2] } } } } } } },
        ];
        helper.dataDrivenTest(tests, function (data, expect) {
            generator.extendValidator(data.target, data.src);
            assert.deepEqual(data.target, expect);
        });
    });
    suite("mapValidator", function () {
        var tests = [
            { data: { '.x': 'a' }, expect: { '.x': 'a+' } },
            { data: { '.x': 'b' }, expect: {} },
        ];
        helper.dataDrivenTest(tests, function (data, expect) {
            generator.mapValidator(data, function (value, prop) {
                if (value === 'b') {
                    return undefined;
                }
                return value + '+';
            });
            assert.deepEqual(data, expect);
        });
    });
    suite("Schema Generation Errors", function () {
        var tests = [
            { data: "",
                expect: /at least one path/ },
            { data: "type Simple extends String {a: String} path /x is Simple;",
                expect: /properties.*extend/ },
            { data: "path /y { index() { return 1; }}",
                expect: /index.*string/i },
            { data: "path /x { write() { return undefinedFunc(); }}",
                expect: /undefined.*function/i },
            { data: "path /x is NoSuchType {}",
                expect: /No type.*NoSuchType/ },
            { data: "path /x { unsupported() { true } }",
                warn: /unsupported method/i },
            { data: "path /x { validate() { return this.test(123); } }",
                expect: /convert value/i },
            { data: "path /x { validate() { return this.test('a/'); } }",
                expect: /convert value/i },
            { data: "path /x { validate() { return this.test('/a/'); } }",
                expect: /convert value/i },
            { data: "function f(a) { return f(a); } path / { validate() { return f(1); }}",
                expect: /recursive/i },
            { data: "type X { $n: Number, $s: String } path / is X;",
                expect: /wild property/ },
            { data: "type X { $$n: Number } path / is X;",
                expect: /property names/i },
            { data: "type X { '\x01': Number } path / is X;",
                expect: /property names/i },
            { data: "path / is Map;",
                expect: /No type.*non-generic/ },
            { data: "type Pair<X, Y> {a: X, b: Y} path / is Pair;",
                expect: /No type.*non-generic/ },
            { data: "path / is String<Number>;",
                expect: /No type.*generic/ },
            { data: "path / is Map<Object, Number>;",
                expect: /must derive from String/ },
            { data: "path / { write() { true } create() { true } }",
                expect: /write-aliasing.*create/i },
            { data: "path / { write() { true } update() { true } }",
                expect: /write-aliasing.*update/i },
            { data: "path / { write() { true } delete() { true } }",
                expect: /write-aliasing.*delete/i },
        ];
        helper.dataDrivenTest(tests, function (data, expect, t) {
            logger.reset();
            logger.silent();
            var symbols = parse(data);
            var gen = new bolt.Generator(symbols);
            var lastError;
            try {
                gen.generateRules();
            }
            catch (e) {
                if (!expect) {
                    throw e;
                }
                lastError = logger.getLastMessage() || e.message;
                assert.match(lastError, expect);
                return;
            }
            if (expect) {
                assert.fail(undefined, undefined, "No exception thrown.");
            }
            if (t.warn) {
                assert.match(logger.getLastMessage(), t.warn);
            }
        });
    });
});

//# sourceMappingURL=data:application/json;charset=utf8;base64,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QUFFO1lBQzFCLEVBQUUsSUFBSSxFQUFFLEVBQUMsTUFBTSxFQUFFLEVBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxHQUFHLEVBQUUsRUFBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBQyxFQUFDLEVBQUM7Z0JBQzdELE1BQU0sRUFBRSxFQUFDLElBQUksRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBQyxFQUFDLEVBQUU7WUFDMUMsRUFBRSxJQUFJLEVBQUUsRUFBQyxNQUFNLEVBQUUsRUFBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBQyxFQUFDLEVBQUUsR0FBRyxFQUFFLEVBQUMsQ0FBQyxFQUFFLEVBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBQyxFQUFDO2dCQUNsRSxNQUFNLEVBQUUsRUFBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUMsRUFBQyxFQUFFO1lBQzFDLEVBQUUsSUFBSSxFQUFFLEVBQUMsTUFBTSxFQUFFLEVBQUUsRUFBRSxHQUFHLEVBQUUsRUFBQyxDQUFDLEVBQUUsRUFBQyxDQUFDLEVBQUUsRUFBQyxDQUFDLEVBQUUsRUFBQyxDQUFDLEVBQUUsRUFBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBQyxFQUFDLEVBQUMsRUFBQyxFQUFDLEVBQUMsRUFBQztnQkFDeEUsTUFBTSxFQUFFLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxFQUFFLEVBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBQyxFQUFDLEVBQUMsRUFBQyxFQUFDLEVBQUU7U0FDNUQsQ0FBQztRQUVGLE1BQU0sQ0FBQyxjQUFjLENBQUMsS0FBSyxFQUFFLFVBQVMsSUFBSSxFQUFFLE1BQU07WUFDaEQsU0FBUyxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUNqRCxNQUFNLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsTUFBTSxDQUFDLENBQUM7UUFDeEMsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDLENBQUMsQ0FBQztJQUVILEtBQUssQ0FBQyxjQUFjLEVBQUU7UUFDcEIsSUFBSSxLQUFLLEdBQUc7WUFDVixFQUFFLElBQUksRUFBRSxFQUFDLElBQUksRUFBRSxHQUFHLEVBQUMsRUFBRSxNQUFNLEVBQUUsRUFBQyxJQUFJLEVBQUUsSUFBSSxFQUFDLEVBQUU7WUFDM0MsRUFBRSxJQUFJLEVBQUUsRUFBQyxJQUFJLEVBQUUsR0FBRyxFQUFDLEVBQUUsTUFBTSxFQUFFLEVBQUUsRUFBRTtTQUNsQyxDQUFDO1FBRUYsTUFBTSxDQUFDLGNBQWMsQ0FBQyxLQUFLLEVBQUUsVUFBUyxJQUFJLEVBQUUsTUFBTTtZQUNoRCxTQUFTLENBQUMsWUFBWSxDQUFDLElBQUksRUFBRSxVQUFTLEtBQUssRUFBRSxJQUFJO2dCQUMvQyxJQUFJLEtBQUssS0FBSyxHQUFHLEVBQUU7b0JBQ2pCLE9BQU8sU0FBUyxDQUFDO2lCQUNsQjtnQkFDRCxPQUFPLEtBQUssR0FBRyxHQUFHLENBQUM7WUFDckIsQ0FBQyxDQUFDLENBQUM7WUFDSCxNQUFNLENBQUMsU0FBUyxDQUFDLElBQUksRUFBRSxNQUFNLENBQUMsQ0FBQztRQUNqQyxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUMsQ0FBQyxDQUFDO0lBRUgsS0FBSyxDQUFDLDBCQUEwQixFQUFFO1FBQ2hDLElBQUksS0FBSyxHQUFHO1lBQ1YsRUFBRSxJQUFJLEVBQUUsRUFBRTtnQkFDUixNQUFNLEVBQUUsbUJBQW1CLEVBQUU7WUFDL0IsRUFBRSxJQUFJLEVBQUUsMkRBQTJEO2dCQUNqRSxNQUFNLEVBQUUsb0JBQW9CLEVBQUU7WUFDaEMsRUFBRSxJQUFJLEVBQUUsa0NBQWtDO2dCQUN4QyxNQUFNLEVBQUUsZ0JBQWdCLEVBQUU7WUFDNUIsRUFBRSxJQUFJLEVBQUUsZ0RBQWdEO2dCQUN0RCxNQUFNLEVBQUUsc0JBQXNCLEVBQUU7WUFDbEMsRUFBRSxJQUFJLEVBQUUsMEJBQTBCO2dCQUNoQyxNQUFNLEVBQUUscUJBQXFCLEVBQUU7WUFDakMsRUFBRSxJQUFJLEVBQUUsb0NBQW9DO2dCQUMxQyxJQUFJLEVBQUUscUJBQXFCLEVBQUU7WUFFL0IsRUFBRSxJQUFJLEVBQUUsbURBQW1EO2dCQUN6RCxNQUFNLEVBQUUsZ0JBQWdCLEVBQUU7WUFDNUIsRUFBRSxJQUFJLEVBQUUsb0RBQW9EO2dCQUMxRCxNQUFNLEVBQUUsZ0JBQWdCLEVBQUU7WUFDNUIsRUFBRSxJQUFJLEVBQUUscURBQXFEO2dCQUMzRCxNQUFNLEVBQUUsZ0JBQWdCLEVBQUU7WUFFNUIsRUFBRSxJQUFJLEVBQUUsc0VBQXNFO2dCQUM1RSxNQUFNLEVBQUUsWUFBWSxFQUFFO1lBQ3hCLEVBQUUsSUFBSSxFQUFFLGdEQUFnRDtnQkFDdEQsTUFBTSxFQUFFLGVBQWUsRUFBRTtZQUMzQixFQUFFLElBQUksRUFBRSxxQ0FBcUM7Z0JBQzNDLE1BQU0sRUFBRSxpQkFBaUIsRUFBRTtZQUM3QixFQUFFLElBQUksRUFBRSx3Q0FBd0M7Z0JBQzlDLE1BQU0sRUFBRSxpQkFBaUIsRUFBRTtZQUM3QixFQUFFLElBQUksRUFBRSxnQkFBZ0I7Z0JBQ3RCLE1BQU0sRUFBRSxzQkFBc0IsRUFBRTtZQUNsQyxFQUFFLElBQUksRUFBRSw4Q0FBOEM7Z0JBQ3BELE1BQU0sRUFBRSxzQkFBc0IsRUFBRTtZQUNsQyxFQUFFLElBQUksRUFBRSwyQkFBMkI7Z0JBQ2pDLE1BQU0sRUFBRSxrQkFBa0IsRUFBRTtZQUM5QixFQUFFLElBQUksRUFBRSxnQ0FBZ0M7Z0JBQ3RDLE1BQU0sRUFBRSx5QkFBeUIsRUFBRTtZQUNyQyxFQUFFLElBQUksRUFBRSwrQ0FBK0M7Z0JBQ3JELE1BQU0sRUFBRSx5QkFBeUIsRUFBRTtZQUNyQyxFQUFFLElBQUksRUFBRSwrQ0FBK0M7Z0JBQ3JELE1BQU0sRUFBRSx5QkFBeUIsRUFBRTtZQUNyQyxFQUFFLElBQUksRUFBRSwrQ0FBK0M7Z0JBQ3JELE1BQU0sRUFBRSx5QkFBeUIsRUFBRTtTQUN0QyxDQUFDO1FBRUYsTUFBTSxDQUFDLGNBQWMsQ0FBQyxLQUFLLEVBQUUsVUFBUyxJQUFJLEVBQUUsTUFBTSxFQUFFLENBQUM7WUFDbkQsTUFBTSxDQUFDLEtBQUssRUFBRSxDQUFDO1lBQ2YsTUFBTSxDQUFDLE1BQU0sRUFBRSxDQUFDO1lBQ2hCLElBQUksT0FBTyxHQUFHLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUMxQixJQUFJLEdBQUcsR0FBRyxJQUFJLElBQUksQ0FBQyxTQUFTLENBQUMsT0FBTyxDQUFDLENBQUM7WUFDdEMsSUFBSSxTQUFpQixDQUFDO1lBRXRCLElBQUk7Z0JBQ0YsR0FBRyxDQUFDLGFBQWEsRUFBRSxDQUFDO2FBQ3JCO1lBQUMsT0FBTyxDQUFDLEVBQUU7Z0JBQ1YsSUFBSSxDQUFDLE1BQU0sRUFBRTtvQkFDWCxNQUFNLENBQUMsQ0FBQztpQkFDVDtnQkFDRCxTQUFTLEdBQUcsTUFBTSxDQUFDLGNBQWMsRUFBRSxJQUFJLENBQUMsQ0FBQyxPQUFPLENBQUM7Z0JBQ2pELE1BQU0sQ0FBQyxLQUFLLENBQUMsU0FBUyxFQUFFLE1BQU0sQ0FBQyxDQUFDO2dCQUNoQyxPQUFPO2FBQ1I7WUFDRCxJQUFJLE1BQU0sRUFBRTtnQkFDVixNQUFNLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRSxTQUFTLEVBQUUsc0JBQXNCLENBQUMsQ0FBQzthQUMzRDtZQUNELElBQUksQ0FBQyxDQUFDLElBQUksRUFBRTtnQkFDVixNQUFNLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxjQUFjLEVBQUUsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUM7YUFDL0M7UUFDSCxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQyxDQUFDLENBQUMiLCJmaWxlIjoidGVzdC9nZW5lcmF0b3ItdGVzdC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBDb3B5cmlnaHQgMjAxNSBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuaW1wb3J0ICogYXMgYm9sdCBmcm9tICcuLi9ib2x0JztcbmxldCBwYXJzZSA9IGJvbHQucGFyc2U7XG5pbXBvcnQgKiBhcyBnZW5lcmF0b3IgZnJvbSAnLi4vcnVsZXMtZ2VuZXJhdG9yJztcbmltcG9ydCAqIGFzIGFzdCBmcm9tICcuLi9hc3QnO1xuaW1wb3J0ICogYXMgZmlsZWlvIGZyb20gJy4uL2ZpbGUtaW8nO1xuaW1wb3J0ICogYXMgbG9nZ2VyIGZyb20gJy4uL2xvZ2dlcic7XG5pbXBvcnQgKiBhcyBoZWxwZXIgZnJvbSAnLi90ZXN0LWhlbHBlcic7XG5pbXBvcnQge3NhbXBsZXN9IGZyb20gJy4vc2FtcGxlLWZpbGVzJztcblxuaW1wb3J0ICogYXMgY2hhaSBmcm9tICdjaGFpJztcbmNoYWkuY29uZmlnLnRydW5jYXRlVGhyZXNob2xkID0gMTAwMDtcbmxldCBhc3NlcnQgPSBjaGFpLmFzc2VydDtcblxuLy8gVE9ETzogVGVzdCBkdXBsaWNhdGVkIGZ1bmN0aW9uLCBhbmQgc2NoZW1hIGRlZmluaXRpb25zLlxuLy8gVE9ETzogVGVzdCBvdGhlciBwYXJzZXIgZXJyb3JzIC0gYXBwcm9wcmlhdGUgbWVzc2FnZXMgKGV4Y2VwdGlvbnMpLlxuXG5zdWl0ZShcIlJ1bGVzIEdlbmVyYXRvciBUZXN0c1wiLCBmdW5jdGlvbigpIHtcbiAgc3VpdGUoXCJCYXNpYyBTYW1wbGVzXCIsIGZ1bmN0aW9uKCkge1xuICAgIHZhciB0ZXN0cyA9IFtcbiAgICAgIHsgZGF0YTogXCJwYXRoIC8ge3JlYWQoKSB7IHRydWUgfSB3cml0ZSgpIHsgdHJ1ZSB9fVwiLFxuICAgICAgICBleHBlY3Q6IHsgcnVsZXM6IHtcIi5yZWFkXCI6IFwidHJ1ZVwiLCBcIi53cml0ZVwiOiBcInRydWVcIn0gfVxuICAgICAgfSxcbiAgICAgIHsgZGF0YTogXCJwYXRoIC8geyB3cml0ZSgpIHsgdHJ1ZSB9fVwiLFxuICAgICAgICBleHBlY3Q6IHsgcnVsZXM6IHtcIi53cml0ZVwiOiBcInRydWVcIn0gfVxuICAgICAgfSxcbiAgICAgIHsgZGF0YTogXCJwYXRoIC8geyBjcmVhdGUoKSB7IHRydWUgfX1cIixcbiAgICAgICAgZXhwZWN0OiB7IHJ1bGVzOiB7XCIud3JpdGVcIjogXCJkYXRhLnZhbCgpID09IG51bGxcIn0gfVxuICAgICAgfSxcbiAgICAgIHsgZGF0YTogXCJwYXRoIC8geyB1cGRhdGUoKSB7IHRydWUgfX1cIixcbiAgICAgICAgZXhwZWN0OiB7IHJ1bGVzOiB7XCIud3JpdGVcIjogXCJkYXRhLnZhbCgpICE9IG51bGwgJiYgbmV3RGF0YS52YWwoKSAhPSBudWxsXCJ9IH1cbiAgICAgIH0sXG4gICAgICB7IGRhdGE6IFwicGF0aCAvIHsgZGVsZXRlKCkgeyB0cnVlIH19XCIsXG4gICAgICAgIGV4cGVjdDogeyBydWxlczoge1wiLndyaXRlXCI6IFwiZGF0YS52YWwoKSAhPSBudWxsICYmIG5ld0RhdGEudmFsKCkgPT0gbnVsbFwifSB9XG4gICAgICB9LFxuICAgICAgeyBkYXRhOiBcInBhdGggLyB7cmVhZCgpIHsgdHJ1ZSB9fVwiLFxuICAgICAgICBleHBlY3Q6IHsgcnVsZXM6IHtcIi5yZWFkXCI6IFwidHJ1ZVwifSB9XG4gICAgICB9LFxuICAgICAgeyBkYXRhOiBcInBhdGggLyB7IHJlYWQoKSB7IGZhbHNlIH19XCIsXG4gICAgICAgIGV4cGVjdDogeyBydWxlczoge30gfVxuICAgICAgfSxcbiAgICAgIHsgZGF0YTogXCJwYXRoIC8ge2luZGV4KCkgeyByZXR1cm4gWydhJywgJ2InXTsgfX1cIixcbiAgICAgICAgZXhwZWN0OiB7IHJ1bGVzOiB7XCIuaW5kZXhPblwiOiBbXCJhXCIsIFwiYlwiXX0gfVxuICAgICAgfSxcbiAgICAgIHsgZGF0YTogXCJwYXRoIC8geyB2YWxpZGF0ZSgpIHsgcmV0dXJuIHRoaXMgPiAwOyB9fVwiLFxuICAgICAgICBleHBlY3Q6IHsgcnVsZXM6IHsgXCIudmFsaWRhdGVcIjogXCJuZXdEYXRhLnZhbCgpID4gMFwiIH0gfVxuICAgICAgfSxcbiAgICBdO1xuXG4gICAgaGVscGVyLmRhdGFEcml2ZW5UZXN0KHRlc3RzLCBmdW5jdGlvbihkYXRhLCBleHBlY3QpIHtcbiAgICAgIHZhciByZXN1bHQgPSBwYXJzZShkYXRhKTtcbiAgICAgIGFzc2VydC5vayhyZXN1bHQpO1xuICAgICAgdmFyIGdlbiA9IG5ldyBib2x0LkdlbmVyYXRvcihyZXN1bHQpO1xuICAgICAgdmFyIGpzb24gPSBnZW4uZ2VuZXJhdGVSdWxlcygpO1xuICAgICAgYXNzZXJ0LmRlZXBFcXVhbChqc29uLCBleHBlY3QpO1xuICAgIH0pO1xuICB9KTtcblxuICBzdWl0ZShcIlNhbXBsZSBmaWxlc1wiLCBmdW5jdGlvbigpIHtcbiAgICBoZWxwZXIuZGF0YURyaXZlblRlc3Qoc2FtcGxlcywgZnVuY3Rpb24oZmlsZW5hbWUpIHtcbiAgICAgIGZpbGVuYW1lID0gJ3NhbXBsZXMvJyArIGZpbGVuYW1lICsgJy4nICsgYm9sdC5GSUxFX0VYVEVOU0lPTjtcbiAgICAgIHJldHVybiBmaWxlaW8ucmVhZEZpbGUoZmlsZW5hbWUpXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IHBhcnNlKHJlc3BvbnNlLmNvbnRlbnQpO1xuICAgICAgICAgIGFzc2VydC5vayhyZXN1bHQsIHJlc3BvbnNlLnVybCk7XG4gICAgICAgICAgdmFyIGdlbiA9IG5ldyBib2x0LkdlbmVyYXRvcihyZXN1bHQpO1xuICAgICAgICAgIHZhciBqc29uID0gZ2VuLmdlbmVyYXRlUnVsZXMoKTtcbiAgICAgICAgICBhc3NlcnQub2soJ3J1bGVzJyBpbiBqc29uLCByZXNwb25zZS51cmwgKyBcIiBoYXMgcnVsZXNcIik7XG4gICAgICAgICAgcmV0dXJuIGZpbGVpby5yZWFkSlNPTkZpbGUocmVzcG9uc2UudXJsLnJlcGxhY2UoJy4nICsgYm9sdC5GSUxFX0VYVEVOU0lPTiwgJy5qc29uJykpXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbihyZXNwb25zZTIpIHtcbiAgICAgICAgICAgICAgYXNzZXJ0LmRlZXBFcXVhbChqc29uLCByZXNwb25zZTIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaChmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgIGFzc2VydC5vayhmYWxzZSwgZXJyb3IubWVzc2FnZSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcblxuICBzdWl0ZShcIlBhcnRpYWwgZXZhbHVhdGlvblwiLCBmdW5jdGlvbigpIHtcbiAgICB2YXIgdGVzdHMgPSBbXG4gICAgICB7IGY6IFwiZnVuY3Rpb24gZihhKSB7IHJldHVybiB0cnVlID09IGE7IH1cIiwgeDogXCJmKGEgPT0gYilcIiwgZXhwZWN0OiBcInRydWUgPT0gKGEgPT0gYilcIiB9LFxuICAgICAgeyBmOiBcImZ1bmN0aW9uIGYoYSkgeyByZXR1cm4gYSA9PSB0cnVlOyB9XCIsIHg6IFwiZihhID09IGIpXCIsIGV4cGVjdDogXCJhID09IGIgPT0gdHJ1ZVwiIH0sXG4gICAgICB7IGY6IFwiZnVuY3Rpb24gZihhKSB7IHJldHVybiBhICsgMzsgfVwiLCB4OiBcImYoMSArIDIpXCIsIGV4cGVjdDogXCIxICsgMiArIDNcIiB9LFxuICAgICAgeyBmOiBcImZ1bmN0aW9uIGYoYSkgeyByZXR1cm4gYSArIDM7IH1cIiwgeDogXCJmKDEgKiAyKVwiLCBleHBlY3Q6IFwiMSAqIDIgKyAzXCIgfSxcbiAgICAgIHsgZjogXCJmdW5jdGlvbiBmKGEpIHsgcmV0dXJuIGEgKiAzOyB9XCIsIHg6IFwiZigxICsgMilcIiwgZXhwZWN0OiBcIigxICsgMikgKiAzXCIgfSxcbiAgICAgIHsgZjogXCJmdW5jdGlvbiBmKGEpIHsgcmV0dXJuIGEgKyAxOyB9XCIsIHg6IFwiZihhICsgYSlcIiwgZXhwZWN0OiBcImEgKyBhICsgMVwiIH0sXG4gICAgICB7IGY6IFwiZnVuY3Rpb24gZihhKSB7IHJldHVybiBnKGEpOyB9IGZ1bmN0aW9uIGcoYSkgeyByZXR1cm4gYSA9PSB0cnVlOyB9XCIsXG4gICAgICAgIHg6IFwiZigxMjMpXCIsIGV4cGVjdDogXCIxMjMgPT0gdHJ1ZVwiIH0sXG4gICAgICB7IGY6IFwiZnVuY3Rpb24gZihhLCBiKSB7IHJldHVybiBnKGEpID09IGcoYik7IH0gZnVuY3Rpb24gZyhhKSB7IHJldHVybiBhID09IHRydWU7IH1cIixcbiAgICAgICAgeDogXCJmKDEsIDIpXCIsIGV4cGVjdDogXCIxID09IHRydWUgPT0gKDIgPT0gdHJ1ZSlcIiB9LFxuICAgICAgLy8gSGlnaGxlciBsZXZlbCBmdW5jdGlvbiB3b3JrcyBhcyBsb25nIGFzIHJldHVybnMgYSBjb25zdGFudCBmdW5jdGlvblxuICAgICAgeyBmOiBcImZ1bmN0aW9uIGYoKSB7IHJldHVybiBnOyB9IGZ1bmN0aW9uIGcoYSkgeyByZXR1cm4gYSA9PSB0cnVlOyB9XCIsXG4gICAgICAgIHg6IFwiZigpKDEyMylcIiwgZXhwZWN0OiBcIjEyMyA9PSB0cnVlXCIgfSxcbiAgICAgIHsgZjogXCJmdW5jdGlvbiBmKGEpIHsgcmV0dXJuIGEgKyAxOyB9XCIsIHg6IFwiYVtmKDEyMyldXCIsIGV4cGVjdDogXCJhWzEyMyArIDFdXCIgfSxcbiAgICAgIHsgZjogXCJcIiwgeDogXCJ0aGlzXCIsIGV4cGVjdDogXCJuZXdEYXRhLnZhbCgpID09IHRydWVcIiB9LFxuICAgICAgeyBmOiBcIlwiLCB4OiBcIiF0aGlzXCIsIGV4cGVjdDogXCIhKG5ld0RhdGEudmFsKCkgPT0gdHJ1ZSlcIiB9LFxuICAgICAgeyBmOiBcIlwiLCB4OiBcInRoaXMucHJvcFwiLCBleHBlY3Q6IFwibmV3RGF0YS5jaGlsZCgncHJvcCcpLnZhbCgpID09IHRydWVcIiB9LFxuICAgICAgeyBmOiBcIlwiLCB4OiBcIiF0aGlzLnByb3BcIiwgZXhwZWN0OiBcIiEobmV3RGF0YS5jaGlsZCgncHJvcCcpLnZhbCgpID09IHRydWUpXCIgfSxcbiAgICAgIHsgZjogXCJcIiwgeDogXCJ0aGlzLmZvby5wYXJlbnQoKVwiLCBleHBlY3Q6IFwibmV3RGF0YS5jaGlsZCgnZm9vJykucGFyZW50KCkudmFsKCkgPT0gdHJ1ZVwiIH0sXG4gICAgICB7IGY6IFwiXCIsXG4gICAgICAgIHg6IFwidGhpcy5mb28gfHwgdGhpcy5iYXJcIixcbiAgICAgICAgZXhwZWN0OiBcIm5ld0RhdGEuY2hpbGQoJ2ZvbycpLnZhbCgpID09IHRydWUgfHwgbmV3RGF0YS5jaGlsZCgnYmFyJykudmFsKCkgPT0gdHJ1ZVwifSxcbiAgICAgIC8vIFRPRE86IERvbid0IHN1cHBvcnQgc25hcHNob3QgZnVuY3Rpb25zIGJleW9uZCBwYXJlbnQuXG4gICAgICAvLyBUT0RPOiBTaG91bGQgd2FybiB1c2VyIG5vdCB0byB1c2UgRmlyZWJhc2UgYnVpbHRpbnMhXG4gICAgICAvLyB7IGY6IFwiXCIsIHg6IFwidGhpcy5pc1N0cmluZygpXCIsIGV4cGVjdDogXCJuZXdEYXRhLmNoaWxkKCdpc1N0cmluZycpLnZhbCgpID09IHRydWVcIiB9LFxuICAgICAgeyBmOiBcImZ1bmN0aW9uIGYoYSkgeyByZXR1cm4gYSA9PSAnMTIzJzsgfVwiLCB4OiBcImYodGhpcylcIiwgZXhwZWN0OiBcIm5ld0RhdGEudmFsKCkgPT0gJzEyMydcIiB9LFxuICAgICAgeyBmOiBcImZ1bmN0aW9uIGYoYSkgeyByZXR1cm4gYSA9PSAnMTIzJzsgfVwiLFxuICAgICAgICB4OiBcImYodGhpcy5mb28pXCIsIGV4cGVjdDogXCJuZXdEYXRhLmNoaWxkKCdmb28nKS52YWwoKSA9PSAnMTIzJ1wiIH0sXG4gICAgXTtcblxuICAgIGhlbHBlci5kYXRhRHJpdmVuVGVzdCh0ZXN0cywgZnVuY3Rpb24oZGF0YSwgZXhwZWN0KSB7XG4gICAgICB2YXIgc3ltYm9scyA9IHBhcnNlKGRhdGEuZiArIFwiIHBhdGggL3ggeyB3cml0ZSgpIHsgcmV0dXJuIFwiICsgZGF0YS54ICsgXCI7IH19XCIpO1xuICAgICAgdmFyIGdlbiA9IG5ldyBib2x0LkdlbmVyYXRvcihzeW1ib2xzKTtcbiAgICAgIC8vIE1ha2Ugc3VyZSBsb2NhbCBTY2hlbWEgaW5pdGlhbGl6ZWQuXG4gICAgICB2YXIganNvbiA9IDxhbnk+IGdlbi5nZW5lcmF0ZVJ1bGVzKCk7XG4gICAgICBhc3NlcnQuZXF1YWwoanNvblsncnVsZXMnXVsneCddWycud3JpdGUnXSwgZXhwZWN0KTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgc3VpdGUoXCJTdHJpbmcgbWV0aG9kc1wiLCBmdW5jdGlvbigpIHtcbiAgICB2YXIgdGVzdHMgPSBbXG4gICAgICB7IGRhdGE6IFwidGhpcy5sZW5ndGhcIixcbiAgICAgICAgZXhwZWN0OiBcIm5ld0RhdGEudmFsKCkubGVuZ3RoXCIgfSxcbiAgICAgIHsgZGF0YTogXCJ0aGlzLmxlbmd0aCA8IDEwMFwiLFxuICAgICAgICBleHBlY3Q6IFwibmV3RGF0YS52YWwoKS5sZW5ndGggPCAxMDBcIiB9LFxuICAgICAgeyBkYXRhOiBcIidhYmMnLmxlbmd0aFwiLFxuICAgICAgICBleHBlY3Q6IFwiJ2FiYycubGVuZ3RoXCIgfSxcbiAgICAgIHsgZGF0YTogXCInYWJjJy5pbmNsdWRlcygnYicpXCIsXG4gICAgICAgIGV4cGVjdDogXCInYWJjJy5jb250YWlucygnYicpXCIgfSxcbiAgICAgIHsgZGF0YTogXCJ0aGlzLmluY2x1ZGVzKCdiJylcIixcbiAgICAgICAgZXhwZWN0OiBcIm5ld0RhdGEudmFsKCkuY29udGFpbnMoJ2InKVwiIH0sXG4gICAgICB7IGRhdGE6IFwiJ2FiYycuaW5jbHVkZXModGhpcylcIixcbiAgICAgICAgZXhwZWN0OiBcIidhYmMnLmNvbnRhaW5zKG5ld0RhdGEudmFsKCkpXCIgfSxcbiAgICAgIHsgZGF0YTogXCInYWJjJy5zdGFydHNXaXRoKHRoaXMpXCIsXG4gICAgICAgIGV4cGVjdDogXCInYWJjJy5iZWdpbnNXaXRoKG5ld0RhdGEudmFsKCkpXCIgfSxcbiAgICAgIHsgZGF0YTogXCInYWJjJy5lbmRzV2l0aCh0aGlzKVwiLFxuICAgICAgICBleHBlY3Q6IFwiJ2FiYycuZW5kc1dpdGgobmV3RGF0YS52YWwoKSlcIiB9LFxuICAgICAgeyBkYXRhOiBcIidhYmMnLnJlcGxhY2UodGhpcy5hLCB0aGlzLmIpXCIsXG4gICAgICAgIGV4cGVjdDogXCInYWJjJy5yZXBsYWNlKG5ld0RhdGEuY2hpbGQoJ2EnKS52YWwoKSwgbmV3RGF0YS5jaGlsZCgnYicpLnZhbCgpKVwiIH0sXG4gICAgICB7IGRhdGE6IFwiJ0FCQycudG9Mb3dlckNhc2UoKVwiLFxuICAgICAgICBleHBlY3Q6IFwiJ0FCQycudG9Mb3dlckNhc2UoKVwiIH0sXG4gICAgICB7IGRhdGE6IFwiJ2FiYycudG9VcHBlckNhc2UoKVwiLFxuICAgICAgICBleHBlY3Q6IFwiJ2FiYycudG9VcHBlckNhc2UoKVwiIH0sXG4gICAgICB7IGRhdGE6IFwidGhpcy50b1VwcGVyQ2FzZSgpXCIsXG4gICAgICAgIGV4cGVjdDogXCJuZXdEYXRhLnZhbCgpLnRvVXBwZXJDYXNlKClcIiB9LFxuICAgICAgeyBkYXRhOiBcIidhYmFiYScudGVzdCgvYmFiLylcIixcbiAgICAgICAgZXhwZWN0OiBcIidhYmFiYScubWF0Y2hlcygvYmFiLylcIiB9LFxuICAgIF07XG5cbiAgICBoZWxwZXIuZGF0YURyaXZlblRlc3QodGVzdHMsIGZ1bmN0aW9uKGRhdGEsIGV4cGVjdCkge1xuICAgICAgdmFyIHN5bWJvbHMgPSBwYXJzZShcInBhdGggL3ggeyB3cml0ZSgpIHsgcmV0dXJuIFwiICsgZGF0YSArIFwiOyB9fVwiKTtcbiAgICAgIHZhciBnZW4gPSBuZXcgYm9sdC5HZW5lcmF0b3Ioc3ltYm9scyk7XG4gICAgICAvLyBNYWtlIHN1cmUgbG9jYWwgU2NoZW1hIGluaXRpYWxpemVkLlxuICAgICAgdmFyIGpzb24gPSA8YW55PiBnZW4uZ2VuZXJhdGVSdWxlcygpO1xuICAgICAgYXNzZXJ0LmVxdWFsKGpzb25bJ3J1bGVzJ11bJ3gnXVsnLndyaXRlJ10sIGV4cGVjdCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIHN1aXRlKFwiQnVpbHRpbiB2YWxpZGF0aW9uIGZ1bmN0aW9uc1wiLCBmdW5jdGlvbigpIHtcbiAgICB2YXIgdGVzdHMgPSBbXG4gICAgICBbICdTdHJpbmcnLCAndGhpcy5pc1N0cmluZygpJ10sXG4gICAgICBbICdOdW1iZXInLCAndGhpcy5pc051bWJlcigpJ10sXG4gICAgICBbICdCb29sZWFuJywgJ3RoaXMuaXNCb29sZWFuKCknXSxcbiAgICAgIFsgJ09iamVjdCcsICd0aGlzLmhhc0NoaWxkcmVuKCknXSxcbiAgICAgIFsgJ051bGwnLCAnZmFsc2UnXSxcbiAgICBdO1xuXG4gICAgaGVscGVyLmRhdGFEcml2ZW5UZXN0KHRlc3RzLCBmdW5jdGlvbihkYXRhLCBleHBlY3QpIHtcbiAgICAgIHZhciBzeW1ib2xzID0gcGFyc2UoXCJwYXRoIC8ge31cIik7XG4gICAgICB2YXIgZ2VuID0gbmV3IGJvbHQuR2VuZXJhdG9yKHN5bWJvbHMpO1xuICAgICAgZ2VuLmVuc3VyZVZhbGlkYXRvcihhc3QudHlwZVR5cGUoZGF0YSkpO1xuXG4gICAgICB2YXIgdGVybXMgPSA8YXN0LkV4cFtdPiBnZW4udmFsaWRhdG9yc1tkYXRhXVsnLnZhbGlkYXRlJ107XG4gICAgICB2YXIgcmVzdWx0ID0gYm9sdC5kZWNvZGVFeHByZXNzaW9uKGFzdC5hbmRBcnJheSh0ZXJtcykpO1xuICAgICAgYXNzZXJ0LmRlZXBFcXVhbChyZXN1bHQsIGV4cGVjdCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIHN1aXRlKFwiU2NoZW1hIFZhbGlkYXRpb25cIiwgZnVuY3Rpb24oKSB7XG4gICAgdmFyIHRlc3RzID0gW1xuICAgICAgeyBkYXRhOiBcInR5cGUgVCB7fVwiLFxuICAgICAgICBleHBlY3Q6IHVuZGVmaW5lZCB9LFxuICAgICAgeyBkYXRhOiBcInR5cGUgVCBleHRlbmRzIE9iamVjdCB7fVwiLFxuICAgICAgICBleHBlY3Q6IHsnLnZhbGlkYXRlJzogXCJuZXdEYXRhLmhhc0NoaWxkcmVuKClcIn0gfSxcbiAgICAgIHsgZGF0YTogXCJ0eXBlIFQgZXh0ZW5kcyBTdHJpbmcge31cIixcbiAgICAgICAgZXhwZWN0OiB7Jy52YWxpZGF0ZSc6IFwibmV3RGF0YS5pc1N0cmluZygpXCJ9IH0sXG4gICAgICB7IGRhdGE6IFwidHlwZSBUIGV4dGVuZHMgU3RyaW5nIHsgdmFsaWRhdGUoKSB7IHJldHVybiB0aGlzLmxlbmd0aCA+IDA7IH0gfVwiLFxuICAgICAgICBleHBlY3Q6IHsnLnZhbGlkYXRlJzogXCJuZXdEYXRhLmlzU3RyaW5nKCkgJiYgbmV3RGF0YS52YWwoKS5sZW5ndGggPiAwXCJ9IH0sXG4gICAgICB7IGRhdGE6IFwidHlwZSBOb25FbXB0eSBleHRlbmRzIFN0cmluZyB7IHZhbGlkYXRlKCkgeyByZXR1cm4gdGhpcy5sZW5ndGggPiAwOyB9IH0gXFxcbiAgICAgICAgICAgIHR5cGUgVCB7IHByb3A6IE5vbkVtcHR5IH1cIixcbiAgICAgICAgZXhwZWN0OiB7Jy52YWxpZGF0ZSc6IFwibmV3RGF0YS5oYXNDaGlsZHJlbihbJ3Byb3AnXSlcIixcbiAgICAgICAgICAgICAgICAgcHJvcDoge1xuICAgICAgICAgICAgICAgICAgICcudmFsaWRhdGUnOiAnbmV3RGF0YS5pc1N0cmluZygpICYmIG5ld0RhdGEudmFsKCkubGVuZ3RoID4gMCdcbiAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgJyRvdGhlcic6IHsnLnZhbGlkYXRlJzogXCJmYWxzZVwifVxuICAgICAgICAgICAgICAgIH0gfSxcbiAgICAgIHsgZGF0YTogXCJ0eXBlIFQge246IE51bWJlcn1cIixcbiAgICAgICAgZXhwZWN0OiB7Jy52YWxpZGF0ZSc6IFwibmV3RGF0YS5oYXNDaGlsZHJlbihbJ24nXSlcIixcbiAgICAgICAgICAgICAgICAgbjogeycudmFsaWRhdGUnOiBcIm5ld0RhdGEuaXNOdW1iZXIoKVwifSxcbiAgICAgICAgICAgICAgICAgJyRvdGhlcic6IHsnLnZhbGlkYXRlJzogXCJmYWxzZVwifX0gfSxcbiAgICAgIHsgZGF0YTogXCJ0eXBlIFQge3M6IFN0cmluZ31cIixcbiAgICAgICAgZXhwZWN0OiB7Jy52YWxpZGF0ZSc6IFwibmV3RGF0YS5oYXNDaGlsZHJlbihbJ3MnXSlcIixcbiAgICAgICAgICAgICAgICAgczogeycudmFsaWRhdGUnOiBcIm5ld0RhdGEuaXNTdHJpbmcoKVwifSxcbiAgICAgICAgICAgICAgICAgJyRvdGhlcic6IHsnLnZhbGlkYXRlJzogXCJmYWxzZVwifX0gfSxcbiAgICAgIHsgZGF0YTogXCJ0eXBlIFQge2I6IEJvb2xlYW59XCIsXG4gICAgICAgIGV4cGVjdDogeycudmFsaWRhdGUnOiBcIm5ld0RhdGEuaGFzQ2hpbGRyZW4oWydiJ10pXCIsXG4gICAgICAgICAgICAgICAgIGI6IHsnLnZhbGlkYXRlJzogXCJuZXdEYXRhLmlzQm9vbGVhbigpXCJ9LFxuICAgICAgICAgICAgICAgICAnJG90aGVyJzogeycudmFsaWRhdGUnOiBcImZhbHNlXCJ9fSB9LFxuICAgICAgeyBkYXRhOiBcInR5cGUgVCB7eDogT2JqZWN0fVwiLFxuICAgICAgICBleHBlY3Q6IHsnLnZhbGlkYXRlJzogXCJuZXdEYXRhLmhhc0NoaWxkcmVuKFsneCddKVwiLFxuICAgICAgICAgICAgICAgICB4OiB7Jy52YWxpZGF0ZSc6IFwibmV3RGF0YS5oYXNDaGlsZHJlbigpXCJ9LFxuICAgICAgICAgICAgICAgICAnJG90aGVyJzogeycudmFsaWRhdGUnOiBcImZhbHNlXCJ9fSB9LFxuICAgICAgeyBkYXRhOiBcInR5cGUgVCB7eDogTnVtYmVyfFN0cmluZ31cIixcbiAgICAgICAgZXhwZWN0OiB7Jy52YWxpZGF0ZSc6IFwibmV3RGF0YS5oYXNDaGlsZHJlbihbJ3gnXSlcIixcbiAgICAgICAgICAgICAgICAgeDogeycudmFsaWRhdGUnOiBcIm5ld0RhdGEuaXNOdW1iZXIoKSB8fCBuZXdEYXRhLmlzU3RyaW5nKClcIn0sXG4gICAgICAgICAgICAgICAgICckb3RoZXInOiB7Jy52YWxpZGF0ZSc6IFwiZmFsc2VcIn19IH0sXG5cbiAgICAgIHsgZGF0YTogXCJ0eXBlIFQgeyAka2V5OiBOdW1iZXIgfVwiLFxuICAgICAgICBleHBlY3Q6IHsnLnZhbGlkYXRlJzogXCJuZXdEYXRhLmhhc0NoaWxkcmVuKClcIixcbiAgICAgICAgICAgICAgICAgJyRrZXknOiB7Jy52YWxpZGF0ZSc6IFwibmV3RGF0YS5pc051bWJlcigpXCJ9fSB9LFxuXG4gICAgICB7IGRhdGE6IFwidHlwZSBUIHsgJ2EgYic6IE51bWJlciB9XCIsXG4gICAgICAgIGV4cGVjdDogeycudmFsaWRhdGUnOiBcIm5ld0RhdGEuaGFzQ2hpbGRyZW4oWydhIGInXSlcIixcbiAgICAgICAgICAgICAgICAgJ2EgYic6IHsnLnZhbGlkYXRlJzogXCJuZXdEYXRhLmlzTnVtYmVyKClcIn0sXG4gICAgICAgICAgICAgICAgICckb3RoZXInOiB7Jy52YWxpZGF0ZSc6ICdmYWxzZSd9fSB9LFxuXG4gICAgICB7IGRhdGE6IFwidHlwZSBUIHthOiBOdW1iZXIsIGI6IFN0cmluZ31cIixcbiAgICAgICAgZXhwZWN0OiB7Jy52YWxpZGF0ZSc6IFwibmV3RGF0YS5oYXNDaGlsZHJlbihbJ2EnLCAnYiddKVwiLFxuICAgICAgICAgICAgICAgICBhOiB7Jy52YWxpZGF0ZSc6IFwibmV3RGF0YS5pc051bWJlcigpXCJ9LFxuICAgICAgICAgICAgICAgICBiOiB7Jy52YWxpZGF0ZSc6IFwibmV3RGF0YS5pc1N0cmluZygpXCJ9LFxuICAgICAgICAgICAgICAgICAnJG90aGVyJzogeycudmFsaWRhdGUnOiBcImZhbHNlXCJ9fSB9LFxuICAgICAgeyBkYXRhOiBcInR5cGUgVCB7eDogTnVtYmVyfE51bGx9XCIsXG4gICAgICAgIGV4cGVjdDogeycudmFsaWRhdGUnOiBcIm5ld0RhdGEuaGFzQ2hpbGRyZW4oKVwiLFxuICAgICAgICAgICAgICAgICB4OiB7Jy52YWxpZGF0ZSc6IFwibmV3RGF0YS5pc051bWJlcigpXCJ9LFxuICAgICAgICAgICAgICAgICAnJG90aGVyJzogeycudmFsaWRhdGUnOiBcImZhbHNlXCJ9fSB9LFxuICAgICAgeyBkYXRhOiBcInR5cGUgVCB7bjogTnVtYmVyLCB2YWxpZGF0ZSgpIHtyZXR1cm4gdGhpcy5uIDwgNzt9fVwiLFxuICAgICAgICBleHBlY3Q6IHsnLnZhbGlkYXRlJzogXCJuZXdEYXRhLmhhc0NoaWxkcmVuKFsnbiddKSAmJiBuZXdEYXRhLmNoaWxkKCduJykudmFsKCkgPCA3XCIsXG4gICAgICAgICAgICAgICAgIG46IHsnLnZhbGlkYXRlJzogXCJuZXdEYXRhLmlzTnVtYmVyKClcIn0sXG4gICAgICAgICAgICAgICAgICckb3RoZXInOiB7Jy52YWxpZGF0ZSc6IFwiZmFsc2VcIn19IH0sXG4gICAgICB7IGRhdGE6IFwidHlwZSBCaWdnZXIgZXh0ZW5kcyBOdW1iZXIge3ZhbGlkYXRlKCkgeyByZXR1cm4gdGhpcyA+IHByaW9yKHRoaXMpOyB9fVwiICtcbiAgICAgICAgXCJ0eXBlIFQgeyB0czogQmlnZ2VyIH1cIixcbiAgICAgICAgZXhwZWN0OiB7Jy52YWxpZGF0ZSc6IFwibmV3RGF0YS5oYXNDaGlsZHJlbihbJ3RzJ10pXCIsXG4gICAgICAgICAgICAgICAgIHRzOiB7Jy52YWxpZGF0ZSc6IFwibmV3RGF0YS5pc051bWJlcigpICYmIG5ld0RhdGEudmFsKCkgPiBkYXRhLnZhbCgpXCJ9LFxuICAgICAgICAgICAgICAgICAnJG90aGVyJzogeycudmFsaWRhdGUnOiBcImZhbHNlXCJ9fSB9LFxuICAgICAgeyBkYXRhOiBcInR5cGUgVCB7YTogU3RyaW5nLCBiOiBTdHJpbmcsIGM6IFN0cmluZ31cIixcbiAgICAgICAgZXhwZWN0OiB7Jy52YWxpZGF0ZSc6IFwibmV3RGF0YS5oYXNDaGlsZHJlbihbJ2EnLCAnYicsICdjJ10pXCIsXG4gICAgICAgICAgICAgICAgIGE6IHsnLnZhbGlkYXRlJzogXCJuZXdEYXRhLmlzU3RyaW5nKClcIn0sXG4gICAgICAgICAgICAgICAgIGI6IHsnLnZhbGlkYXRlJzogXCJuZXdEYXRhLmlzU3RyaW5nKClcIn0sXG4gICAgICAgICAgICAgICAgIGM6IHsnLnZhbGlkYXRlJzogXCJuZXdEYXRhLmlzU3RyaW5nKClcIn0sXG4gICAgICAgICAgICAgICAgICckb3RoZXInOiB7Jy52YWxpZGF0ZSc6IFwiZmFsc2VcIn19IH0sXG4gICAgICB7IGRhdGE6IFwidHlwZSBCIHsgZm9vOiBOdW1iZXIgfSB0eXBlIFQgZXh0ZW5kcyBCIHsgYmFyOiBTdHJpbmcgfVwiLFxuICAgICAgICBleHBlY3Q6IHsnLnZhbGlkYXRlJzogXCJuZXdEYXRhLmhhc0NoaWxkcmVuKFsnZm9vJywgJ2JhciddKVwiLFxuICAgICAgICAgICAgICAgICBmb286IHsnLnZhbGlkYXRlJzogXCJuZXdEYXRhLmlzTnVtYmVyKClcIn0sXG4gICAgICAgICAgICAgICAgIGJhcjogeycudmFsaWRhdGUnOiBcIm5ld0RhdGEuaXNTdHJpbmcoKVwifSxcbiAgICAgICAgICAgICAgICAgJyRvdGhlcic6IHsnLnZhbGlkYXRlJzogXCJmYWxzZVwifX0gfSxcblxuICAgICAgeyBkYXRhOiBcInR5cGUgVCB7bjogTnVtYmVyLCB4OiBNYXA8U3RyaW5nLCBOdW1iZXI+fVwiLFxuICAgICAgICBleHBlY3Q6IHsnLnZhbGlkYXRlJzogXCJuZXdEYXRhLmhhc0NoaWxkcmVuKFsnbiddKVwiLFxuICAgICAgICAgICAgICAgICBuOiB7Jy52YWxpZGF0ZSc6IFwibmV3RGF0YS5pc051bWJlcigpXCJ9LFxuICAgICAgICAgICAgICAgICB4OiB7JyRrZXkxJzogeycudmFsaWRhdGUnOiBcIm5ld0RhdGEuaXNOdW1iZXIoKVwifSxcbiAgICAgICAgICAgICAgICAgICAgICcudmFsaWRhdGUnOiBcIm5ld0RhdGEuaGFzQ2hpbGRyZW4oKVwiIH0sXG4gICAgICAgICAgICAgICAgICckb3RoZXInOiB7Jy52YWxpZGF0ZSc6IFwiZmFsc2VcIn19IH0sXG4gICAgICB7IGRhdGE6IFwidHlwZSBUIHt4OiBNYXA8U3RyaW5nLCBOdW1iZXI+fVwiLFxuICAgICAgICBleHBlY3Q6IHsnLnZhbGlkYXRlJzogXCJuZXdEYXRhLmhhc0NoaWxkcmVuKClcIixcbiAgICAgICAgICAgICAgICAgeDogeycka2V5MSc6IHsnLnZhbGlkYXRlJzogXCJuZXdEYXRhLmlzTnVtYmVyKClcIn0sXG4gICAgICAgICAgICAgICAgICAgICAnLnZhbGlkYXRlJzogXCJuZXdEYXRhLmhhc0NoaWxkcmVuKClcIiB9LFxuICAgICAgICAgICAgICAgICAnJG90aGVyJzogeycudmFsaWRhdGUnOiBcImZhbHNlXCJ9fSB9LFxuICAgICAgeyBkYXRhOiBcInR5cGUgU21hbGxTdHJpbmcgZXh0ZW5kcyBTdHJpbmcgeyB2YWxpZGF0ZSgpIHsgdGhpcy5sZW5ndGggPCAzMiB9IH0gXCIgK1xuICAgICAgICAgICAgICBcInR5cGUgVCB7eDogTWFwPFNtYWxsU3RyaW5nLCBOdW1iZXI+fVwiLFxuICAgICAgICBleHBlY3Q6IHsnLnZhbGlkYXRlJzogXCJuZXdEYXRhLmhhc0NoaWxkcmVuKClcIixcbiAgICAgICAgICAgICAgICAgeDogeycka2V5MSc6IHsnLnZhbGlkYXRlJzogXCIka2V5MS5sZW5ndGggPCAzMiAmJiBuZXdEYXRhLmlzTnVtYmVyKClcIn0sXG4gICAgICAgICAgICAgICAgICAgICAnLnZhbGlkYXRlJzogXCJuZXdEYXRhLmhhc0NoaWxkcmVuKClcIiB9LFxuICAgICAgICAgICAgICAgICAnJG90aGVyJzogeycudmFsaWRhdGUnOiBcImZhbHNlXCJ9fSB9LFxuICAgICAgeyBkYXRhOiBcInR5cGUgTSBleHRlbmRzIE1hcDxTdHJpbmcsIE51bWJlcj47IHR5cGUgVCB7IHg6IE0gfVwiLFxuICAgICAgICBleHBlY3Q6IHsnLnZhbGlkYXRlJzogXCJuZXdEYXRhLmhhc0NoaWxkcmVuKClcIixcbiAgICAgICAgICAgICAgICAgJyRvdGhlcic6IHsnLnZhbGlkYXRlJzogXCJmYWxzZVwifSxcbiAgICAgICAgICAgICAgICAgJ3gnOiB7JyRrZXkxJzogeycudmFsaWRhdGUnOiBcIm5ld0RhdGEuaXNOdW1iZXIoKVwifSxcbiAgICAgICAgICAgICAgICAgICAgICAgJy52YWxpZGF0ZSc6IFwibmV3RGF0YS5oYXNDaGlsZHJlbigpXCIgfX0gfSxcbiAgICAgIHsgZGF0YTogXCJ0eXBlIFBhaXI8WCwgWT4geyBmaXJzdDogWCwgc2Vjb25kOiBZIH0gdHlwZSBUIGV4dGVuZHMgUGFpcjxTdHJpbmcsIE51bWJlcj47XCIsXG4gICAgICAgIGV4cGVjdDogeycudmFsaWRhdGUnOiBcIm5ld0RhdGEuaGFzQ2hpbGRyZW4oWydmaXJzdCcsICdzZWNvbmQnXSlcIixcbiAgICAgICAgICAgICAgICAgJ2ZpcnN0JzogeycudmFsaWRhdGUnOiBcIm5ld0RhdGEuaXNTdHJpbmcoKVwifSxcbiAgICAgICAgICAgICAgICAgJ3NlY29uZCc6IHsnLnZhbGlkYXRlJzogXCJuZXdEYXRhLmlzTnVtYmVyKClcIn0sXG4gICAgICAgICAgICAgICAgICckb3RoZXInOiB7Jy52YWxpZGF0ZSc6IFwiZmFsc2VcIn19IH0sXG5cbiAgICAgIHsgZGF0YTogXCJ0eXBlIFggeyBhOiBOdW1iZXIsIHZhbGlkYXRlKCkgeyB0aGlzLmEgPT0ga2V5KCkgfSB9IHR5cGUgVCBleHRlbmRzIFhbXTtcIixcbiAgICAgICAgZXhwZWN0OiB7JyRrZXkxJzogeycudmFsaWRhdGUnOiBcIm5ld0RhdGEuaGFzQ2hpbGRyZW4oWydhJ10pICYmIG5ld0RhdGEuY2hpbGQoJ2EnKS52YWwoKSA9PSAka2V5MVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2EnOiB7Jy52YWxpZGF0ZSc6IFwibmV3RGF0YS5pc051bWJlcigpXCJ9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgJyRvdGhlcic6IHsnLnZhbGlkYXRlJzogXCJmYWxzZVwifX0sXG4gICAgICAgICAgICAgICAgICcudmFsaWRhdGUnOiBcIm5ld0RhdGEuaGFzQ2hpbGRyZW4oKVwiXG4gICAgICAgICAgICAgICAgfSB9LFxuICAgICAgeyBkYXRhOiBcInR5cGUgWCB7IGE6IE51bWJlciwgdmFsaWRhdGUoKSB7IHRoaXMuYSA9PSBrZXkoKSB9IH0gdHlwZSBUIHsgeDogWCB9XCIsXG4gICAgICAgIGV4cGVjdDogeyd4JzogeycudmFsaWRhdGUnOiBcIm5ld0RhdGEuaGFzQ2hpbGRyZW4oWydhJ10pICYmIG5ld0RhdGEuY2hpbGQoJ2EnKS52YWwoKSA9PSAneCdcIixcbiAgICAgICAgICAgICAgICAgICAgICAgJ2EnOiB7Jy52YWxpZGF0ZSc6IFwibmV3RGF0YS5pc051bWJlcigpXCJ9LFxuICAgICAgICAgICAgICAgICAgICAgICAnJG90aGVyJzogeycudmFsaWRhdGUnOiBcImZhbHNlXCJ9fSxcbiAgICAgICAgICAgICAgICAgJyRvdGhlcic6IHsnLnZhbGlkYXRlJzogXCJmYWxzZVwifSxcbiAgICAgICAgICAgICAgICAgJy52YWxpZGF0ZSc6IFwibmV3RGF0YS5oYXNDaGlsZHJlbihbJ3gnXSlcIlxuICAgICAgICAgICAgICAgIH0gfSxcblxuICAgICAgeyBkYXRhOiBcInR5cGUgVCBleHRlbmRzIFN0cmluZyB7IHZhbGlkYXRlKCkgeyByb290ID09ICduZXcnICYmIHByaW9yKHJvb3QpID09ICdvbGQnIH0gfVwiICtcbiAgICAgICAgICAgICAgXCJwYXRoIC90L3ggaXMgQW55IHsgcmVhZCgpIHsgcm9vdCA9PSAnb2xkJyB9IH1cIixcbiAgICAgICAgZXhwZWN0OiB7Jy52YWxpZGF0ZSc6IFwibmV3RGF0YS5pc1N0cmluZygpICYmIG5ld0RhdGEucGFyZW50KCkudmFsKCkgPT0gJ25ldycgJiYgcm9vdC52YWwoKSA9PSAnb2xkJ1wiLFxuICAgICAgICAgICAgICAgICAneCc6IHsnLnJlYWQnOiBcInJvb3QudmFsKCkgPT0gJ29sZCdcIn1cbiAgICAgICAgICAgICAgICB9IH0sXG4gICAgXTtcblxuICAgIGhlbHBlci5kYXRhRHJpdmVuVGVzdCh0ZXN0cywgZnVuY3Rpb24oZGF0YSwgZXhwZWN0KSB7XG4gICAgICB2YXIgc3ltYm9scyA9IHBhcnNlKGRhdGEgKyBcIiBwYXRoIC90IGlzIFQ7XCIpO1xuICAgICAgdmFyIGdlbiA9IG5ldyBib2x0LkdlbmVyYXRvcihzeW1ib2xzKTtcbiAgICAgIHZhciBydWxlcyA9IGdlbi5nZW5lcmF0ZVJ1bGVzKCk7XG4gICAgICBpZiAoZXhwZWN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYXNzZXJ0LmRlZXBFcXVhbChydWxlcywge1wicnVsZXNcIjoge319KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFzc2VydC5kZWVwRXF1YWwocnVsZXMsIHtcInJ1bGVzXCI6IHt0OiBleHBlY3R9fSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuXG4gIHN1aXRlKFwiZXh0ZW5kVmFsaWRhdG9yXCIsIGZ1bmN0aW9uKCkge1xuICAgIHZhciB0ZXN0cyA9IFtcbiAgICAgIHsgZGF0YToge3RhcmdldDoge30sIHNyYzoge319LFxuICAgICAgICBleHBlY3Q6IHt9IH0sXG4gICAgICB7IGRhdGE6IHt0YXJnZXQ6IHt9LCBzcmM6IHsnLngnOiBbMV19fSxcbiAgICAgICAgZXhwZWN0OiB7Jy54JzogWzFdfSB9LFxuICAgICAgeyBkYXRhOiB7dGFyZ2V0OiB7Jy54JzogWzFdfSwgc3JjOiB7Jy54JzogWzJdfX0sXG4gICAgICAgIGV4cGVjdDogeycueCc6IFsxLCAyXX0gfSxcbiAgICAgIHsgZGF0YToge3RhcmdldDogeycueCc6IFsxXX0sIHNyYzogeycueCc6IFsyXSwgYzogeycueCc6IFszXX19fSxcbiAgICAgICAgZXhwZWN0OiB7Jy54JzogWzEsIDJdLCBjOiB7Jy54JzogWzNdfX0gfSxcbiAgICAgIHsgZGF0YToge3RhcmdldDogeycueCc6IFsxXSwgYzogeycueCc6IFsyXX19LCBzcmM6IHtjOiB7Jy54JzogWzNdfX19LFxuICAgICAgICBleHBlY3Q6IHsnLngnOiBbMV0sIGM6IHsnLngnOiBbMiwgM119fSB9LFxuICAgICAgeyBkYXRhOiB7dGFyZ2V0OiB7fSwgc3JjOiB7YToge2I6IHtjOiB7ZDogeycueCc6IFsxXSwgZTogeycueCc6IFsyXX19fX19fX0sXG4gICAgICAgIGV4cGVjdDoge2E6IHtiOiB7Yzoge2Q6IHsnLngnOiBbMV0sIGU6IHsnLngnOiBbMl19fX19fX0gfSxcbiAgICBdO1xuXG4gICAgaGVscGVyLmRhdGFEcml2ZW5UZXN0KHRlc3RzLCBmdW5jdGlvbihkYXRhLCBleHBlY3QpIHtcbiAgICAgIGdlbmVyYXRvci5leHRlbmRWYWxpZGF0b3IoZGF0YS50YXJnZXQsIGRhdGEuc3JjKTtcbiAgICAgIGFzc2VydC5kZWVwRXF1YWwoZGF0YS50YXJnZXQsIGV4cGVjdCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIHN1aXRlKFwibWFwVmFsaWRhdG9yXCIsIGZ1bmN0aW9uKCkge1xuICAgIHZhciB0ZXN0cyA9IFtcbiAgICAgIHsgZGF0YTogeycueCc6ICdhJ30sIGV4cGVjdDogeycueCc6ICdhKyd9IH0sXG4gICAgICB7IGRhdGE6IHsnLngnOiAnYid9LCBleHBlY3Q6IHt9IH0sXG4gICAgXTtcblxuICAgIGhlbHBlci5kYXRhRHJpdmVuVGVzdCh0ZXN0cywgZnVuY3Rpb24oZGF0YSwgZXhwZWN0KSB7XG4gICAgICBnZW5lcmF0b3IubWFwVmFsaWRhdG9yKGRhdGEsIGZ1bmN0aW9uKHZhbHVlLCBwcm9wKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gJ2InKSB7XG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWUgKyAnKyc7XG4gICAgICB9KTtcbiAgICAgIGFzc2VydC5kZWVwRXF1YWwoZGF0YSwgZXhwZWN0KTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgc3VpdGUoXCJTY2hlbWEgR2VuZXJhdGlvbiBFcnJvcnNcIiwgZnVuY3Rpb24oKSB7XG4gICAgdmFyIHRlc3RzID0gW1xuICAgICAgeyBkYXRhOiBcIlwiLFxuICAgICAgICBleHBlY3Q6IC9hdCBsZWFzdCBvbmUgcGF0aC8gfSxcbiAgICAgIHsgZGF0YTogXCJ0eXBlIFNpbXBsZSBleHRlbmRzIFN0cmluZyB7YTogU3RyaW5nfSBwYXRoIC94IGlzIFNpbXBsZTtcIixcbiAgICAgICAgZXhwZWN0OiAvcHJvcGVydGllcy4qZXh0ZW5kLyB9LFxuICAgICAgeyBkYXRhOiBcInBhdGggL3kgeyBpbmRleCgpIHsgcmV0dXJuIDE7IH19XCIsXG4gICAgICAgIGV4cGVjdDogL2luZGV4LipzdHJpbmcvaSB9LFxuICAgICAgeyBkYXRhOiBcInBhdGggL3ggeyB3cml0ZSgpIHsgcmV0dXJuIHVuZGVmaW5lZEZ1bmMoKTsgfX1cIixcbiAgICAgICAgZXhwZWN0OiAvdW5kZWZpbmVkLipmdW5jdGlvbi9pIH0sXG4gICAgICB7IGRhdGE6IFwicGF0aCAveCBpcyBOb1N1Y2hUeXBlIHt9XCIsXG4gICAgICAgIGV4cGVjdDogL05vIHR5cGUuKk5vU3VjaFR5cGUvIH0sXG4gICAgICB7IGRhdGE6IFwicGF0aCAveCB7IHVuc3VwcG9ydGVkKCkgeyB0cnVlIH0gfVwiLFxuICAgICAgICB3YXJuOiAvdW5zdXBwb3J0ZWQgbWV0aG9kL2kgfSxcblxuICAgICAgeyBkYXRhOiBcInBhdGggL3ggeyB2YWxpZGF0ZSgpIHsgcmV0dXJuIHRoaXMudGVzdCgxMjMpOyB9IH1cIixcbiAgICAgICAgZXhwZWN0OiAvY29udmVydCB2YWx1ZS9pIH0sXG4gICAgICB7IGRhdGE6IFwicGF0aCAveCB7IHZhbGlkYXRlKCkgeyByZXR1cm4gdGhpcy50ZXN0KCdhLycpOyB9IH1cIixcbiAgICAgICAgZXhwZWN0OiAvY29udmVydCB2YWx1ZS9pIH0sXG4gICAgICB7IGRhdGE6IFwicGF0aCAveCB7IHZhbGlkYXRlKCkgeyByZXR1cm4gdGhpcy50ZXN0KCcvYS8nKTsgfSB9XCIsXG4gICAgICAgIGV4cGVjdDogL2NvbnZlcnQgdmFsdWUvaSB9LFxuXG4gICAgICB7IGRhdGE6IFwiZnVuY3Rpb24gZihhKSB7IHJldHVybiBmKGEpOyB9IHBhdGggLyB7IHZhbGlkYXRlKCkgeyByZXR1cm4gZigxKTsgfX1cIixcbiAgICAgICAgZXhwZWN0OiAvcmVjdXJzaXZlL2kgfSxcbiAgICAgIHsgZGF0YTogXCJ0eXBlIFggeyAkbjogTnVtYmVyLCAkczogU3RyaW5nIH0gcGF0aCAvIGlzIFg7XCIsXG4gICAgICAgIGV4cGVjdDogL3dpbGQgcHJvcGVydHkvIH0sXG4gICAgICB7IGRhdGE6IFwidHlwZSBYIHsgJCRuOiBOdW1iZXIgfSBwYXRoIC8gaXMgWDtcIixcbiAgICAgICAgZXhwZWN0OiAvcHJvcGVydHkgbmFtZXMvaSB9LFxuICAgICAgeyBkYXRhOiBcInR5cGUgWCB7ICdcXHgwMSc6IE51bWJlciB9IHBhdGggLyBpcyBYO1wiLFxuICAgICAgICBleHBlY3Q6IC9wcm9wZXJ0eSBuYW1lcy9pIH0sXG4gICAgICB7IGRhdGE6IFwicGF0aCAvIGlzIE1hcDtcIixcbiAgICAgICAgZXhwZWN0OiAvTm8gdHlwZS4qbm9uLWdlbmVyaWMvIH0sXG4gICAgICB7IGRhdGE6IFwidHlwZSBQYWlyPFgsIFk+IHthOiBYLCBiOiBZfSBwYXRoIC8gaXMgUGFpcjtcIixcbiAgICAgICAgZXhwZWN0OiAvTm8gdHlwZS4qbm9uLWdlbmVyaWMvIH0sXG4gICAgICB7IGRhdGE6IFwicGF0aCAvIGlzIFN0cmluZzxOdW1iZXI+O1wiLFxuICAgICAgICBleHBlY3Q6IC9ObyB0eXBlLipnZW5lcmljLyB9LFxuICAgICAgeyBkYXRhOiBcInBhdGggLyBpcyBNYXA8T2JqZWN0LCBOdW1iZXI+O1wiLFxuICAgICAgICBleHBlY3Q6IC9tdXN0IGRlcml2ZSBmcm9tIFN0cmluZy8gfSxcbiAgICAgIHsgZGF0YTogXCJwYXRoIC8geyB3cml0ZSgpIHsgdHJ1ZSB9IGNyZWF0ZSgpIHsgdHJ1ZSB9IH1cIixcbiAgICAgICAgZXhwZWN0OiAvd3JpdGUtYWxpYXNpbmcuKmNyZWF0ZS9pIH0sXG4gICAgICB7IGRhdGE6IFwicGF0aCAvIHsgd3JpdGUoKSB7IHRydWUgfSB1cGRhdGUoKSB7IHRydWUgfSB9XCIsXG4gICAgICAgIGV4cGVjdDogL3dyaXRlLWFsaWFzaW5nLip1cGRhdGUvaSB9LFxuICAgICAgeyBkYXRhOiBcInBhdGggLyB7IHdyaXRlKCkgeyB0cnVlIH0gZGVsZXRlKCkgeyB0cnVlIH0gfVwiLFxuICAgICAgICBleHBlY3Q6IC93cml0ZS1hbGlhc2luZy4qZGVsZXRlL2kgfSxcbiAgICBdO1xuXG4gICAgaGVscGVyLmRhdGFEcml2ZW5UZXN0KHRlc3RzLCBmdW5jdGlvbihkYXRhLCBleHBlY3QsIHQpIHtcbiAgICAgIGxvZ2dlci5yZXNldCgpO1xuICAgICAgbG9nZ2VyLnNpbGVudCgpO1xuICAgICAgbGV0IHN5bWJvbHMgPSBwYXJzZShkYXRhKTtcbiAgICAgIGxldCBnZW4gPSBuZXcgYm9sdC5HZW5lcmF0b3Ioc3ltYm9scyk7XG4gICAgICBsZXQgbGFzdEVycm9yOiBzdHJpbmc7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGdlbi5nZW5lcmF0ZVJ1bGVzKCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmICghZXhwZWN0KSB7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0RXJyb3IgPSBsb2dnZXIuZ2V0TGFzdE1lc3NhZ2UoKSB8fCBlLm1lc3NhZ2U7XG4gICAgICAgIGFzc2VydC5tYXRjaChsYXN0RXJyb3IsIGV4cGVjdCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChleHBlY3QpIHtcbiAgICAgICAgYXNzZXJ0LmZhaWwodW5kZWZpbmVkLCB1bmRlZmluZWQsIFwiTm8gZXhjZXB0aW9uIHRocm93bi5cIik7XG4gICAgICB9XG4gICAgICBpZiAodC53YXJuKSB7XG4gICAgICAgIGFzc2VydC5tYXRjaChsb2dnZXIuZ2V0TGFzdE1lc3NhZ2UoKSwgdC53YXJuKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59KTtcbiJdfQ==
