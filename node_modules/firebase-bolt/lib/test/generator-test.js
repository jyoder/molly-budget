"use strict";
/*
 * Copyright 2015 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var bolt = require('../bolt');
var parse = bolt.parse;
var generator = require('../rules-generator');
var ast = require('../ast');
var fileio = require('../file-io');
var logger = require('../logger');
var helper = require('./test-helper');
var sample_files_1 = require('./sample-files');
var chai = require('chai');
chai.config.truncateThreshold = 1000;
var assert = chai.assert;
// TODO: Test duplicated function, and schema definitions.
// TODO: Test other parser errors - appropriate messages (exceptions).
suite("Rules Generator Tests", function () {
    suite("Basic Samples", function () {
        var tests = [
            { data: "path / {read() { true } write() { true }}",
                expect: { rules: { ".read": "true", ".write": "true" } }
            },
            { data: "path / { write() { true }}",
                expect: { rules: { ".write": "true" } }
            },
            { data: "path / { create() { true }}",
                expect: { rules: { ".write": "data.val() == null" } }
            },
            { data: "path / { update() { true }}",
                expect: { rules: { ".write": "data.val() != null && newData.val() != null" } }
            },
            { data: "path / { delete() { true }}",
                expect: { rules: { ".write": "data.val() != null && newData.val() == null" } }
            },
            { data: "path / {read() { true }}",
                expect: { rules: { ".read": "true" } }
            },
            { data: "path / { read() { false }}",
                expect: { rules: {} }
            },
            { data: "path / {index() { return ['a', 'b']; }}",
                expect: { rules: { ".indexOn": ["a", "b"] } }
            },
            { data: "path / { validate() { return this > 0; }}",
                expect: { rules: { ".validate": "newData.val() > 0" } }
            },
        ];
        helper.dataDrivenTest(tests, function (data, expect) {
            var result = parse(data);
            assert.ok(result);
            var gen = new bolt.Generator(result);
            var json = gen.generateRules();
            assert.deepEqual(json, expect);
        });
    });
    suite("Sample files", function () {
        helper.dataDrivenTest(sample_files_1.samples, function (filename) {
            filename = 'samples/' + filename + '.' + bolt.FILE_EXTENSION;
            return fileio.readFile(filename)
                .then(function (response) {
                var result = parse(response.content);
                assert.ok(result, response.url);
                var gen = new bolt.Generator(result);
                var json = gen.generateRules();
                assert.ok('rules' in json, response.url + " has rules");
                return fileio.readJSONFile(response.url.replace('.' + bolt.FILE_EXTENSION, '.json'))
                    .then(function (response2) {
                    assert.deepEqual(json, response2);
                });
            })
                .catch(function (error) {
                assert.ok(false, error.message);
            });
        });
    });
    suite("Partial evaluation", function () {
        var tests = [
            { f: "function f(a) { return true == a; }", x: "f(a == b)", expect: "true == (a == b)" },
            { f: "function f(a) { return a == true; }", x: "f(a == b)", expect: "a == b == true" },
            { f: "function f(a) { return a + 3; }", x: "f(1 + 2)", expect: "1 + 2 + 3" },
            { f: "function f(a) { return a + 3; }", x: "f(1 * 2)", expect: "1 * 2 + 3" },
            { f: "function f(a) { return a * 3; }", x: "f(1 + 2)", expect: "(1 + 2) * 3" },
            { f: "function f(a) { return a + 1; }", x: "f(a + a)", expect: "a + a + 1" },
            { f: "function f(a) { return g(a); } function g(a) { return a == true; }",
                x: "f(123)", expect: "123 == true" },
            { f: "function f(a, b) { return g(a) == g(b); } function g(a) { return a == true; }",
                x: "f(1, 2)", expect: "1 == true == (2 == true)" },
            // Highler level function works as long as returns a constant function
            { f: "function f() { return g; } function g(a) { return a == true; }",
                x: "f()(123)", expect: "123 == true" },
            { f: "function f(a) { return a + 1; }", x: "a[f(123)]", expect: "a[123 + 1]" },
            { f: "", x: "this", expect: "newData.val() == true" },
            { f: "", x: "!this", expect: "!(newData.val() == true)" },
            { f: "", x: "this.prop", expect: "newData.child('prop').val() == true" },
            { f: "", x: "!this.prop", expect: "!(newData.child('prop').val() == true)" },
            { f: "", x: "this.foo.parent()", expect: "newData.child('foo').parent().val() == true" },
            { f: "",
                x: "this.foo || this.bar",
                expect: "newData.child('foo').val() == true || newData.child('bar').val() == true" },
            // TODO: Don't support snapshot functions beyond parent.
            // TODO: Should warn user not to use Firebase builtins!
            // { f: "", x: "this.isString()", expect: "newData.child('isString').val() == true" },
            { f: "function f(a) { return a == '123'; }", x: "f(this)", expect: "newData.val() == '123'" },
            { f: "function f(a) { return a == '123'; }",
                x: "f(this.foo)", expect: "newData.child('foo').val() == '123'" },
        ];
        helper.dataDrivenTest(tests, function (data, expect) {
            var symbols = parse(data.f + " path /x { write() { return " + data.x + "; }}");
            var gen = new bolt.Generator(symbols);
            // Make sure local Schema initialized.
            var json = gen.generateRules();
            assert.equal(json['rules']['x']['.write'], expect);
        });
    });
    suite("String methods", function () {
        var tests = [
            { data: "this.length",
                expect: "newData.val().length" },
            { data: "this.length < 100",
                expect: "newData.val().length < 100" },
            { data: "'abc'.length",
                expect: "'abc'.length" },
            { data: "'abc'.includes('b')",
                expect: "'abc'.contains('b')" },
            { data: "this.includes('b')",
                expect: "newData.val().contains('b')" },
            { data: "'abc'.includes(this)",
                expect: "'abc'.contains(newData.val())" },
            { data: "'abc'.startsWith(this)",
                expect: "'abc'.beginsWith(newData.val())" },
            { data: "'abc'.endsWith(this)",
                expect: "'abc'.endsWith(newData.val())" },
            { data: "'abc'.replace(this.a, this.b)",
                expect: "'abc'.replace(newData.child('a').val(), newData.child('b').val())" },
            { data: "'ABC'.toLowerCase()",
                expect: "'ABC'.toLowerCase()" },
            { data: "'abc'.toUpperCase()",
                expect: "'abc'.toUpperCase()" },
            { data: "this.toUpperCase()",
                expect: "newData.val().toUpperCase()" },
            { data: "'ababa'.test(/bab/)",
                expect: "'ababa'.matches(/bab/)" },
        ];
        helper.dataDrivenTest(tests, function (data, expect) {
            var symbols = parse("path /x { write() { return " + data + "; }}");
            var gen = new bolt.Generator(symbols);
            // Make sure local Schema initialized.
            var json = gen.generateRules();
            assert.equal(json['rules']['x']['.write'], expect);
        });
    });
    suite("Builtin validation functions", function () {
        var tests = [
            ['String', 'this.isString()'],
            ['Number', 'this.isNumber()'],
            ['Boolean', 'this.isBoolean()'],
            ['Object', 'this.hasChildren()'],
            ['Null', 'false'],
        ];
        helper.dataDrivenTest(tests, function (data, expect) {
            var symbols = parse("path / {}");
            var gen = new bolt.Generator(symbols);
            gen.ensureValidator(ast.typeType(data));
            var terms = gen.validators[data]['.validate'];
            var result = bolt.decodeExpression(ast.andArray(terms));
            assert.deepEqual(result, expect);
        });
    });
    suite("Schema Validation", function () {
        var tests = [
            { data: "type T {}",
                expect: undefined },
            { data: "type T extends Object {}",
                expect: { '.validate': "newData.hasChildren()" } },
            { data: "type T extends String {}",
                expect: { '.validate': "newData.isString()" } },
            { data: "type T extends String { validate() { return this.length > 0; } }",
                expect: { '.validate': "newData.isString() && newData.val().length > 0" } },
            { data: "type NonEmpty extends String { validate() { return this.length > 0; } } \
            type T { prop: NonEmpty }",
                expect: { '.validate': "newData.hasChildren(['prop'])",
                    prop: {
                        '.validate': 'newData.isString() && newData.val().length > 0'
                    },
                    '$other': { '.validate': "false" }
                } },
            { data: "type T {n: Number}",
                expect: { '.validate': "newData.hasChildren(['n'])",
                    n: { '.validate': "newData.isNumber()" },
                    '$other': { '.validate': "false" } } },
            { data: "type T {s: String}",
                expect: { '.validate': "newData.hasChildren(['s'])",
                    s: { '.validate': "newData.isString()" },
                    '$other': { '.validate': "false" } } },
            { data: "type T {b: Boolean}",
                expect: { '.validate': "newData.hasChildren(['b'])",
                    b: { '.validate': "newData.isBoolean()" },
                    '$other': { '.validate': "false" } } },
            { data: "type T {x: Object}",
                expect: { '.validate': "newData.hasChildren(['x'])",
                    x: { '.validate': "newData.hasChildren()" },
                    '$other': { '.validate': "false" } } },
            { data: "type T {x: Number|String}",
                expect: { '.validate': "newData.hasChildren(['x'])",
                    x: { '.validate': "newData.isNumber() || newData.isString()" },
                    '$other': { '.validate': "false" } } },
            { data: "type T { $key: Number }",
                expect: { '.validate': "newData.hasChildren()",
                    '$key': { '.validate': "newData.isNumber()" } } },
            { data: "type T { 'a b': Number }",
                expect: { '.validate': "newData.hasChildren(['a b'])",
                    'a b': { '.validate': "newData.isNumber()" },
                    '$other': { '.validate': 'false' } } },
            { data: "type T {a: Number, b: String}",
                expect: { '.validate': "newData.hasChildren(['a', 'b'])",
                    a: { '.validate': "newData.isNumber()" },
                    b: { '.validate': "newData.isString()" },
                    '$other': { '.validate': "false" } } },
            { data: "type T {x: Number|Null}",
                expect: { '.validate': "newData.hasChildren()",
                    x: { '.validate': "newData.isNumber()" },
                    '$other': { '.validate': "false" } } },
            { data: "type T {n: Number, validate() {return this.n < 7;}}",
                expect: { '.validate': "newData.hasChildren(['n']) && newData.child('n').val() < 7",
                    n: { '.validate': "newData.isNumber()" },
                    '$other': { '.validate': "false" } } },
            { data: "type Bigger extends Number {validate() { return this > prior(this); }}" +
                    "type T { ts: Bigger }",
                expect: { '.validate': "newData.hasChildren(['ts'])",
                    ts: { '.validate': "newData.isNumber() && newData.val() > data.val()" },
                    '$other': { '.validate': "false" } } },
            { data: "type T {a: String, b: String, c: String}",
                expect: { '.validate': "newData.hasChildren(['a', 'b', 'c'])",
                    a: { '.validate': "newData.isString()" },
                    b: { '.validate': "newData.isString()" },
                    c: { '.validate': "newData.isString()" },
                    '$other': { '.validate': "false" } } },
            { data: "type B { foo: Number } type T extends B { bar: String }",
                expect: { '.validate': "newData.hasChildren(['foo', 'bar'])",
                    foo: { '.validate': "newData.isNumber()" },
                    bar: { '.validate': "newData.isString()" },
                    '$other': { '.validate': "false" } } },
            { data: "type T {n: Number, x: Map<String, Number>}",
                expect: { '.validate': "newData.hasChildren(['n'])",
                    n: { '.validate': "newData.isNumber()" },
                    x: { '$key1': { '.validate': "newData.isNumber()" },
                        '.validate': "newData.hasChildren()" },
                    '$other': { '.validate': "false" } } },
            { data: "type T {x: Map<String, Number>}",
                expect: { '.validate': "newData.hasChildren()",
                    x: { '$key1': { '.validate': "newData.isNumber()" },
                        '.validate': "newData.hasChildren()" },
                    '$other': { '.validate': "false" } } },
            { data: "type SmallString extends String { validate() { this.length < 32 } } " +
                    "type T {x: Map<SmallString, Number>}",
                expect: { '.validate': "newData.hasChildren()",
                    x: { '$key1': { '.validate': "$key1.length < 32 && newData.isNumber()" },
                        '.validate': "newData.hasChildren()" },
                    '$other': { '.validate': "false" } } },
            { data: "type M extends Map<String, Number>; type T { x: M }",
                expect: { '.validate': "newData.hasChildren()",
                    '$other': { '.validate': "false" },
                    'x': { '$key1': { '.validate': "newData.isNumber()" },
                        '.validate': "newData.hasChildren()" } } },
            { data: "type Pair<X, Y> { first: X, second: Y } type T extends Pair<String, Number>;",
                expect: { '.validate': "newData.hasChildren(['first', 'second'])",
                    'first': { '.validate': "newData.isString()" },
                    'second': { '.validate': "newData.isNumber()" },
                    '$other': { '.validate': "false" } } },
            { data: "type X { a: Number, validate() { this.a == key() } } type T extends X[];",
                expect: { '$key1': { '.validate': "newData.hasChildren(['a']) && newData.child('a').val() == $key1",
                        'a': { '.validate': "newData.isNumber()" },
                        '$other': { '.validate': "false" } },
                    '.validate': "newData.hasChildren()"
                } },
            { data: "type X { a: Number, validate() { this.a == key() } } type T { x: X }",
                expect: { 'x': { '.validate': "newData.hasChildren(['a']) && newData.child('a').val() == 'x'",
                        'a': { '.validate': "newData.isNumber()" },
                        '$other': { '.validate': "false" } },
                    '$other': { '.validate': "false" },
                    '.validate': "newData.hasChildren(['x'])"
                } },
            { data: "type T extends String { validate() { root == 'new' && prior(root) == 'old' } }" +
                    "path /t/x is Any { read() { root == 'old' } }",
                expect: { '.validate': "newData.isString() && newData.parent().val() == 'new' && root.val() == 'old'",
                    'x': { '.read': "root.val() == 'old'" }
                } },
        ];
        helper.dataDrivenTest(tests, function (data, expect) {
            var symbols = parse(data + " path /t is T;");
            var gen = new bolt.Generator(symbols);
            var rules = gen.generateRules();
            if (expect === undefined) {
                assert.deepEqual(rules, { "rules": {} });
            }
            else {
                assert.deepEqual(rules, { "rules": { t: expect } });
            }
        });
    });
    suite("extendValidator", function () {
        var tests = [
            { data: { target: {}, src: {} },
                expect: {} },
            { data: { target: {}, src: { '.x': [1] } },
                expect: { '.x': [1] } },
            { data: { target: { '.x': [1] }, src: { '.x': [2] } },
                expect: { '.x': [1, 2] } },
            { data: { target: { '.x': [1] }, src: { '.x': [2], c: { '.x': [3] } } },
                expect: { '.x': [1, 2], c: { '.x': [3] } } },
            { data: { target: { '.x': [1], c: { '.x': [2] } }, src: { c: { '.x': [3] } } },
                expect: { '.x': [1], c: { '.x': [2, 3] } } },
            { data: { target: {}, src: { a: { b: { c: { d: { '.x': [1], e: { '.x': [2] } } } } } } },
                expect: { a: { b: { c: { d: { '.x': [1], e: { '.x': [2] } } } } } } },
        ];
        helper.dataDrivenTest(tests, function (data, expect) {
            generator.extendValidator(data.target, data.src);
            assert.deepEqual(data.target, expect);
        });
    });
    suite("mapValidator", function () {
        var tests = [
            { data: { '.x': 'a' }, expect: { '.x': 'a+' } },
            { data: { '.x': 'b' }, expect: {} },
        ];
        helper.dataDrivenTest(tests, function (data, expect) {
            generator.mapValidator(data, function (value, prop) {
                if (value === 'b') {
                    return undefined;
                }
                return value + '+';
            });
            assert.deepEqual(data, expect);
        });
    });
    suite("Schema Generation Errors", function () {
        var tests = [
            { data: "",
                expect: /at least one path/ },
            { data: "type Simple extends String {a: String} path /x is Simple;",
                expect: /properties.*extend/ },
            { data: "path /y { index() { return 1; }}",
                expect: /index.*string/i },
            { data: "path /x { write() { return undefinedFunc(); }}",
                expect: /undefined.*function/i },
            { data: "path /x is NoSuchType {}",
                expect: /No type.*NoSuchType/ },
            { data: "path /x { unsupported() { true } }",
                warn: /unsupported method/i },
            { data: "path /x { validate() { return this.test(123); } }",
                expect: /convert value/i },
            { data: "path /x { validate() { return this.test('a/'); } }",
                expect: /convert value/i },
            { data: "path /x { validate() { return this.test('/a/'); } }",
                expect: /convert value/i },
            { data: "function f(a) { return f(a); } path / { validate() { return f(1); }}",
                expect: /recursive/i },
            { data: "type X { $n: Number, $s: String } path / is X;",
                expect: /wild property/ },
            { data: "type X { $$n: Number } path / is X;",
                expect: /property names/i },
            { data: "type X { '\x01': Number } path / is X;",
                expect: /property names/i },
            { data: "path / is Map;",
                expect: /No type.*non-generic/ },
            { data: "type Pair<X, Y> {a: X, b: Y} path / is Pair;",
                expect: /No type.*non-generic/ },
            { data: "path / is String<Number>;",
                expect: /No type.*generic/ },
            { data: "path / is Map<Object, Number>;",
                expect: /must derive from String/ },
            { data: "path / { write() { true } create() { true } }",
                expect: /write-aliasing.*create/i },
            { data: "path / { write() { true } update() { true } }",
                expect: /write-aliasing.*update/i },
            { data: "path / { write() { true } delete() { true } }",
                expect: /write-aliasing.*delete/i },
        ];
        helper.dataDrivenTest(tests, function (data, expect, t) {
            logger.reset();
            logger.silent();
            var symbols = parse(data);
            var gen = new bolt.Generator(symbols);
            var lastError;
            try {
                gen.generateRules();
            }
            catch (e) {
                if (!expect) {
                    throw e;
                }
                lastError = logger.getLastMessage() || e.message;
                assert.match(lastError, expect);
                return;
            }
            if (expect) {
                assert.fail(undefined, undefined, "No exception thrown.");
            }
            if (t.warn) {
                assert.match(logger.getLastMessage(), t.warn);
            }
        });
    });
});

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInRlc3QvZ2VuZXJhdG9yLXRlc3QudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBOzs7Ozs7Ozs7Ozs7OztHQWNHO0FBQ0gsSUFBWSxJQUFJLFdBQU0sU0FBUyxDQUFDLENBQUE7QUFDaEMsSUFBSSxLQUFLLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQztBQUN2QixJQUFZLFNBQVMsV0FBTSxvQkFBb0IsQ0FBQyxDQUFBO0FBQ2hELElBQVksR0FBRyxXQUFNLFFBQVEsQ0FBQyxDQUFBO0FBQzlCLElBQVksTUFBTSxXQUFNLFlBQVksQ0FBQyxDQUFBO0FBQ3JDLElBQVksTUFBTSxXQUFNLFdBQVcsQ0FBQyxDQUFBO0FBQ3BDLElBQVksTUFBTSxXQUFNLGVBQWUsQ0FBQyxDQUFBO0FBQ3hDLDZCQUFzQixnQkFBZ0IsQ0FBQyxDQUFBO0FBRXZDLElBQVksSUFBSSxXQUFNLE1BQU0sQ0FBQyxDQUFBO0FBQzdCLElBQUksQ0FBQyxNQUFNLENBQUMsaUJBQWlCLEdBQUcsSUFBSSxDQUFDO0FBQ3JDLElBQUksTUFBTSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUM7QUFFekIsMERBQTBEO0FBQzFELHNFQUFzRTtBQUV0RSxLQUFLLENBQUMsdUJBQXVCLEVBQUU7SUFDN0IsS0FBSyxDQUFDLGVBQWUsRUFBRTtRQUNyQixJQUFJLEtBQUssR0FBRztZQUNWLEVBQUUsSUFBSSxFQUFFLDJDQUEyQztnQkFDakQsTUFBTSxFQUFFLEVBQUUsS0FBSyxFQUFFLEVBQUMsT0FBTyxFQUFFLE1BQU0sRUFBRSxRQUFRLEVBQUUsTUFBTSxFQUFDLEVBQUU7YUFDdkQ7WUFDRCxFQUFFLElBQUksRUFBRSw0QkFBNEI7Z0JBQ2xDLE1BQU0sRUFBRSxFQUFFLEtBQUssRUFBRSxFQUFDLFFBQVEsRUFBRSxNQUFNLEVBQUMsRUFBRTthQUN0QztZQUNELEVBQUUsSUFBSSxFQUFFLDZCQUE2QjtnQkFDbkMsTUFBTSxFQUFFLEVBQUUsS0FBSyxFQUFFLEVBQUMsUUFBUSxFQUFFLG9CQUFv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RUFBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBQyxFQUFFO1lBQ3ZCLEVBQUUsSUFBSSxFQUFFLEVBQUMsTUFBTSxFQUFFLEVBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxHQUFHLEVBQUUsRUFBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBQyxFQUFDO2dCQUM3QyxNQUFNLEVBQUUsRUFBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUMsRUFBRTtZQUMxQixFQUFFLElBQUksRUFBRSxFQUFDLE1BQU0sRUFBRSxFQUFDLElBQUksRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsR0FBRyxFQUFFLEVBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBQyxFQUFDO2dCQUM3RCxNQUFNLEVBQUUsRUFBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBQyxFQUFFO1lBQzFDLEVBQUUsSUFBSSxFQUFFLEVBQUMsTUFBTSxFQUFFLEVBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBQyxFQUFFLEdBQUcsRUFBRSxFQUFDLENBQUMsRUFBRSxFQUFDLElBQUksRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUMsRUFBQztnQkFDbEUsTUFBTSxFQUFFLEVBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFDLEVBQUMsRUFBRTtZQUMxQyxFQUFFLElBQUksRUFBRSxFQUFDLE1BQU0sRUFBRSxFQUFFLEVBQUUsR0FBRyxFQUFFLEVBQUMs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QUM7Z0JBQ1gsRUFBRSxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO29CQUNaLE1BQU0sQ0FBQyxDQUFDO2dCQUNWLENBQUM7Z0JBQ0QsU0FBUyxHQUFHLE1BQU0sQ0FBQyxjQUFjLEVBQUUsSUFBSSxDQUFDLENBQUMsT0FBTyxDQUFDO2dCQUNqRCxNQUFNLENBQUMsS0FBSyxDQUFDLFNBQVMsRUFBRSxNQUFNLENBQUMsQ0FBQztnQkFDaEMsTUFBTSxDQUFDO1lBQ1QsQ0FBQztZQUNELEVBQUUsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7Z0JBQ1gsTUFBTSxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUUsU0FBUyxFQUFFLHNCQUFzQixDQUFDLENBQUM7WUFDNUQsQ0FBQztZQUNELEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO2dCQUNYLE1BQU0sQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLGNBQWMsRUFBRSxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUNoRCxDQUFDO1FBQ0gsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDLENBQUMsQ0FBQztBQUNMLENBQUMsQ0FBQyxDQUFDIiwiZmlsZSI6InRlc3QvZ2VuZXJhdG9yLXRlc3QuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogQ29weXJpZ2h0IDIwMTUgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmltcG9ydCAqIGFzIGJvbHQgZnJvbSAnLi4vYm9sdCc7XG5sZXQgcGFyc2UgPSBib2x0LnBhcnNlO1xuaW1wb3J0ICogYXMgZ2VuZXJhdG9yIGZyb20gJy4uL3J1bGVzLWdlbmVyYXRvcic7XG5pbXBvcnQgKiBhcyBhc3QgZnJvbSAnLi4vYXN0JztcbmltcG9ydCAqIGFzIGZpbGVpbyBmcm9tICcuLi9maWxlLWlvJztcbmltcG9ydCAqIGFzIGxvZ2dlciBmcm9tICcuLi9sb2dnZXInO1xuaW1wb3J0ICogYXMgaGVscGVyIGZyb20gJy4vdGVzdC1oZWxwZXInO1xuaW1wb3J0IHtzYW1wbGVzfSBmcm9tICcuL3NhbXBsZS1maWxlcyc7XG5cbmltcG9ydCAqIGFzIGNoYWkgZnJvbSAnY2hhaSc7XG5jaGFpLmNvbmZpZy50cnVuY2F0ZVRocmVzaG9sZCA9IDEwMDA7XG5sZXQgYXNzZXJ0ID0gY2hhaS5hc3NlcnQ7XG5cbi8vIFRPRE86IFRlc3QgZHVwbGljYXRlZCBmdW5jdGlvbiwgYW5kIHNjaGVtYSBkZWZpbml0aW9ucy5cbi8vIFRPRE86IFRlc3Qgb3RoZXIgcGFyc2VyIGVycm9ycyAtIGFwcHJvcHJpYXRlIG1lc3NhZ2VzIChleGNlcHRpb25zKS5cblxuc3VpdGUoXCJSdWxlcyBHZW5lcmF0b3IgVGVzdHNcIiwgZnVuY3Rpb24oKSB7XG4gIHN1aXRlKFwiQmFzaWMgU2FtcGxlc1wiLCBmdW5jdGlvbigpIHtcbiAgICB2YXIgdGVzdHMgPSBbXG4gICAgICB7IGRhdGE6IFwicGF0aCAvIHtyZWFkKCkgeyB0cnVlIH0gd3JpdGUoKSB7IHRydWUgfX1cIixcbiAgICAgICAgZXhwZWN0OiB7IHJ1bGVzOiB7XCIucmVhZFwiOiBcInRydWVcIiwgXCIud3JpdGVcIjogXCJ0cnVlXCJ9IH1cbiAgICAgIH0sXG4gICAgICB7IGRhdGE6IFwicGF0aCAvIHsgd3JpdGUoKSB7IHRydWUgfX1cIixcbiAgICAgICAgZXhwZWN0OiB7IHJ1bGVzOiB7XCIud3JpdGVcIjogXCJ0cnVlXCJ9IH1cbiAgICAgIH0sXG4gICAgICB7IGRhdGE6IFwicGF0aCAvIHsgY3JlYXRlKCkgeyB0cnVlIH19XCIsXG4gICAgICAgIGV4cGVjdDogeyBydWxlczoge1wiLndyaXRlXCI6IFwiZGF0YS52YWwoKSA9PSBudWxsXCJ9IH1cbiAgICAgIH0sXG4gICAgICB7IGRhdGE6IFwicGF0aCAvIHsgdXBkYXRlKCkgeyB0cnVlIH19XCIsXG4gICAgICAgIGV4cGVjdDogeyBydWxlczoge1wiLndyaXRlXCI6IFwiZGF0YS52YWwoKSAhPSBudWxsICYmIG5ld0RhdGEudmFsKCkgIT0gbnVsbFwifSB9XG4gICAgICB9LFxuICAgICAgeyBkYXRhOiBcInBhdGggLyB7IGRlbGV0ZSgpIHsgdHJ1ZSB9fVwiLFxuICAgICAgICBleHBlY3Q6IHsgcnVsZXM6IHtcIi53cml0ZVwiOiBcImRhdGEudmFsKCkgIT0gbnVsbCAmJiBuZXdEYXRhLnZhbCgpID09IG51bGxcIn0gfVxuICAgICAgfSxcbiAgICAgIHsgZGF0YTogXCJwYXRoIC8ge3JlYWQoKSB7IHRydWUgfX1cIixcbiAgICAgICAgZXhwZWN0OiB7IHJ1bGVzOiB7XCIucmVhZFwiOiBcInRydWVcIn0gfVxuICAgICAgfSxcbiAgICAgIHsgZGF0YTogXCJwYXRoIC8geyByZWFkKCkgeyBmYWxzZSB9fVwiLFxuICAgICAgICBleHBlY3Q6IHsgcnVsZXM6IHt9IH1cbiAgICAgIH0sXG4gICAgICB7IGRhdGE6IFwicGF0aCAvIHtpbmRleCgpIHsgcmV0dXJuIFsnYScsICdiJ107IH19XCIsXG4gICAgICAgIGV4cGVjdDogeyBydWxlczoge1wiLmluZGV4T25cIjogW1wiYVwiLCBcImJcIl19IH1cbiAgICAgIH0sXG4gICAgICB7IGRhdGE6IFwicGF0aCAvIHsgdmFsaWRhdGUoKSB7IHJldHVybiB0aGlzID4gMDsgfX1cIixcbiAgICAgICAgZXhwZWN0OiB7IHJ1bGVzOiB7IFwiLnZhbGlkYXRlXCI6IFwibmV3RGF0YS52YWwoKSA+IDBcIiB9IH1cbiAgICAgIH0sXG4gICAgXTtcblxuICAgIGhlbHBlci5kYXRhRHJpdmVuVGVzdCh0ZXN0cywgZnVuY3Rpb24oZGF0YSwgZXhwZWN0KSB7XG4gICAgICB2YXIgcmVzdWx0ID0gcGFyc2UoZGF0YSk7XG4gICAgICBhc3NlcnQub2socmVzdWx0KTtcbiAgICAgIHZhciBnZW4gPSBuZXcgYm9sdC5HZW5lcmF0b3IocmVzdWx0KTtcbiAgICAgIHZhciBqc29uID0gZ2VuLmdlbmVyYXRlUnVsZXMoKTtcbiAgICAgIGFzc2VydC5kZWVwRXF1YWwoanNvbiwgZXhwZWN0KTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgc3VpdGUoXCJTYW1wbGUgZmlsZXNcIiwgZnVuY3Rpb24oKSB7XG4gICAgaGVscGVyLmRhdGFEcml2ZW5UZXN0KHNhbXBsZXMsIGZ1bmN0aW9uKGZpbGVuYW1lKSB7XG4gICAgICBmaWxlbmFtZSA9ICdzYW1wbGVzLycgKyBmaWxlbmFtZSArICcuJyArIGJvbHQuRklMRV9FWFRFTlNJT047XG4gICAgICByZXR1cm4gZmlsZWlvLnJlYWRGaWxlKGZpbGVuYW1lKVxuICAgICAgICAudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAgIHZhciByZXN1bHQgPSBwYXJzZShyZXNwb25zZS5jb250ZW50KTtcbiAgICAgICAgICBhc3NlcnQub2socmVzdWx0LCByZXNwb25zZS51cmwpO1xuICAgICAgICAgIHZhciBnZW4gPSBuZXcgYm9sdC5HZW5lcmF0b3IocmVzdWx0KTtcbiAgICAgICAgICB2YXIganNvbiA9IGdlbi5nZW5lcmF0ZVJ1bGVzKCk7XG4gICAgICAgICAgYXNzZXJ0Lm9rKCdydWxlcycgaW4ganNvbiwgcmVzcG9uc2UudXJsICsgXCIgaGFzIHJ1bGVzXCIpO1xuICAgICAgICAgIHJldHVybiBmaWxlaW8ucmVhZEpTT05GaWxlKHJlc3BvbnNlLnVybC5yZXBsYWNlKCcuJyArIGJvbHQuRklMRV9FWFRFTlNJT04sICcuanNvbicpKVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UyKSB7XG4gICAgICAgICAgICAgIGFzc2VydC5kZWVwRXF1YWwoanNvbiwgcmVzcG9uc2UyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICBhc3NlcnQub2soZmFsc2UsIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgc3VpdGUoXCJQYXJ0aWFsIGV2YWx1YXRpb25cIiwgZnVuY3Rpb24oKSB7XG4gICAgdmFyIHRlc3RzID0gW1xuICAgICAgeyBmOiBcImZ1bmN0aW9uIGYoYSkgeyByZXR1cm4gdHJ1ZSA9PSBhOyB9XCIsIHg6IFwiZihhID09IGIpXCIsIGV4cGVjdDogXCJ0cnVlID09IChhID09IGIpXCIgfSxcbiAgICAgIHsgZjogXCJmdW5jdGlvbiBmKGEpIHsgcmV0dXJuIGEgPT0gdHJ1ZTsgfVwiLCB4OiBcImYoYSA9PSBiKVwiLCBleHBlY3Q6IFwiYSA9PSBiID09IHRydWVcIiB9LFxuICAgICAgeyBmOiBcImZ1bmN0aW9uIGYoYSkgeyByZXR1cm4gYSArIDM7IH1cIiwgeDogXCJmKDEgKyAyKVwiLCBleHBlY3Q6IFwiMSArIDIgKyAzXCIgfSxcbiAgICAgIHsgZjogXCJmdW5jdGlvbiBmKGEpIHsgcmV0dXJuIGEgKyAzOyB9XCIsIHg6IFwiZigxICogMilcIiwgZXhwZWN0OiBcIjEgKiAyICsgM1wiIH0sXG4gICAgICB7IGY6IFwiZnVuY3Rpb24gZihhKSB7IHJldHVybiBhICogMzsgfVwiLCB4OiBcImYoMSArIDIpXCIsIGV4cGVjdDogXCIoMSArIDIpICogM1wiIH0sXG4gICAgICB7IGY6IFwiZnVuY3Rpb24gZihhKSB7IHJldHVybiBhICsgMTsgfVwiLCB4OiBcImYoYSArIGEpXCIsIGV4cGVjdDogXCJhICsgYSArIDFcIiB9LFxuICAgICAgeyBmOiBcImZ1bmN0aW9uIGYoYSkgeyByZXR1cm4gZyhhKTsgfSBmdW5jdGlvbiBnKGEpIHsgcmV0dXJuIGEgPT0gdHJ1ZTsgfVwiLFxuICAgICAgICB4OiBcImYoMTIzKVwiLCBleHBlY3Q6IFwiMTIzID09IHRydWVcIiB9LFxuICAgICAgeyBmOiBcImZ1bmN0aW9uIGYoYSwgYikgeyByZXR1cm4gZyhhKSA9PSBnKGIpOyB9IGZ1bmN0aW9uIGcoYSkgeyByZXR1cm4gYSA9PSB0cnVlOyB9XCIsXG4gICAgICAgIHg6IFwiZigxLCAyKVwiLCBleHBlY3Q6IFwiMSA9PSB0cnVlID09ICgyID09IHRydWUpXCIgfSxcbiAgICAgIC8vIEhpZ2hsZXIgbGV2ZWwgZnVuY3Rpb24gd29ya3MgYXMgbG9uZyBhcyByZXR1cm5zIGEgY29uc3RhbnQgZnVuY3Rpb25cbiAgICAgIHsgZjogXCJmdW5jdGlvbiBmKCkgeyByZXR1cm4gZzsgfSBmdW5jdGlvbiBnKGEpIHsgcmV0dXJuIGEgPT0gdHJ1ZTsgfVwiLFxuICAgICAgICB4OiBcImYoKSgxMjMpXCIsIGV4cGVjdDogXCIxMjMgPT0gdHJ1ZVwiIH0sXG4gICAgICB7IGY6IFwiZnVuY3Rpb24gZihhKSB7IHJldHVybiBhICsgMTsgfVwiLCB4OiBcImFbZigxMjMpXVwiLCBleHBlY3Q6IFwiYVsxMjMgKyAxXVwiIH0sXG4gICAgICB7IGY6IFwiXCIsIHg6IFwidGhpc1wiLCBleHBlY3Q6IFwibmV3RGF0YS52YWwoKSA9PSB0cnVlXCIgfSxcbiAgICAgIHsgZjogXCJcIiwgeDogXCIhdGhpc1wiLCBleHBlY3Q6IFwiIShuZXdEYXRhLnZhbCgpID09IHRydWUpXCIgfSxcbiAgICAgIHsgZjogXCJcIiwgeDogXCJ0aGlzLnByb3BcIiwgZXhwZWN0OiBcIm5ld0RhdGEuY2hpbGQoJ3Byb3AnKS52YWwoKSA9PSB0cnVlXCIgfSxcbiAgICAgIHsgZjogXCJcIiwgeDogXCIhdGhpcy5wcm9wXCIsIGV4cGVjdDogXCIhKG5ld0RhdGEuY2hpbGQoJ3Byb3AnKS52YWwoKSA9PSB0cnVlKVwiIH0sXG4gICAgICB7IGY6IFwiXCIsIHg6IFwidGhpcy5mb28ucGFyZW50KClcIiwgZXhwZWN0OiBcIm5ld0RhdGEuY2hpbGQoJ2ZvbycpLnBhcmVudCgpLnZhbCgpID09IHRydWVcIiB9LFxuICAgICAgeyBmOiBcIlwiLFxuICAgICAgICB4OiBcInRoaXMuZm9vIHx8IHRoaXMuYmFyXCIsXG4gICAgICAgIGV4cGVjdDogXCJuZXdEYXRhLmNoaWxkKCdmb28nKS52YWwoKSA9PSB0cnVlIHx8IG5ld0RhdGEuY2hpbGQoJ2JhcicpLnZhbCgpID09IHRydWVcIn0sXG4gICAgICAvLyBUT0RPOiBEb24ndCBzdXBwb3J0IHNuYXBzaG90IGZ1bmN0aW9ucyBiZXlvbmQgcGFyZW50LlxuICAgICAgLy8gVE9ETzogU2hvdWxkIHdhcm4gdXNlciBub3QgdG8gdXNlIEZpcmViYXNlIGJ1aWx0aW5zIVxuICAgICAgLy8geyBmOiBcIlwiLCB4OiBcInRoaXMuaXNTdHJpbmcoKVwiLCBleHBlY3Q6IFwibmV3RGF0YS5jaGlsZCgnaXNTdHJpbmcnKS52YWwoKSA9PSB0cnVlXCIgfSxcbiAgICAgIHsgZjogXCJmdW5jdGlvbiBmKGEpIHsgcmV0dXJuIGEgPT0gJzEyMyc7IH1cIiwgeDogXCJmKHRoaXMpXCIsIGV4cGVjdDogXCJuZXdEYXRhLnZhbCgpID09ICcxMjMnXCIgfSxcbiAgICAgIHsgZjogXCJmdW5jdGlvbiBmKGEpIHsgcmV0dXJuIGEgPT0gJzEyMyc7IH1cIixcbiAgICAgICAgeDogXCJmKHRoaXMuZm9vKVwiLCBleHBlY3Q6IFwibmV3RGF0YS5jaGlsZCgnZm9vJykudmFsKCkgPT0gJzEyMydcIiB9LFxuICAgIF07XG5cbiAgICBoZWxwZXIuZGF0YURyaXZlblRlc3QodGVzdHMsIGZ1bmN0aW9uKGRhdGEsIGV4cGVjdCkge1xuICAgICAgdmFyIHN5bWJvbHMgPSBwYXJzZShkYXRhLmYgKyBcIiBwYXRoIC94IHsgd3JpdGUoKSB7IHJldHVybiBcIiArIGRhdGEueCArIFwiOyB9fVwiKTtcbiAgICAgIHZhciBnZW4gPSBuZXcgYm9sdC5HZW5lcmF0b3Ioc3ltYm9scyk7XG4gICAgICAvLyBNYWtlIHN1cmUgbG9jYWwgU2NoZW1hIGluaXRpYWxpemVkLlxuICAgICAgdmFyIGpzb24gPSA8YW55PiBnZW4uZ2VuZXJhdGVSdWxlcygpO1xuICAgICAgYXNzZXJ0LmVxdWFsKGpzb25bJ3J1bGVzJ11bJ3gnXVsnLndyaXRlJ10sIGV4cGVjdCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIHN1aXRlKFwiU3RyaW5nIG1ldGhvZHNcIiwgZnVuY3Rpb24oKSB7XG4gICAgdmFyIHRlc3RzID0gW1xuICAgICAgeyBkYXRhOiBcInRoaXMubGVuZ3RoXCIsXG4gICAgICAgIGV4cGVjdDogXCJuZXdEYXRhLnZhbCgpLmxlbmd0aFwiIH0sXG4gICAgICB7IGRhdGE6IFwidGhpcy5sZW5ndGggPCAxMDBcIixcbiAgICAgICAgZXhwZWN0OiBcIm5ld0RhdGEudmFsKCkubGVuZ3RoIDwgMTAwXCIgfSxcbiAgICAgIHsgZGF0YTogXCInYWJjJy5sZW5ndGhcIixcbiAgICAgICAgZXhwZWN0OiBcIidhYmMnLmxlbmd0aFwiIH0sXG4gICAgICB7IGRhdGE6IFwiJ2FiYycuaW5jbHVkZXMoJ2InKVwiLFxuICAgICAgICBleHBlY3Q6IFwiJ2FiYycuY29udGFpbnMoJ2InKVwiIH0sXG4gICAgICB7IGRhdGE6IFwidGhpcy5pbmNsdWRlcygnYicpXCIsXG4gICAgICAgIGV4cGVjdDogXCJuZXdEYXRhLnZhbCgpLmNvbnRhaW5zKCdiJylcIiB9LFxuICAgICAgeyBkYXRhOiBcIidhYmMnLmluY2x1ZGVzKHRoaXMpXCIsXG4gICAgICAgIGV4cGVjdDogXCInYWJjJy5jb250YWlucyhuZXdEYXRhLnZhbCgpKVwiIH0sXG4gICAgICB7IGRhdGE6IFwiJ2FiYycuc3RhcnRzV2l0aCh0aGlzKVwiLFxuICAgICAgICBleHBlY3Q6IFwiJ2FiYycuYmVnaW5zV2l0aChuZXdEYXRhLnZhbCgpKVwiIH0sXG4gICAgICB7IGRhdGE6IFwiJ2FiYycuZW5kc1dpdGgodGhpcylcIixcbiAgICAgICAgZXhwZWN0OiBcIidhYmMnLmVuZHNXaXRoKG5ld0RhdGEudmFsKCkpXCIgfSxcbiAgICAgIHsgZGF0YTogXCInYWJjJy5yZXBsYWNlKHRoaXMuYSwgdGhpcy5iKVwiLFxuICAgICAgICBleHBlY3Q6IFwiJ2FiYycucmVwbGFjZShuZXdEYXRhLmNoaWxkKCdhJykudmFsKCksIG5ld0RhdGEuY2hpbGQoJ2InKS52YWwoKSlcIiB9LFxuICAgICAgeyBkYXRhOiBcIidBQkMnLnRvTG93ZXJDYXNlKClcIixcbiAgICAgICAgZXhwZWN0OiBcIidBQkMnLnRvTG93ZXJDYXNlKClcIiB9LFxuICAgICAgeyBkYXRhOiBcIidhYmMnLnRvVXBwZXJDYXNlKClcIixcbiAgICAgICAgZXhwZWN0OiBcIidhYmMnLnRvVXBwZXJDYXNlKClcIiB9LFxuICAgICAgeyBkYXRhOiBcInRoaXMudG9VcHBlckNhc2UoKVwiLFxuICAgICAgICBleHBlY3Q6IFwibmV3RGF0YS52YWwoKS50b1VwcGVyQ2FzZSgpXCIgfSxcbiAgICAgIHsgZGF0YTogXCInYWJhYmEnLnRlc3QoL2JhYi8pXCIsXG4gICAgICAgIGV4cGVjdDogXCInYWJhYmEnLm1hdGNoZXMoL2JhYi8pXCIgfSxcbiAgICBdO1xuXG4gICAgaGVscGVyLmRhdGFEcml2ZW5UZXN0KHRlc3RzLCBmdW5jdGlvbihkYXRhLCBleHBlY3QpIHtcbiAgICAgIHZhciBzeW1ib2xzID0gcGFyc2UoXCJwYXRoIC94IHsgd3JpdGUoKSB7IHJldHVybiBcIiArIGRhdGEgKyBcIjsgfX1cIik7XG4gICAgICB2YXIgZ2VuID0gbmV3IGJvbHQuR2VuZXJhdG9yKHN5bWJvbHMpO1xuICAgICAgLy8gTWFrZSBzdXJlIGxvY2FsIFNjaGVtYSBpbml0aWFsaXplZC5cbiAgICAgIHZhciBqc29uID0gPGFueT4gZ2VuLmdlbmVyYXRlUnVsZXMoKTtcbiAgICAgIGFzc2VydC5lcXVhbChqc29uWydydWxlcyddWyd4J11bJy53cml0ZSddLCBleHBlY3QpO1xuICAgIH0pO1xuICB9KTtcblxuICBzdWl0ZShcIkJ1aWx0aW4gdmFsaWRhdGlvbiBmdW5jdGlvbnNcIiwgZnVuY3Rpb24oKSB7XG4gICAgdmFyIHRlc3RzID0gW1xuICAgICAgWyAnU3RyaW5nJywgJ3RoaXMuaXNTdHJpbmcoKSddLFxuICAgICAgWyAnTnVtYmVyJywgJ3RoaXMuaXNOdW1iZXIoKSddLFxuICAgICAgWyAnQm9vbGVhbicsICd0aGlzLmlzQm9vbGVhbigpJ10sXG4gICAgICBbICdPYmplY3QnLCAndGhpcy5oYXNDaGlsZHJlbigpJ10sXG4gICAgICBbICdOdWxsJywgJ2ZhbHNlJ10sXG4gICAgXTtcblxuICAgIGhlbHBlci5kYXRhRHJpdmVuVGVzdCh0ZXN0cywgZnVuY3Rpb24oZGF0YSwgZXhwZWN0KSB7XG4gICAgICB2YXIgc3ltYm9scyA9IHBhcnNlKFwicGF0aCAvIHt9XCIpO1xuICAgICAgdmFyIGdlbiA9IG5ldyBib2x0LkdlbmVyYXRvcihzeW1ib2xzKTtcbiAgICAgIGdlbi5lbnN1cmVWYWxpZGF0b3IoYXN0LnR5cGVUeXBlKGRhdGEpKTtcblxuICAgICAgdmFyIHRlcm1zID0gPGFzdC5FeHBbXT4gZ2VuLnZhbGlkYXRvcnNbZGF0YV1bJy52YWxpZGF0ZSddO1xuICAgICAgdmFyIHJlc3VsdCA9IGJvbHQuZGVjb2RlRXhwcmVzc2lvbihhc3QuYW5kQXJyYXkodGVybXMpKTtcbiAgICAgIGFzc2VydC5kZWVwRXF1YWwocmVzdWx0LCBleHBlY3QpO1xuICAgIH0pO1xuICB9KTtcblxuICBzdWl0ZShcIlNjaGVtYSBWYWxpZGF0aW9uXCIsIGZ1bmN0aW9uKCkge1xuICAgIHZhciB0ZXN0cyA9IFtcbiAgICAgIHsgZGF0YTogXCJ0eXBlIFQge31cIixcbiAgICAgICAgZXhwZWN0OiB1bmRlZmluZWQgfSxcbiAgICAgIHsgZGF0YTogXCJ0eXBlIFQgZXh0ZW5kcyBPYmplY3Qge31cIixcbiAgICAgICAgZXhwZWN0OiB7Jy52YWxpZGF0ZSc6IFwibmV3RGF0YS5oYXNDaGlsZHJlbigpXCJ9IH0sXG4gICAgICB7IGRhdGE6IFwidHlwZSBUIGV4dGVuZHMgU3RyaW5nIHt9XCIsXG4gICAgICAgIGV4cGVjdDogeycudmFsaWRhdGUnOiBcIm5ld0RhdGEuaXNTdHJpbmcoKVwifSB9LFxuICAgICAgeyBkYXRhOiBcInR5cGUgVCBleHRlbmRzIFN0cmluZyB7IHZhbGlkYXRlKCkgeyByZXR1cm4gdGhpcy5sZW5ndGggPiAwOyB9IH1cIixcbiAgICAgICAgZXhwZWN0OiB7Jy52YWxpZGF0ZSc6IFwibmV3RGF0YS5pc1N0cmluZygpICYmIG5ld0RhdGEudmFsKCkubGVuZ3RoID4gMFwifSB9LFxuICAgICAgeyBkYXRhOiBcInR5cGUgTm9uRW1wdHkgZXh0ZW5kcyBTdHJpbmcgeyB2YWxpZGF0ZSgpIHsgcmV0dXJuIHRoaXMubGVuZ3RoID4gMDsgfSB9IFxcXG4gICAgICAgICAgICB0eXBlIFQgeyBwcm9wOiBOb25FbXB0eSB9XCIsXG4gICAgICAgIGV4cGVjdDogeycudmFsaWRhdGUnOiBcIm5ld0RhdGEuaGFzQ2hpbGRyZW4oWydwcm9wJ10pXCIsXG4gICAgICAgICAgICAgICAgIHByb3A6IHtcbiAgICAgICAgICAgICAgICAgICAnLnZhbGlkYXRlJzogJ25ld0RhdGEuaXNTdHJpbmcoKSAmJiBuZXdEYXRhLnZhbCgpLmxlbmd0aCA+IDAnXG4gICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICckb3RoZXInOiB7Jy52YWxpZGF0ZSc6IFwiZmFsc2VcIn1cbiAgICAgICAgICAgICAgICB9IH0sXG4gICAgICB7IGRhdGE6IFwidHlwZSBUIHtuOiBOdW1iZXJ9XCIsXG4gICAgICAgIGV4cGVjdDogeycudmFsaWRhdGUnOiBcIm5ld0RhdGEuaGFzQ2hpbGRyZW4oWyduJ10pXCIsXG4gICAgICAgICAgICAgICAgIG46IHsnLnZhbGlkYXRlJzogXCJuZXdEYXRhLmlzTnVtYmVyKClcIn0sXG4gICAgICAgICAgICAgICAgICckb3RoZXInOiB7Jy52YWxpZGF0ZSc6IFwiZmFsc2VcIn19IH0sXG4gICAgICB7IGRhdGE6IFwidHlwZSBUIHtzOiBTdHJpbmd9XCIsXG4gICAgICAgIGV4cGVjdDogeycudmFsaWRhdGUnOiBcIm5ld0RhdGEuaGFzQ2hpbGRyZW4oWydzJ10pXCIsXG4gICAgICAgICAgICAgICAgIHM6IHsnLnZhbGlkYXRlJzogXCJuZXdEYXRhLmlzU3RyaW5nKClcIn0sXG4gICAgICAgICAgICAgICAgICckb3RoZXInOiB7Jy52YWxpZGF0ZSc6IFwiZmFsc2VcIn19IH0sXG4gICAgICB7IGRhdGE6IFwidHlwZSBUIHtiOiBCb29sZWFufVwiLFxuICAgICAgICBleHBlY3Q6IHsnLnZhbGlkYXRlJzogXCJuZXdEYXRhLmhhc0NoaWxkcmVuKFsnYiddKVwiLFxuICAgICAgICAgICAgICAgICBiOiB7Jy52YWxpZGF0ZSc6IFwibmV3RGF0YS5pc0Jvb2xlYW4oKVwifSxcbiAgICAgICAgICAgICAgICAgJyRvdGhlcic6IHsnLnZhbGlkYXRlJzogXCJmYWxzZVwifX0gfSxcbiAgICAgIHsgZGF0YTogXCJ0eXBlIFQge3g6IE9iamVjdH1cIixcbiAgICAgICAgZXhwZWN0OiB7Jy52YWxpZGF0ZSc6IFwibmV3RGF0YS5oYXNDaGlsZHJlbihbJ3gnXSlcIixcbiAgICAgICAgICAgICAgICAgeDogeycudmFsaWRhdGUnOiBcIm5ld0RhdGEuaGFzQ2hpbGRyZW4oKVwifSxcbiAgICAgICAgICAgICAgICAgJyRvdGhlcic6IHsnLnZhbGlkYXRlJzogXCJmYWxzZVwifX0gfSxcbiAgICAgIHsgZGF0YTogXCJ0eXBlIFQge3g6IE51bWJlcnxTdHJpbmd9XCIsXG4gICAgICAgIGV4cGVjdDogeycudmFsaWRhdGUnOiBcIm5ld0RhdGEuaGFzQ2hpbGRyZW4oWyd4J10pXCIsXG4gICAgICAgICAgICAgICAgIHg6IHsnLnZhbGlkYXRlJzogXCJuZXdEYXRhLmlzTnVtYmVyKCkgfHwgbmV3RGF0YS5pc1N0cmluZygpXCJ9LFxuICAgICAgICAgICAgICAgICAnJG90aGVyJzogeycudmFsaWRhdGUnOiBcImZhbHNlXCJ9fSB9LFxuXG4gICAgICB7IGRhdGE6IFwidHlwZSBUIHsgJGtleTogTnVtYmVyIH1cIixcbiAgICAgICAgZXhwZWN0OiB7Jy52YWxpZGF0ZSc6IFwibmV3RGF0YS5oYXNDaGlsZHJlbigpXCIsXG4gICAgICAgICAgICAgICAgICcka2V5JzogeycudmFsaWRhdGUnOiBcIm5ld0RhdGEuaXNOdW1iZXIoKVwifX0gfSxcblxuICAgICAgeyBkYXRhOiBcInR5cGUgVCB7ICdhIGInOiBOdW1iZXIgfVwiLFxuICAgICAgICBleHBlY3Q6IHsnLnZhbGlkYXRlJzogXCJuZXdEYXRhLmhhc0NoaWxkcmVuKFsnYSBiJ10pXCIsXG4gICAgICAgICAgICAgICAgICdhIGInOiB7Jy52YWxpZGF0ZSc6IFwibmV3RGF0YS5pc051bWJlcigpXCJ9LFxuICAgICAgICAgICAgICAgICAnJG90aGVyJzogeycudmFsaWRhdGUnOiAnZmFsc2UnfX0gfSxcblxuICAgICAgeyBkYXRhOiBcInR5cGUgVCB7YTogTnVtYmVyLCBiOiBTdHJpbmd9XCIsXG4gICAgICAgIGV4cGVjdDogeycudmFsaWRhdGUnOiBcIm5ld0RhdGEuaGFzQ2hpbGRyZW4oWydhJywgJ2InXSlcIixcbiAgICAgICAgICAgICAgICAgYTogeycudmFsaWRhdGUnOiBcIm5ld0RhdGEuaXNOdW1iZXIoKVwifSxcbiAgICAgICAgICAgICAgICAgYjogeycudmFsaWRhdGUnOiBcIm5ld0RhdGEuaXNTdHJpbmcoKVwifSxcbiAgICAgICAgICAgICAgICAgJyRvdGhlcic6IHsnLnZhbGlkYXRlJzogXCJmYWxzZVwifX0gfSxcbiAgICAgIHsgZGF0YTogXCJ0eXBlIFQge3g6IE51bWJlcnxOdWxsfVwiLFxuICAgICAgICBleHBlY3Q6IHsnLnZhbGlkYXRlJzogXCJuZXdEYXRhLmhhc0NoaWxkcmVuKClcIixcbiAgICAgICAgICAgICAgICAgeDogeycudmFsaWRhdGUnOiBcIm5ld0RhdGEuaXNOdW1iZXIoKVwifSxcbiAgICAgICAgICAgICAgICAgJyRvdGhlcic6IHsnLnZhbGlkYXRlJzogXCJmYWxzZVwifX0gfSxcbiAgICAgIHsgZGF0YTogXCJ0eXBlIFQge246IE51bWJlciwgdmFsaWRhdGUoKSB7cmV0dXJuIHRoaXMubiA8IDc7fX1cIixcbiAgICAgICAgZXhwZWN0OiB7Jy52YWxpZGF0ZSc6IFwibmV3RGF0YS5oYXNDaGlsZHJlbihbJ24nXSkgJiYgbmV3RGF0YS5jaGlsZCgnbicpLnZhbCgpIDwgN1wiLFxuICAgICAgICAgICAgICAgICBuOiB7Jy52YWxpZGF0ZSc6IFwibmV3RGF0YS5pc051bWJlcigpXCJ9LFxuICAgICAgICAgICAgICAgICAnJG90aGVyJzogeycudmFsaWRhdGUnOiBcImZhbHNlXCJ9fSB9LFxuICAgICAgeyBkYXRhOiBcInR5cGUgQmlnZ2VyIGV4dGVuZHMgTnVtYmVyIHt2YWxpZGF0ZSgpIHsgcmV0dXJuIHRoaXMgPiBwcmlvcih0aGlzKTsgfX1cIiArXG4gICAgICAgIFwidHlwZSBUIHsgdHM6IEJpZ2dlciB9XCIsXG4gICAgICAgIGV4cGVjdDogeycudmFsaWRhdGUnOiBcIm5ld0RhdGEuaGFzQ2hpbGRyZW4oWyd0cyddKVwiLFxuICAgICAgICAgICAgICAgICB0czogeycudmFsaWRhdGUnOiBcIm5ld0RhdGEuaXNOdW1iZXIoKSAmJiBuZXdEYXRhLnZhbCgpID4gZGF0YS52YWwoKVwifSxcbiAgICAgICAgICAgICAgICAgJyRvdGhlcic6IHsnLnZhbGlkYXRlJzogXCJmYWxzZVwifX0gfSxcbiAgICAgIHsgZGF0YTogXCJ0eXBlIFQge2E6IFN0cmluZywgYjogU3RyaW5nLCBjOiBTdHJpbmd9XCIsXG4gICAgICAgIGV4cGVjdDogeycudmFsaWRhdGUnOiBcIm5ld0RhdGEuaGFzQ2hpbGRyZW4oWydhJywgJ2InLCAnYyddKVwiLFxuICAgICAgICAgICAgICAgICBhOiB7Jy52YWxpZGF0ZSc6IFwibmV3RGF0YS5pc1N0cmluZygpXCJ9LFxuICAgICAgICAgICAgICAgICBiOiB7Jy52YWxpZGF0ZSc6IFwibmV3RGF0YS5pc1N0cmluZygpXCJ9LFxuICAgICAgICAgICAgICAgICBjOiB7Jy52YWxpZGF0ZSc6IFwibmV3RGF0YS5pc1N0cmluZygpXCJ9LFxuICAgICAgICAgICAgICAgICAnJG90aGVyJzogeycudmFsaWRhdGUnOiBcImZhbHNlXCJ9fSB9LFxuICAgICAgeyBkYXRhOiBcInR5cGUgQiB7IGZvbzogTnVtYmVyIH0gdHlwZSBUIGV4dGVuZHMgQiB7IGJhcjogU3RyaW5nIH1cIixcbiAgICAgICAgZXhwZWN0OiB7Jy52YWxpZGF0ZSc6IFwibmV3RGF0YS5oYXNDaGlsZHJlbihbJ2ZvbycsICdiYXInXSlcIixcbiAgICAgICAgICAgICAgICAgZm9vOiB7Jy52YWxpZGF0ZSc6IFwibmV3RGF0YS5pc051bWJlcigpXCJ9LFxuICAgICAgICAgICAgICAgICBiYXI6IHsnLnZhbGlkYXRlJzogXCJuZXdEYXRhLmlzU3RyaW5nKClcIn0sXG4gICAgICAgICAgICAgICAgICckb3RoZXInOiB7Jy52YWxpZGF0ZSc6IFwiZmFsc2VcIn19IH0sXG5cbiAgICAgIHsgZGF0YTogXCJ0eXBlIFQge246IE51bWJlciwgeDogTWFwPFN0cmluZywgTnVtYmVyPn1cIixcbiAgICAgICAgZXhwZWN0OiB7Jy52YWxpZGF0ZSc6IFwibmV3RGF0YS5oYXNDaGlsZHJlbihbJ24nXSlcIixcbiAgICAgICAgICAgICAgICAgbjogeycudmFsaWRhdGUnOiBcIm5ld0RhdGEuaXNOdW1iZXIoKVwifSxcbiAgICAgICAgICAgICAgICAgeDogeycka2V5MSc6IHsnLnZhbGlkYXRlJzogXCJuZXdEYXRhLmlzTnVtYmVyKClcIn0sXG4gICAgICAgICAgICAgICAgICAgICAnLnZhbGlkYXRlJzogXCJuZXdEYXRhLmhhc0NoaWxkcmVuKClcIiB9LFxuICAgICAgICAgICAgICAgICAnJG90aGVyJzogeycudmFsaWRhdGUnOiBcImZhbHNlXCJ9fSB9LFxuICAgICAgeyBkYXRhOiBcInR5cGUgVCB7eDogTWFwPFN0cmluZywgTnVtYmVyPn1cIixcbiAgICAgICAgZXhwZWN0OiB7Jy52YWxpZGF0ZSc6IFwibmV3RGF0YS5oYXNDaGlsZHJlbigpXCIsXG4gICAgICAgICAgICAgICAgIHg6IHsnJGtleTEnOiB7Jy52YWxpZGF0ZSc6IFwibmV3RGF0YS5pc051bWJlcigpXCJ9LFxuICAgICAgICAgICAgICAgICAgICAgJy52YWxpZGF0ZSc6IFwibmV3RGF0YS5oYXNDaGlsZHJlbigpXCIgfSxcbiAgICAgICAgICAgICAgICAgJyRvdGhlcic6IHsnLnZhbGlkYXRlJzogXCJmYWxzZVwifX0gfSxcbiAgICAgIHsgZGF0YTogXCJ0eXBlIFNtYWxsU3RyaW5nIGV4dGVuZHMgU3RyaW5nIHsgdmFsaWRhdGUoKSB7IHRoaXMubGVuZ3RoIDwgMzIgfSB9IFwiICtcbiAgICAgICAgICAgICAgXCJ0eXBlIFQge3g6IE1hcDxTbWFsbFN0cmluZywgTnVtYmVyPn1cIixcbiAgICAgICAgZXhwZWN0OiB7Jy52YWxpZGF0ZSc6IFwibmV3RGF0YS5oYXNDaGlsZHJlbigpXCIsXG4gICAgICAgICAgICAgICAgIHg6IHsnJGtleTEnOiB7Jy52YWxpZGF0ZSc6IFwiJGtleTEubGVuZ3RoIDwgMzIgJiYgbmV3RGF0YS5pc051bWJlcigpXCJ9LFxuICAgICAgICAgICAgICAgICAgICAgJy52YWxpZGF0ZSc6IFwibmV3RGF0YS5oYXNDaGlsZHJlbigpXCIgfSxcbiAgICAgICAgICAgICAgICAgJyRvdGhlcic6IHsnLnZhbGlkYXRlJzogXCJmYWxzZVwifX0gfSxcbiAgICAgIHsgZGF0YTogXCJ0eXBlIE0gZXh0ZW5kcyBNYXA8U3RyaW5nLCBOdW1iZXI+OyB0eXBlIFQgeyB4OiBNIH1cIixcbiAgICAgICAgZXhwZWN0OiB7Jy52YWxpZGF0ZSc6IFwibmV3RGF0YS5oYXNDaGlsZHJlbigpXCIsXG4gICAgICAgICAgICAgICAgICckb3RoZXInOiB7Jy52YWxpZGF0ZSc6IFwiZmFsc2VcIn0sXG4gICAgICAgICAgICAgICAgICd4Jzogeycka2V5MSc6IHsnLnZhbGlkYXRlJzogXCJuZXdEYXRhLmlzTnVtYmVyKClcIn0sXG4gICAgICAgICAgICAgICAgICAgICAgICcudmFsaWRhdGUnOiBcIm5ld0RhdGEuaGFzQ2hpbGRyZW4oKVwiIH19IH0sXG4gICAgICB7IGRhdGE6IFwidHlwZSBQYWlyPFgsIFk+IHsgZmlyc3Q6IFgsIHNlY29uZDogWSB9IHR5cGUgVCBleHRlbmRzIFBhaXI8U3RyaW5nLCBOdW1iZXI+O1wiLFxuICAgICAgICBleHBlY3Q6IHsnLnZhbGlkYXRlJzogXCJuZXdEYXRhLmhhc0NoaWxkcmVuKFsnZmlyc3QnLCAnc2Vjb25kJ10pXCIsXG4gICAgICAgICAgICAgICAgICdmaXJzdCc6IHsnLnZhbGlkYXRlJzogXCJuZXdEYXRhLmlzU3RyaW5nKClcIn0sXG4gICAgICAgICAgICAgICAgICdzZWNvbmQnOiB7Jy52YWxpZGF0ZSc6IFwibmV3RGF0YS5pc051bWJlcigpXCJ9LFxuICAgICAgICAgICAgICAgICAnJG90aGVyJzogeycudmFsaWRhdGUnOiBcImZhbHNlXCJ9fSB9LFxuXG4gICAgICB7IGRhdGE6IFwidHlwZSBYIHsgYTogTnVtYmVyLCB2YWxpZGF0ZSgpIHsgdGhpcy5hID09IGtleSgpIH0gfSB0eXBlIFQgZXh0ZW5kcyBYW107XCIsXG4gICAgICAgIGV4cGVjdDogeycka2V5MSc6IHsnLnZhbGlkYXRlJzogXCJuZXdEYXRhLmhhc0NoaWxkcmVuKFsnYSddKSAmJiBuZXdEYXRhLmNoaWxkKCdhJykudmFsKCkgPT0gJGtleTFcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICdhJzogeycudmFsaWRhdGUnOiBcIm5ld0RhdGEuaXNOdW1iZXIoKVwifSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICckb3RoZXInOiB7Jy52YWxpZGF0ZSc6IFwiZmFsc2VcIn19LFxuICAgICAgICAgICAgICAgICAnLnZhbGlkYXRlJzogXCJuZXdEYXRhLmhhc0NoaWxkcmVuKClcIlxuICAgICAgICAgICAgICAgIH0gfSxcbiAgICAgIHsgZGF0YTogXCJ0eXBlIFggeyBhOiBOdW1iZXIsIHZhbGlkYXRlKCkgeyB0aGlzLmEgPT0ga2V5KCkgfSB9IHR5cGUgVCB7IHg6IFggfVwiLFxuICAgICAgICBleHBlY3Q6IHsneCc6IHsnLnZhbGlkYXRlJzogXCJuZXdEYXRhLmhhc0NoaWxkcmVuKFsnYSddKSAmJiBuZXdEYXRhLmNoaWxkKCdhJykudmFsKCkgPT0gJ3gnXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICdhJzogeycudmFsaWRhdGUnOiBcIm5ld0RhdGEuaXNOdW1iZXIoKVwifSxcbiAgICAgICAgICAgICAgICAgICAgICAgJyRvdGhlcic6IHsnLnZhbGlkYXRlJzogXCJmYWxzZVwifX0sXG4gICAgICAgICAgICAgICAgICckb3RoZXInOiB7Jy52YWxpZGF0ZSc6IFwiZmFsc2VcIn0sXG4gICAgICAgICAgICAgICAgICcudmFsaWRhdGUnOiBcIm5ld0RhdGEuaGFzQ2hpbGRyZW4oWyd4J10pXCJcbiAgICAgICAgICAgICAgICB9IH0sXG5cbiAgICAgIHsgZGF0YTogXCJ0eXBlIFQgZXh0ZW5kcyBTdHJpbmcgeyB2YWxpZGF0ZSgpIHsgcm9vdCA9PSAnbmV3JyAmJiBwcmlvcihyb290KSA9PSAnb2xkJyB9IH1cIiArXG4gICAgICAgICAgICAgIFwicGF0aCAvdC94IGlzIEFueSB7IHJlYWQoKSB7IHJvb3QgPT0gJ29sZCcgfSB9XCIsXG4gICAgICAgIGV4cGVjdDogeycudmFsaWRhdGUnOiBcIm5ld0RhdGEuaXNTdHJpbmcoKSAmJiBuZXdEYXRhLnBhcmVudCgpLnZhbCgpID09ICduZXcnICYmIHJvb3QudmFsKCkgPT0gJ29sZCdcIixcbiAgICAgICAgICAgICAgICAgJ3gnOiB7Jy5yZWFkJzogXCJyb290LnZhbCgpID09ICdvbGQnXCJ9XG4gICAgICAgICAgICAgICAgfSB9LFxuICAgIF07XG5cbiAgICBoZWxwZXIuZGF0YURyaXZlblRlc3QodGVzdHMsIGZ1bmN0aW9uKGRhdGEsIGV4cGVjdCkge1xuICAgICAgdmFyIHN5bWJvbHMgPSBwYXJzZShkYXRhICsgXCIgcGF0aCAvdCBpcyBUO1wiKTtcbiAgICAgIHZhciBnZW4gPSBuZXcgYm9sdC5HZW5lcmF0b3Ioc3ltYm9scyk7XG4gICAgICB2YXIgcnVsZXMgPSBnZW4uZ2VuZXJhdGVSdWxlcygpO1xuICAgICAgaWYgKGV4cGVjdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGFzc2VydC5kZWVwRXF1YWwocnVsZXMsIHtcInJ1bGVzXCI6IHt9fSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhc3NlcnQuZGVlcEVxdWFsKHJ1bGVzLCB7XCJydWxlc1wiOiB7dDogZXhwZWN0fX0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcblxuICBzdWl0ZShcImV4dGVuZFZhbGlkYXRvclwiLCBmdW5jdGlvbigpIHtcbiAgICB2YXIgdGVzdHMgPSBbXG4gICAgICB7IGRhdGE6IHt0YXJnZXQ6IHt9LCBzcmM6IHt9fSxcbiAgICAgICAgZXhwZWN0OiB7fSB9LFxuICAgICAgeyBkYXRhOiB7dGFyZ2V0OiB7fSwgc3JjOiB7Jy54JzogWzFdfX0sXG4gICAgICAgIGV4cGVjdDogeycueCc6IFsxXX0gfSxcbiAgICAgIHsgZGF0YToge3RhcmdldDogeycueCc6IFsxXX0sIHNyYzogeycueCc6IFsyXX19LFxuICAgICAgICBleHBlY3Q6IHsnLngnOiBbMSwgMl19IH0sXG4gICAgICB7IGRhdGE6IHt0YXJnZXQ6IHsnLngnOiBbMV19LCBzcmM6IHsnLngnOiBbMl0sIGM6IHsnLngnOiBbM119fX0sXG4gICAgICAgIGV4cGVjdDogeycueCc6IFsxLCAyXSwgYzogeycueCc6IFszXX19IH0sXG4gICAgICB7IGRhdGE6IHt0YXJnZXQ6IHsnLngnOiBbMV0sIGM6IHsnLngnOiBbMl19fSwgc3JjOiB7YzogeycueCc6IFszXX19fSxcbiAgICAgICAgZXhwZWN0OiB7Jy54JzogWzFdLCBjOiB7Jy54JzogWzIsIDNdfX0gfSxcbiAgICAgIHsgZGF0YToge3RhcmdldDoge30sIHNyYzoge2E6IHtiOiB7Yzoge2Q6IHsnLngnOiBbMV0sIGU6IHsnLngnOiBbMl19fX19fX19LFxuICAgICAgICBleHBlY3Q6IHthOiB7Yjoge2M6IHtkOiB7Jy54JzogWzFdLCBlOiB7Jy54JzogWzJdfX19fX19IH0sXG4gICAgXTtcblxuICAgIGhlbHBlci5kYXRhRHJpdmVuVGVzdCh0ZXN0cywgZnVuY3Rpb24oZGF0YSwgZXhwZWN0KSB7XG4gICAgICBnZW5lcmF0b3IuZXh0ZW5kVmFsaWRhdG9yKGRhdGEudGFyZ2V0LCBkYXRhLnNyYyk7XG4gICAgICBhc3NlcnQuZGVlcEVxdWFsKGRhdGEudGFyZ2V0LCBleHBlY3QpO1xuICAgIH0pO1xuICB9KTtcblxuICBzdWl0ZShcIm1hcFZhbGlkYXRvclwiLCBmdW5jdGlvbigpIHtcbiAgICB2YXIgdGVzdHMgPSBbXG4gICAgICB7IGRhdGE6IHsnLngnOiAnYSd9LCBleHBlY3Q6IHsnLngnOiAnYSsnfSB9LFxuICAgICAgeyBkYXRhOiB7Jy54JzogJ2InfSwgZXhwZWN0OiB7fSB9LFxuICAgIF07XG5cbiAgICBoZWxwZXIuZGF0YURyaXZlblRlc3QodGVzdHMsIGZ1bmN0aW9uKGRhdGEsIGV4cGVjdCkge1xuICAgICAgZ2VuZXJhdG9yLm1hcFZhbGlkYXRvcihkYXRhLCBmdW5jdGlvbih2YWx1ZSwgcHJvcCkge1xuICAgICAgICBpZiAodmFsdWUgPT09ICdiJykge1xuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlICsgJysnO1xuICAgICAgfSk7XG4gICAgICBhc3NlcnQuZGVlcEVxdWFsKGRhdGEsIGV4cGVjdCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIHN1aXRlKFwiU2NoZW1hIEdlbmVyYXRpb24gRXJyb3JzXCIsIGZ1bmN0aW9uKCkge1xuICAgIHZhciB0ZXN0cyA9IFtcbiAgICAgIHsgZGF0YTogXCJcIixcbiAgICAgICAgZXhwZWN0OiAvYXQgbGVhc3Qgb25lIHBhdGgvIH0sXG4gICAgICB7IGRhdGE6IFwidHlwZSBTaW1wbGUgZXh0ZW5kcyBTdHJpbmcge2E6IFN0cmluZ30gcGF0aCAveCBpcyBTaW1wbGU7XCIsXG4gICAgICAgIGV4cGVjdDogL3Byb3BlcnRpZXMuKmV4dGVuZC8gfSxcbiAgICAgIHsgZGF0YTogXCJwYXRoIC95IHsgaW5kZXgoKSB7IHJldHVybiAxOyB9fVwiLFxuICAgICAgICBleHBlY3Q6IC9pbmRleC4qc3RyaW5nL2kgfSxcbiAgICAgIHsgZGF0YTogXCJwYXRoIC94IHsgd3JpdGUoKSB7IHJldHVybiB1bmRlZmluZWRGdW5jKCk7IH19XCIsXG4gICAgICAgIGV4cGVjdDogL3VuZGVmaW5lZC4qZnVuY3Rpb24vaSB9LFxuICAgICAgeyBkYXRhOiBcInBhdGggL3ggaXMgTm9TdWNoVHlwZSB7fVwiLFxuICAgICAgICBleHBlY3Q6IC9ObyB0eXBlLipOb1N1Y2hUeXBlLyB9LFxuICAgICAgeyBkYXRhOiBcInBhdGggL3ggeyB1bnN1cHBvcnRlZCgpIHsgdHJ1ZSB9IH1cIixcbiAgICAgICAgd2FybjogL3Vuc3VwcG9ydGVkIG1ldGhvZC9pIH0sXG5cbiAgICAgIHsgZGF0YTogXCJwYXRoIC94IHsgdmFsaWRhdGUoKSB7IHJldHVybiB0aGlzLnRlc3QoMTIzKTsgfSB9XCIsXG4gICAgICAgIGV4cGVjdDogL2NvbnZlcnQgdmFsdWUvaSB9LFxuICAgICAgeyBkYXRhOiBcInBhdGggL3ggeyB2YWxpZGF0ZSgpIHsgcmV0dXJuIHRoaXMudGVzdCgnYS8nKTsgfSB9XCIsXG4gICAgICAgIGV4cGVjdDogL2NvbnZlcnQgdmFsdWUvaSB9LFxuICAgICAgeyBkYXRhOiBcInBhdGggL3ggeyB2YWxpZGF0ZSgpIHsgcmV0dXJuIHRoaXMudGVzdCgnL2EvJyk7IH0gfVwiLFxuICAgICAgICBleHBlY3Q6IC9jb252ZXJ0IHZhbHVlL2kgfSxcblxuICAgICAgeyBkYXRhOiBcImZ1bmN0aW9uIGYoYSkgeyByZXR1cm4gZihhKTsgfSBwYXRoIC8geyB2YWxpZGF0ZSgpIHsgcmV0dXJuIGYoMSk7IH19XCIsXG4gICAgICAgIGV4cGVjdDogL3JlY3Vyc2l2ZS9pIH0sXG4gICAgICB7IGRhdGE6IFwidHlwZSBYIHsgJG46IE51bWJlciwgJHM6IFN0cmluZyB9IHBhdGggLyBpcyBYO1wiLFxuICAgICAgICBleHBlY3Q6IC93aWxkIHByb3BlcnR5LyB9LFxuICAgICAgeyBkYXRhOiBcInR5cGUgWCB7ICQkbjogTnVtYmVyIH0gcGF0aCAvIGlzIFg7XCIsXG4gICAgICAgIGV4cGVjdDogL3Byb3BlcnR5IG5hbWVzL2kgfSxcbiAgICAgIHsgZGF0YTogXCJ0eXBlIFggeyAnXFx4MDEnOiBOdW1iZXIgfSBwYXRoIC8gaXMgWDtcIixcbiAgICAgICAgZXhwZWN0OiAvcHJvcGVydHkgbmFtZXMvaSB9LFxuICAgICAgeyBkYXRhOiBcInBhdGggLyBpcyBNYXA7XCIsXG4gICAgICAgIGV4cGVjdDogL05vIHR5cGUuKm5vbi1nZW5lcmljLyB9LFxuICAgICAgeyBkYXRhOiBcInR5cGUgUGFpcjxYLCBZPiB7YTogWCwgYjogWX0gcGF0aCAvIGlzIFBhaXI7XCIsXG4gICAgICAgIGV4cGVjdDogL05vIHR5cGUuKm5vbi1nZW5lcmljLyB9LFxuICAgICAgeyBkYXRhOiBcInBhdGggLyBpcyBTdHJpbmc8TnVtYmVyPjtcIixcbiAgICAgICAgZXhwZWN0OiAvTm8gdHlwZS4qZ2VuZXJpYy8gfSxcbiAgICAgIHsgZGF0YTogXCJwYXRoIC8gaXMgTWFwPE9iamVjdCwgTnVtYmVyPjtcIixcbiAgICAgICAgZXhwZWN0OiAvbXVzdCBkZXJpdmUgZnJvbSBTdHJpbmcvIH0sXG4gICAgICB7IGRhdGE6IFwicGF0aCAvIHsgd3JpdGUoKSB7IHRydWUgfSBjcmVhdGUoKSB7IHRydWUgfSB9XCIsXG4gICAgICAgIGV4cGVjdDogL3dyaXRlLWFsaWFzaW5nLipjcmVhdGUvaSB9LFxuICAgICAgeyBkYXRhOiBcInBhdGggLyB7IHdyaXRlKCkgeyB0cnVlIH0gdXBkYXRlKCkgeyB0cnVlIH0gfVwiLFxuICAgICAgICBleHBlY3Q6IC93cml0ZS1hbGlhc2luZy4qdXBkYXRlL2kgfSxcbiAgICAgIHsgZGF0YTogXCJwYXRoIC8geyB3cml0ZSgpIHsgdHJ1ZSB9IGRlbGV0ZSgpIHsgdHJ1ZSB9IH1cIixcbiAgICAgICAgZXhwZWN0OiAvd3JpdGUtYWxpYXNpbmcuKmRlbGV0ZS9pIH0sXG4gICAgXTtcblxuICAgIGhlbHBlci5kYXRhRHJpdmVuVGVzdCh0ZXN0cywgZnVuY3Rpb24oZGF0YSwgZXhwZWN0LCB0KSB7XG4gICAgICBsb2dnZXIucmVzZXQoKTtcbiAgICAgIGxvZ2dlci5zaWxlbnQoKTtcbiAgICAgIGxldCBzeW1ib2xzID0gcGFyc2UoZGF0YSk7XG4gICAgICBsZXQgZ2VuID0gbmV3IGJvbHQuR2VuZXJhdG9yKHN5bWJvbHMpO1xuICAgICAgbGV0IGxhc3RFcnJvcjogc3RyaW5nO1xuXG4gICAgICB0cnkge1xuICAgICAgICBnZW4uZ2VuZXJhdGVSdWxlcygpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoIWV4cGVjdCkge1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdEVycm9yID0gbG9nZ2VyLmdldExhc3RNZXNzYWdlKCkgfHwgZS5tZXNzYWdlO1xuICAgICAgICBhc3NlcnQubWF0Y2gobGFzdEVycm9yLCBleHBlY3QpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZXhwZWN0KSB7XG4gICAgICAgIGFzc2VydC5mYWlsKHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBcIk5vIGV4Y2VwdGlvbiB0aHJvd24uXCIpO1xuICAgICAgfVxuICAgICAgaWYgKHQud2Fybikge1xuICAgICAgICBhc3NlcnQubWF0Y2gobG9nZ2VyLmdldExhc3RNZXNzYWdlKCksIHQud2Fybik7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufSk7XG4iXX0=
